<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用Java语言实现简单的垃圾回收功能]]></title>
    <url>%2F2019%2F05%2F29%2Fgc01%2F</url>
    <content type="text"><![CDATA[本人的开源项目pip-boy一直缺少垃圾回收功能，这让它看起来更像是一个解释器而非虚拟机，本篇将介绍如何实现简单的垃圾回收功能。 理论基础本人要实现的算法不是基于引用计数的，而是基于tracing，具体来说就是Mark Sweep GC算法的简易实现，参考自垃圾回收的算法与实现一书。 标记首先看看根对象有哪些： 虚拟机栈（栈帧中的本地变量表）中的引用的对象； 方法区中的类静态属性引用的对象； 方法区中的常量引用的对象； 本地方法栈中JNI引用的对象； 标记阶段，就是将活跃的对象进行标记，简单的方法就是将对象的mark字段设置为true，默认为false； 通常深度优先搜索比广度优先搜索更能压低内存使用量，所以在标记阶段经常使用深度优先搜索； 清除清除阶段遍历整个堆，将没有标记为true的对象进行回收。 分配分配就是将回收的内存再利用。 合并如果回收的内存在地址上是连续的，那么可以将这些内存合并成一个大的内存，这样缓和了碎片化。 引用检测概论R大关于“找出栈上指针/引用”的回答对各种商业级别的虚拟机如何进行引用检测进行了说明。 该文介绍了虚拟机GC的实现，包括了保守式GC（conservative GC）、半保守式GC/根上保守GC（conservative with respect to the roots）、准确式GC（precise GC、exact GC、accurate GC或者type accurate GC）。像HotSpot这种虚拟机采用的是准确式GC，其中有两句话是这么说的： 在HotSpot中，对象的类型信息里有记录自己的OopMap，记录了在该类型的对象内什么偏移量上是什么类型的数据。所以从对象开始向外的扫描可以是准确的；这些数据是在类加载过程中计算得到的； 每个被JIT编译过后的方法也会在一些特定的位置记录下OopMap，记录了执行到该方法的某条指令的时候，栈上和寄存器里哪些位置是引用。这样GC在扫描栈的时候就会查询这些OopMap就知道哪里是引用了； 文中进一步指出了这些特定位置(即安全点)是： 循环的末尾； 方法临返回前/调用方法的call指令后； 可能抛异常的位置； native方法实现首先构造一个实例： 123456789101112131415161718192021222324252627282930public class GcTest01 &#123; public static B newInstance() &#123; A a = new A(); return a.getB(); &#125; public static void main(String[] args) &#123; B bb = newInstance(); System.gc(); &#125; static class A &#123; int x = 77; B b = new B(); public B getB() &#123; return b; &#125; &#125; static class B &#123; int y0 = 8; int y1 = 18; int y2 = 28; int y3 = 38; int y4 = 48; int y5 = 58; int y6 = 68; &#125;&#125; newInstance()执行结束后，对象a不再是根对象，可以被回收处理，而对象a内部生成的B类对象由于被main方法内的变量bb引用，属于根对象，不被回收。 本人进行的工作很简单：实现本地方法System.gc()，用它来主动完成基本的垃圾回收处理功能。当然，System.gc()实际原理非常复杂，这里只为实现简单的功能。 查看System.gc()源码首先看一看整个方法的调用链： 当调用方法System.gc()后，实际上运行了下列代码： 123public static void gc() &#123; Runtime.getRuntime().gc();&#125; 继续追踪，getRuntime()会返回Runtime对象： 123public static Runtime getRuntime() &#123; return currentRuntime;&#125; 而currentRuntime是Runtime类中的私有字段： 1private static Runtime currentRuntime = new Runtime(); gc()是Runtime类下的一个native方法： 1public native void gc(); 这不是一个静态方法，且返回类型为void。 native方法框架首先按照之前站内文Java虚拟机之本地方法调用实现介绍的方法，搭好native方法的框架。 在native_包下，创建java.lang.JRuntime类： 123456789101112public class JRuntime &#123; private static JNINativeMethod[] methods = &#123; new JNINativeMethod("gc", "()V", new JVM_ENTRY.JVM_GC()), &#125;; public static void Java_java_lang_Runtime_registerNatives(String className) &#123; for (JNINativeMethod jniNativeMethod : methods) &#123; Registry.registerMethod(className, jniNativeMethod.getMethodName(), jniNativeMethod.getMethodDescriptor(), jniNativeMethod.getNativeMethod()); &#125; &#125;&#125; Hotspot并不存在Java_java_lang_Runtime_registerNatives()，这里只是为了方便注册进行的简便处理。 接下来在INVOKE_NATIVE内添加代码： 12if (className.equals("java/lang/Runtime")) JRuntime.Java_java_lang_Runtime_registerNatives(className); 框架就搭好了，现在只要在JVM_ENTRY实现gc的本地方法JVM_GC()即可。 垃圾回收算法实现小结本垃圾回收功能的实现采用了显性的方式，要了解更多商业级别的实现细节可以阅读文末的参考。 参考垃圾回收的算法与实现 R大关于活跃分析(liveness analysis)的回答 R大关于“找出栈上指针/引用”的回答 R大关于“java编译生成字节码产生 ()与()的方法疑问”的回答 附：修复遗留的空指针BUG有的类并不含有静态变量，在编写的过程中，设置了当变量个数大于0，才进行类初始化，代码如下： 12345678public LocalVars_(int maxLocals) &#123; if (maxLocals &gt; 0) &#123; slots = new Slot_[maxLocals]; for (int i = 0; i &lt; slots.length; i++) &#123; slots[i] = new Slot_(); &#125; &#125;&#125; 一旦字段个数为0，instanceKlass.getStaticSlotCount()也为0，此时生成的LocalVars对象的slots字段就为null，这将在后续程序运行的过程中，产生错误。于是添加判断语句，修复该错误。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin名称遮蔽等问题简要分析]]></title>
    <url>%2F2019%2F05%2F02%2Fname-shadowed%2F</url>
    <content type="text"><![CDATA[本篇探索Kotlin中存在的一些关于方法参数的问题。 名称遮蔽首先看这样一个例子： 123456789101112fun add(name: Int) &#123; val name = 3 if (name &gt; 2) &#123; val name = "nihao" println(name) &#125; println(name)&#125;fun main(args: Array&lt;String&gt;) &#123; add(1)&#125; 在形参已经命名为name的情况下，方法体以及方法体中的if语句块中，都重复声明了name变量，这就是名称遮蔽，是Kotlin提供的一种特性。 反编译后部分结果如下： 123456789101112131415161718192021public static final void add(int); descriptor: (I)V flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL Code: stack=2, locals=4, args_size=1 0: iconst_3 1: istore_1 2: nop 3: ldc #8 // String nihao 5: astore_2 6: iconst_0 7: istore_3 8: getstatic #14 // Field java/lang/System.out:Ljava/io/PrintStream; 11: aload_2 12: invokevirtual #20 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V 15: iconst_0 16: istore_2 17: getstatic #14 // Field java/lang/System.out:Ljava/io/PrintStream; 20: iload_1 21: invokevirtual #22 // Method java/io/PrintStream.println:(I)V 24: return 可以看出，val name = 3这条语句会编译成将3这个值istore_1上，而参数中的name是存放在局部变量表的0号位置的，所以它们不冲突。 val name = &quot;nihao&quot;这一句会将字符串“nihao”进行astore_2操作，即这里声明的变量是存放在局部变量表的2号位置的，同样不冲突，当这个if语句结束后，第15和16句似乎做了一个清零的动作。 不过这里有个小疑问，标号为第6、第7的字节码指令有何作用？ 构造方法的参数前添加var/val与不添加的区别观察下面的例子： 123456789101112131415161718class A(name: Int) &#123; var selfname = name fun aA() &#123; println(selfname) &#125;&#125;class B(var name: Int) &#123; fun bB() &#123; println(name) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; A(7).aA() B(8).bB()&#125; 来看看A和B反编译后构造方法的区别，首先是A： 1234567891011public kotlin_git.A(int); descriptor: (I)V flags: ACC_PUBLIC Code: stack=2, locals=2, args_size=2 0: aload_0 1: invokespecial #31 // Method java/lang/Object."&lt;init&gt;":()V 4: aload_0 5: iload_1 6: putfield #10 // Field selfname:I 9: return 接下来是B： 1234567891011public kotlin_git.B(int); descriptor: (I)V flags: ACC_PUBLIC Code: stack=2, locals=2, args_size=2 0: aload_0 1: invokespecial #31 // Method java/lang/Object."&lt;init&gt;":()V 4: aload_0 5: iload_1 6: putfield #10 // Field name:I 9: return 从反编译的结果来看，A，B两种写法做了同样的事，它们都涉及到一个关键的字节码指令putfield，不同之处在于，一个为selfname赋值，一个为name赋值。 所以构造方法的参数前添加var/val与不添加的区别在于，是否通过putfield将构造方法内的局部变量赋值给类的字段。如果不添加var/val，类的闭包结构将无法直接调用参数变量。 小结本篇解析了在实际写码过程中发现的几个小问题。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Groupcache(一)：入门]]></title>
    <url>%2F2019%2F04%2F29%2Fgroupcache01%2F</url>
    <content type="text"><![CDATA[本文是研究Groupcache的第一篇，简单跑个Groupcache的例子，对一些代码进行简要分析。 示例 &amp; 运行示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( "fmt" "io/ioutil" "log" "net/http" "github.com/golang/groupcache")func generateThumbnail(fileName string) []byte &#123; result, err := ioutil.ReadFile(fileName) if err != nil &#123; fmt.Println(err.Error()) return nil &#125; return result&#125;func main() &#123; // 声明自己和自己的peers me := "http://127.0.0.1:8080" peers := groupcache.NewHTTPPool(me) peers.Set("http://127.0.0.1:8081", "http://127.0.0.1:8082", "http://127.0.0.1:8083") // 创建Group实例 var thumbNails = groupcache.NewGroup("thumbnails", 64&lt;&lt;20, groupcache.GetterFunc( func(ctx groupcache.Context, key string, dest groupcache.Sink) error &#123; fileName := key dest.SetBytes(generateThumbnail(fileName)) return nil &#125;)) // 路由 http.HandleFunc("/thumbnails/", func(rw http.ResponseWriter, r *http.Request) &#123; var data []byte thumbNails.Get(nil, r.URL.Path[len("/thumbnails/"):], groupcache.AllocatingByteSliceSink(&amp;data)) rw.Write([]byte(data)) &#125;) // 启动服务器 log.Fatal(http.ListenAndServe(me[len("http://"):], nil))&#125; 这段代码补全自：https://talks.golang.org/2013/oscon-dl.slide#45 运行步骤： 本人先在工程目录下放上一张帅气的自拍，文件名为big-file.jpg，运行程序后服务器启动，在浏览器输入 http://localhost:8080/thumbnails/big-file.jpg 后，帅气光芒迸发； 将帅气自拍从本地删除，另起一个server，该server监控8081端口，在浏览器输入 http://localhost:8081/thumbnails/big-file.jpg ，虽然本地并不存在big-file.jpg，但是由于自拍已然缓存，所以帅气光芒依旧迸发； 代码简单分析将目光聚焦到路由函数HandleFunc()中，可以看到关键的处理函数是Get()，通过它，data最终将获得被写入的值(缓存和本地都不能得到值将打印错误)。 走进Get()内部： 123456789101112131415161718192021222324252627func (g *Group) Get(ctx Context, key string, dest Sink) error &#123; g.peersOnce.Do(g.initPeers) g.Stats.Gets.Add(1) if dest == nil &#123; return errors.New("groupcache: nil dest Sink") &#125; value, cacheHit := g.lookupCache(key) if cacheHit &#123; g.Stats.CacheHits.Add(1) return setSinkView(dest, value) &#125; // Optimization to avoid double unmarshalling or copying: keep // track of whether the dest was already populated. One caller // (if local) will set this; the losers will not. The common // case will likely be one caller. destPopulated := false value, destPopulated, err := g.load(ctx, key, dest) if err != nil &#123; return err &#125; if destPopulated &#123; return nil &#125; return setSinkView(dest, value)&#125; ctx是一个opaque值，通常可以设为nil；dest是一个Sink，Sink作为一个接口集合了一些数据处理的方法。在这里代码传入了一个groupcache.AllocatingByteSliceSink(&amp;data)方法，该方法返回的是一个实现了Sink接口方法的结构体实例，结构体长这样： 1234type allocBytesSink struct &#123; dst *[]byte v ByteView&#125; 所以dest就是该结构体实例，实例的dst字段指向传入的data，Get函数会调用g.lookupCache(key)，调用成功说明在缓存里拿到了值，用setSinkView()设置之并返回。 如果上一步没有成功，就要采用g.load(ctx, key, dest)来获取需要设置的value了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// load loads key either by invoking the getter locally or by sending it to another machine.func (g *Group) load(ctx Context, key string, dest Sink) (value ByteView, destPopulated bool, err error) &#123; g.Stats.Loads.Add(1) viewi, err := g.loadGroup.Do(key, func() (interface&#123;&#125;, error) &#123; // Check the cache again because singleflight can only dedup calls // that overlap concurrently. It's possible for 2 concurrent // requests to miss the cache, resulting in 2 load() calls. An // unfortunate goroutine scheduling would result in this callback // being run twice, serially. If we don't check the cache again, // cache.nbytes would be incremented below even though there will // be only one entry for this key. // // Consider the following serialized event ordering for two // goroutines in which this callback gets called twice for hte // same key: // 1: Get("key") // 2: Get("key") // 1: lookupCache("key") // 2: lookupCache("key") // 1: load("key") // 2: load("key") // 1: loadGroup.Do("key", fn) // 1: fn() // 2: loadGroup.Do("key", fn) // 2: fn() if value, cacheHit := g.lookupCache(key); cacheHit &#123; g.Stats.CacheHits.Add(1) return value, nil &#125; g.Stats.LoadsDeduped.Add(1) var value ByteView var err error if peer, ok := g.peers.PickPeer(key); ok &#123; value, err = g.getFromPeer(ctx, peer, key) if err == nil &#123; g.Stats.PeerLoads.Add(1) return value, nil &#125; g.Stats.PeerErrors.Add(1) // TODO(bradfitz): log the peer's error? keep // log of the past few for /groupcachez? It's // probably boring (normal task movement), so not // worth logging I imagine. &#125; value, err = g.getLocally(ctx, key, dest) if err != nil &#123; g.Stats.LocalLoadErrs.Add(1) return nil, err &#125; g.Stats.LocalLoads.Add(1) destPopulated = true // only one caller of load gets this return value g.populateCache(key, value, &amp;g.mainCache) return value, nil &#125;) if err == nil &#123; value = viewi.(ByteView) &#125; return&#125; 这里先忽略一些细节，可以看出方法会依次尝试g.getFromPeer(ctx, peer, key)和g.getLocally(ctx, key, dest)来获取值。为了找到和演示代码中创建Group实例时传入的groupcache.GetterFunc参数产生的关联性，这里主要查看一下g.getLocally(ctx, key, dest)的代码： 1234567func (g *Group) getLocally(ctx Context, key string, dest Sink) (ByteView, error) &#123; err := g.getter.Get(ctx, key, dest) if err != nil &#123; return ByteView&#123;&#125;, err &#125; return dest.view()&#125; 代码中g.getter就是参数groupcache.GetterFunc，它定义了如何获取本地数据，可以从磁盘加载，也可以从数据库得到。 小结本篇运行了一个Groupcache例子，熟悉这个分布式KV缓存系统的操作，通过分析相关代码了解了数据的查找流程。 参考oscon-dl.slide#46]]></content>
      <categories>
        <category>Groupcache</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Groupcache</tag>
        <tag>分布式缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机之反射的实现]]></title>
    <url>%2F2019%2F02%2F15%2FJVM_Reflect%2F</url>
    <content type="text"><![CDATA[本人在《Java虚拟机对象探秘》一文提到过Class &amp; Klass &amp; KlassKlass的概念，这里将基于那篇文章的内容对Java反射进行一个简单的实现。 理论基础理论基础来源于RednaxelaFX的解释： 每个Java对象的对象头里，_klass字段会指向一个VM内部用来记录类的元数据用的InstanceKlass对象；InsanceKlass里有个_java_mirror字段，指向该类所对应的Java镜像——java.lang.Class实例。HotSpot VM会给Class对象注入一个隐藏字段“klass”，用于指回到其对应的InstanceKlass对象。这样，klass与mirror之间就有双向引用，可以来回导航。java.lang.Class实例并不负责记录真正的类元数据，而只是对VM内部的InstanceKlass对象的一个包装供Java的反射访问用。 java.lang.Class对象概要在当前的实现中，Class就相当于InstanceKlass，Java API层面的“对象”都是以生成Instance对象的方式开辟内存空间，java.lang.Class也不例外，用一个Instance_对象简单表示之。 接下来看一个例子： 1234567public class ClassTest &#123; public static void main(String args[]) throws Exception &#123; Class intClass = int.class; // 基本类型 Class testClass = ClassTest.class; // 引用类型 Class testClass02 = Class.forName("ClassTest"); &#125;&#125; 反编译后结果： 123456789101112131415public static void main(java.lang.String[]) throws java.lang.Exception; descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=4, args_size=1 0: getstatic #2 // Field java/lang/Integer.TYPE:Ljava/lang/Class; 3: astore_1 4: ldc #3 // class ClassTest 6: astore_2 7: ldc #4 // String ClassTest 9: invokestatic #5 // Method java/lang/Class.forName:(Ljava/lang/String;)Ljava/lang/Class; 12: astore_3 13: return 从这个例子可以看出，基本类型和引用类型通过.class获得java.lang.Class对象的方式是不一样的，基本类型会调用包装类的静态字段TYPE，而引用类型会调用ldc指令。 在InstanceKlass中添加代码`private Instance javamirror;`，它表示在JVM中java.lang.Class的实例，添加get、set方法。 引用类型的java.lang.Class对象这里解决引用类型的java.lang.Class对象问题，修改将在ClassLoader_以及LDC类中进行。 所有Java对象的类对象都是java.lang.Class产生的对象，像一般对象地，先产生InstanceKlass对象，再通过Instance对象开辟内存空间，不同的是，“HotSpot VM会给Class对象注入一个隐藏字段‘klass’”。 1. 初步改造ClassLoader_的构造器代码如下： 12345public ClassLoader_(ClassPath cp) &#123; this.cp = cp; classMap = new HashMap&lt;&gt;(); loadClass("java/lang/Class");&#125; 运行程序，java.lang.Class的InstanceKlass_对象就在生成类加载器时生成好了： 2. InstanceKlass_添加属性用来表示Java镜像这一步就是简单的在代码中添加javamirror属性： 123456789private Instance_ java_mirror_;public Instance_ getJava_mirror_() &#123; return java_mirror_;&#125;public void setJava_mirror_(Instance_ java_mirror_) &#123; this.java_mirror_ = java_mirror_;&#125; 3. 在Instance_注入隐藏属性klass1234567891011// HotSpot VM会给Class对象注入一个隐藏字段“klass”，// 用于指回到其对应的InstanceKlass对象private InstanceKlass_ klass;public InstanceKlass_ getKlass() &#123; return klass;&#125;public void setKlass(InstanceKlass_ klass) &#123; this.klass = klass;&#125; 4. 实现instanceKlass_与mirror之间双向引用这一步主要是对ClassLoader_中的loadClass进行修改： 1234567891011121314151617181920212223public InstanceKlass_ loadClass(String name) &#123; if (classMap.containsKey(name)) &#123; return classMap.get(name); &#125; InstanceKlass_ instanceKlass_; if (name.startsWith("[")) &#123; // 数组类的数据不来自Class文件，运行时生成，要单独考虑 instanceKlass_ = loadArrayClass(name); &#125; else &#123; instanceKlass_ = loadNonArrayClass(name); &#125; // java/lang/Class的InstanceKlass_对象classInstanceKlass_ InstanceKlass_ classInstanceKlass_ = classMap.get("java/lang/Class"); // instanceKlass_里有个_java_mirror字段， // 指向该类所对应的Java镜像——java.lang.Class实例 instanceKlass_.setJava_mirror_(classInstanceKlass_.newObject()); // 找到这个镜像，将其中的隐藏字段klass设置为instanceKlass_ // 实现instanceKlass_与mirror之间就有双向引用，可以来回导航 instanceKlass_.getJava_mirror_().setKlass(instanceKlass_); return instanceKlass_;&#125; 5. 修改LDC，将类对象推入操作数栈添加代码： 1234case ConstantInfoFactory.CONSTANT_Class: Instance_ java_mirror = ((ClassRef) (c.getVal())).resolvedClass().getJava_mirror_(); stack.pushRef(java_mirror); break; 通过以上步骤，完成了Java反射之于引用类型的准备工作。 完成部分反射功能这里实现最简单的反射功能，看例子： 123456789public class ClassTest &#123; public static void main(String args[]) throws Exception &#123; Class objectClass = ClassTest.class; ClassTest o = new ClassTest(); Class objectClass02 = o.getClass(); System.out.println(objectClass.getName()); System.out.println(objectClass02.getName()); &#125;&#125; 通过.class和getClass()来获得ClassTest的java.lang.Class类对象，然后调用类对象的getName方法打印出ClassTest类名。 1. 修改JObject在OpenJDK中拥有单独的方法Java_java_lang_Object_getClass()，这里为了简便，直接用之前已经写好的Java_java_lang_Object_registerNatives()来注册，需要强调的是getClass()是Object的native方法，所以注册是通过JObject的方法来实现。添加的代码如下： 1234private static JNINativeMethod[] methods = &#123; ...new JNINativeMethod("getClass", "()Ljava/lang/Class;", new GetObjectClass()),&#125;; 2. 在JVM_ENTRY实现相应的native方法这里的native方法指的是GetObjectClass()以及JVM_GetClassName()，前者用来实现getClass的逻辑，后者则用于实现getName。代码如下： 12345678910111213141516171819202122class GetObjectClass implements NativeMethod &#123; @Override public void execute(StackFrame_ frame) &#123; Instance_ thisRef = frame.getLocalVars().getRef(0); Instance_ jClass = thisRef.getInstanceKlass_().getJava_mirror_(); frame.getOperandStack().pushRef(jClass); &#125;&#125;class JVM_GetClassName implements NativeMethod &#123; @Override public void execute(StackFrame_ frame) &#123; Instance_ thisRef = frame.getLocalVars().getRef(0); InstanceKlass_ instanceKlass = thisRef.getKlass(); String name = instanceKlass.getThisClassName(); name = name.replace("/", "."); Instance_ jName = StringPool.jString(instanceKlass.getLoader(), name); frame.getOperandStack().pushRef(jName); &#125;&#125; 以上代码发挥了klass与mirror之间双向引用的作用。 3. 在java.lang中添加JClass这个类的实现类似于JObject，也采用了一个注册方式来调用native方法，但是和JObject不同的是，编译出来的字节码文件没有主动调用该类registerNatives方法的指令(解决这个问题见下一步)。为了方便查阅这里贴出完整类代码： 123456789101112131415public class JClass &#123; private static JNINativeMethod[] methods = &#123; new JNINativeMethod("getName0", "()Ljava/lang/String;", new JVM_GetClassName()), &#125;; // 传入className，对本地方法进行注册 public static void Java_java_lang_Object_registerNatives(String className) &#123; for (JNINativeMethod jniNativeMethod : methods) &#123; Registry.registerMethod(className, jniNativeMethod.getMethodName(), jniNativeMethod.getMethodDescriptor(), jniNativeMethod.getNativeMethod()); &#125; &#125;&#125; 4. 修改INVOKE_NATIVE前面提到了javac编译出来的字节码文件没有主动调用该JClass类registerNatives方法的指令，所以需要给它一个运行的时机，这里将这个“时机”放在INVOKE_NATIVE中，即添加代码： 12if (className.equals("java/lang/Class")) JClass.Java_java_lang_Object_registerNatives(className); 这样当运行INVOKE_NATIVE实例时就会完成JClass中本地方法的注册。 以上就实现了最基本的反射功能，结果是打印出两行ClassTest。 小结理解Java反射的实现原理在于理解记录类元数据的对象和java.lang.Class实例的关系，它们是双向引用的。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收看世界杯并快记常用Vim命令：进阶(三)]]></title>
    <url>%2F2019%2F02%2F01%2Fvim04%2F</url>
    <content type="text"><![CDATA[本篇主要聚焦光标的移动和跳转，有些命令在之前一系列的文章中已经涉及到。 j和k如何在屏幕行进行上下移动？ 使用gj和gk即可。同理，0和$前面添加上g也是对屏幕行的操作。 w和e的反向操作是什么？ 拉莫斯的反向操作是b(保利尼奥)，皮克的反向操作是ge，他们的反向组成“b-ge”组合。顺便提一句，《Vim实用技巧》一书的作者喜欢使用ea组合键用于在单词结尾后添加内容。 单词和字串的区别是什么？ 单词：字母、数字、下划线或者其它非空白字符的序列组成； 字串：由非空白字符序列组成，字串间以空白字符分隔； 所以对应的，w和W分别用来表示单词和字串的向后移动，W用国脚张琳梵表示。 如何对当前行之外的内容进行查找？ 这里考察的是诺伊尔的使用。在Normal模式输入/内容&lt;CR&gt;，这样就可以跨行搜索多个匹配的目标，匹配目标之间的跳跃使用n和N。 如何快速的跨行删除指定内容？ 一种可行的方案是：在Visual模式下(v)，使用诺伊尔搜索，然后跟上一个d，可以完成要求。 如何高亮{}内的文本(不包含{})？ 这个问题考察的是库蒂尼奥的用法，当光标在括号内时，键入vi}就能高亮目标文本。 如何高亮{}内文本(包括{})？ 只要将上一个问题的解决方案中的i替换成a即可。 如何高亮XML内文本？ XML在这里用t表示，前面的解决方案中，}改为t。 如何直接删除{}内的文本？ 直接删除不用进入Visual模式，也就是说，讲前面的解决方案的v改为c或者d，就可以直接用删除取代之前的高亮。 注：如果是拷贝{}内的文本，使用y代替v。 一般来说d和a搭配比较好，而c和i搭配比较好。 如何将一对括号修改为一对中括号？ 假设现在给以一段字符串：{nihao alibb}，现在要讲{}改编为[]，首先光标停留在{上，然后采用蒂亚戈(%)，此时使用r]更换掉}，接着使用``跳转到之前{的地方，然后使用r[更换[。 Vim如何翻页？ 向上翻页是，向下翻页的方法是，向上翻页半屏是，向下翻页半屏是。 前面某问下使用了``跳转命令，它和有什么不同？ ``会更新jump历史，所以连续按此命令会重复在两个位置上跳转，而&lt;C-o&gt;会一直回跳到关闭为止。 如何标记自定义位置？ 在Normal模式下使用m[字符]的形式标记一个自定义的位置，当要跳转到该位置时，使用`[字符]命令就可以满足要求。 如何分屏？ 横向分屏使用:sp命令，纵向使用:vsp。 如何在各屏中切换？ 首先键入C-w，然后通过w、W在各屏中切换，w和W方向相反。 如何关闭光标所在窗口、如何关闭其它窗口？ 在键入C-w的条件下，键入c是关闭当前窗口(如果该窗口是唯一窗口则不关闭，如果希望关闭则使用q)，键入o是关闭其他窗口。 如何将某个窗口和下一个窗口互换？ 键入C-w，通过r进行窗口互换。 如何新开一个没有任何输入的窗口？ 键入C-w，接着键入n。 在新开了一个没有任何输入的窗口后，如何保存，保存后如何打开？ 保存采用:w [文件名]的方式，如果希望再次打开，可以使用:sp/vsp [文件名]的方式打开。 小结本文主要总结Vim的跳转操作。 参考《Vim实用技巧》]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java网络应用框架Netty简单入门法]]></title>
    <url>%2F2019%2F01%2F15%2FNetty01%2F</url>
    <content type="text"><![CDATA[这篇文章旨在采用简单的方式快速入门Java网络应用框架Netty。 Netty应用实例首先给出本文分析的实例，采用自官方User Guide，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// Serverpublic class DiscardServer &#123; private int port; public DiscardServer(int port) &#123; this.port = port; &#125; public void run() throws InterruptedException &#123; EventLoopGroup group = new NioEventLoopGroup(1); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(group) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new Handler()); &#125; &#125;) .option(ChannelOption.SO_BACKLOG, 128) .childOption(ChannelOption.SO_KEEPALIVE, true); ChannelFuture f = b.bind(port).sync(); f.channel().closeFuture().sync(); &#125; finally &#123; group.shutdownGracefully(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; int port = 8080; new DiscardServer(port).run(); &#125;&#125;// Handlerpublic class Handler extends ChannelInboundHandlerAdapter &#123; @Override // 方法在收到消息时被调用，msg就是收到的消息，然后被该方法"洗礼" public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; ((ByteBuf) msg).release(); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; // 出现异常就关闭连接 cause.printStackTrace(); ctx.close(); &#125;&#125; 这是一个单线程模型，采用此实例便于和NIO.2实现的单线程多路复用做对比。 框架结构与NIO.2实现的多路复用进行对比本小节主要将前文代码和站内文《再次更新的NIO：NIO2实现多路复用》中的代码进行对比。 在Netty框架里，NioServerSocketChannel对应Java API的ServerSocketChannel，所以.channel(NioServerSocketChannel.class)相当于ServerSocketChannel ssChannel = ServerSocketChannel.open();。 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;()...)这句相当于： 123SocketChannel sc = ssc.accept();sc.configureBlocking(false);sc.register(selector, SelectionKey.OP_READ); 至于socketChannel.pipeline().addLast(new Handler());主要就是用来处理监控到的事件，对标的代码是： 1234567if (key.isReadable()) &#123; SocketChannel sc = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(1024); sc.read(buffer); buffer.flip(); sc.write(buffer);&#125; .option和.childOption一个是设置ServerSocketChannel对象，一个是设置SocketChannel对象。 可见Netty属于更高一层的封装，相比原本Java API层面的实现，的确清晰明了了许多。 代码中的选项设定ChannelOption.SO_KEEPALIVE的含义首先需要明白.childOption(ChannelOption.SO_KEEPALIVE, true);这句的作用是什么？ 在《UNIX网络编程卷1：套接字联网API》这本书的相关章节已经有所描述。 When the keep-alive option is set for a TCP socket and no data has been exchanged across the socket in either direction for two hours, TCP automatically sends a keep-alive probe to the peer. This probe is a TCP segment to which the peer must respond. 也就是说对一个TCP socket设置了这个选项后，如果两个小时在该socket上的任意方向都没有数据交换，那么它就会网peer发送一个keep-alive probe，这个probe是一个segment对面peer必须响应。具体响应的细节可以参考书中的内容。由此也会产生TCP中已有SO_KEEPALIVE选项，为什么还要在应用层加入心跳包机制??的问题。大体上来说，前者判断连接的存活状态，但并不代表连接能正常传输数据。 所以源代码中的选项设置不是严格限定的，并不能取代应用级别的心跳检测。 ChannelOption.SO_BACKLOG的含义这个选项在《UNIX网络编程卷1：套接字联网API》这本书的相关章节也有所描述。该书的84页写到，要理解backlog就必须认识到内核为任何一个给定的监听套接字维护两个队列：未完成连接队列和已完成连接队列。 该图片来自：http://www.cnxct.com/something-about-phpfpm-s-backlog/ 这涉及到一些TCP协议的知识，本人将另起一篇文章单独进行说明和分析，目前只需知道backlog参数和已完成连接队列的大小有关。 Netty应用的收尾工作涉及到的相关代码： 123456 ... ChannelFuture f = b.bind(port).sync(); f.channel().closeFuture().sync();&#125; finally &#123;group.shutdownGracefully();&#125; sync()先来看看sync()： 12345/** * Waits for this future until it is done, and rethrows the cause of the failure if this future * failed. */Future&lt;V&gt; sync() throws InterruptedException; 这是一个同步操作，它等待当前的future对象is done或者返回future发生错误的原因，在这里暂且不讨论该方法的具体实现。 b.bind(port)b是一个ServerBootstrap，它继承自AbstractBootstrap，而bind(int)也是后者实现的方法，这个方法进一步封装了doBind(SocketAddress)： 12345678910111213141516private ChannelFuture doBind(final SocketAddress localAddress) &#123; final ChannelFuture regFuture = initAndRegister(); final Channel channel = regFuture.channel(); if (regFuture.cause() != null) &#123; return regFuture; &#125; if (regFuture.isDone()) &#123; // At this point we know that the registration was complete and successful. ChannelPromise promise = channel.newPromise(); doBind0(regFuture, channel, localAddress, promise); return promise; &#125; else &#123; ... &#125;&#125; 因为sync()的存在，所以在这里暂时只用去解析if (regFuture.isDone())条件下的代码。doBind0方法会执行线程池进行绑定，来看看这里的channel实例是如何产生的。 它由ChannelFuture实例regFuture通过channel方法得到，而后者又产生自initAndRegister方法，此方法内存在一个赋值语句： 1channel = channelFactory.newChannel(); 那么这个channelFactory是何时初始化的呢？ 不难猜到这和下面这段代码有关： 1b.group(group).channel(NioServerSocketChannel.class) 接着就来验证一下，b是一个ServerBootstrap，它存在一个group方法，此方法主要用来传递group，也就是本人起初new的单线程池包装器对象(NioEventLoopGroup毕竟只是封装，不能等同于线程池)new NioEventLoopGroup(1)。group方法返回的是当前的ServerBootstrap实例，也就是b，相当于采用了构建者模式。同样的手法在channel方法再进行一次，channelFactory就在该方法内完成了赋值。一旦channelFactory调用newChannel()，那么传入的NioServerSocketChannel.class就通过反射产生了Channel对象。 so，当f.channel()时，得到的就是一个NioServerSocketChannel对象。 .closeFuture()注释是这么说的： 1234/** * Returns the &#123;@link ChannelFuture&#125; which will be notified when this * channel is closed. This method always returns the same future instance. */ 注意代码中语句和close()的区别，close()是主动关闭当前的Channel对象，而closeFuture()搭配sync()相当于监听Channel关闭的事件，如何关闭Netty程序可以参考技术贴：Shutdown netty programmatically。 至此，实例中较难理解的部分就分析完毕。 小结Netty随着版本的迭代，对很多方法和对象进行了高度的封装，但不要因为换了马甲就不识其原本的真正面目。将Netty代码和多路复用代码进行对照学习，是一种快速入门Netty框架的方式，本文末尾的参考添加了更多的Netty实例，体现了Netty的简单和强大。 参考How to stop netty bootstrap from listening and accepting new connetions Closing ChannelFuture after bind: I believe I found out… Shutdown netty programmatically UNIX网络编程 卷1：套接字联网API（第3版） 如何在连接闲置时发送心跳来维持连接 Netty聊天功能实例 Netty 实现 WebSocket 聊天功能 TCP中已有SO_KEEPALIVE选项，为什么还要在应用层加入心跳包机制??]]></content>
      <categories>
        <category>NIO2</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>SO_KEEPALIVE</tag>
        <tag>SO_BACKLOG</tag>
        <tag>closeFuture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收看世界杯并快记常用Vim命令：进阶(二)]]></title>
    <url>%2F2019%2F01%2F09%2Fvim03%2F</url>
    <content type="text"><![CDATA[继续之前的Vim之旅。 如何在Command模式对一行或多行执行打印命令？ 如果是打印光标所在行，则可以使用如下命令： 1:print # 或者:p 如果是打印指定行，比如行号为7的行： 1:7p 如何打印指定范围内的行，例如打印第3到第7行： 1:3,7p 执行以上命令后，光标会指向打印的最后一行。 Command模式下，.和%的意涵是什么？ .代表当前行，%代表当前文件所有行，例如如果替换当前文件所有行中的第一个A为B： 1:%s/A/B/ 每行只会替换第一个满足的字符片段，除非加上/g。 如何在Command模式下实现Visual模式的选择效果？ 借用Visual模式来高亮指定范围 比如按下1G ＋ VG，可以高亮第一行到最后一行的内容，然后在Command模式按下:后会出现： 1:'&lt;,'&gt; 逗号前后分别代表高亮的首行和最后一行。 用模式指定范围 比如有一段文字： 123451 &lt;!DOCTYPE html&gt;2 &lt;html&gt;&lt;/html&gt;3 &lt;head&gt;&lt;title&gt;Practical Vim&lt;/title&gt;&lt;/head&gt;4 &lt;body&gt;&lt;h1&gt;Practical Vim&lt;/h1&gt;&lt;/body&gt;5 &lt;/html&gt; 要打印到的内容可以使用： 1:/&lt;html&gt;/,/&lt;\/html&gt;/p 打印内容为： 12 &lt;html&gt;&lt;/html&gt; 记得转义符号。 这里打印的都是行，哪怕在&lt;/html&gt;后面还有内容。 用偏移地址来指定范围 修改上一个例子： 1:/&lt;html&gt;/＋1,/&lt;\/html&gt;/p 打印为： 1233 &lt;head&gt;&lt;title&gt;Practical Vim&lt;/title&gt;&lt;/head&gt;4 &lt;body&gt;&lt;h1&gt;Practical Vim&lt;/h1&gt;&lt;/body&gt;5 &lt;/html&gt; 修改的例子中，/&lt;html&gt;/后进行了加一，表示从该行的后一行打印。 +后的数字可以省略，省略后默认为1。 如何在Command模式进行行拷贝／剪切？ 在Command模式中，:copy简写为:t或者:co。 比如将第六行复制，拷贝到当前行下方： 1:6copy. 和yyp相比，yyp会使用寄存器，而本方法不会。 Command模式剪切的使用方法类似拷贝，使用的命令为:m。 如何取消Vim内容中的高亮？ 可以在Command模式运行下列命令： 1:nohl 如何在非Normal模式下，操作大量重复的任务？ 比如我需要在一段文字的每行最后，添加一个分号，可以这样做： 首先将光标移动到第一行，然后键入VG，接着在Command模式输入normal A;，这样就能达到要求。 记住：执行normal命令时，Vim会默认将光标移动到行的起始处。 在Command模式中如何自动补全？ 输入命令的一部分后，按下&lt;C-d&gt;，通过&lt;Tab&gt;顺序遍历，通过shift &lt;Tab&gt;反向遍历。 如何复制当前光标下的单词到Command模式的命令行？ 进入Command模式，按下&lt;C-r&gt;&lt;C-w&gt;。 在Vim界面中，如何查看当前目录的内容？ 1:! ls 如何在Vim界面和命令行界面间进行切换？ 有两种方式： 通过:shell和$exit进行切换； 通过&lt;C-z&gt;和$fg进行切换； 通过第二种方法，可以在shell命令行中键入jobs来查看后台的作业列表。 小结本文主要用于熟悉Command模式下常用的一些操作。 参考《Vim实用技巧》]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收看世界杯并快记常用Vim命令：进阶(一)]]></title>
    <url>%2F2019%2F01%2F04%2Fvim02%2F</url>
    <content type="text"><![CDATA[本人在之前的文章收看世界杯并快记常用Vim命令里已经介绍了一些基本的Vim命令。本篇将采用问答的方式对其中部分命令进行进阶学习，内容主要参考自《Vim实用技巧》。 问与答.命令会重复上一次修改，那么修改指的是什么？ .命令用科克来代表，圆圆的眼睛也像极了点号的形状。 注：图片来自网络 这里的修改指的是：&lt;切入Insert模式的按键操作&gt; + &lt;Insert模式内的修改操作&gt; + &lt;esc&gt;。 s命令和x命令的区别是什么？ 按照世界杯的表现来说，很像克洛泽和戈麦斯的关系，克洛泽除了戈麦斯的弄能，还拥有切入Insert模式的能力，也就是s = x + &lt;切入Insert模式的操作&gt;。 f的重复操作是什么？ 下一个威廉是;，上一个威廉是,。需要注意的是，这两个命令都是行内有效。 cw和dw的区别是什么？ 类似s命令和x命令的区别，cw比dw多一个切入Insert模式的操作，阿尔巴防守尚可，进攻时切入对方禁区能力亦佳。 这里如果w换成e，各自的效果是一样的，单词的反向删除这是将w换成b，此时删除的部分将不包含光标所在的位置。 cw和dw如果要删除完整的单词该怎么做？ 在这两个命令中间添加a。和上一条不一样的是，这里w不能换成e。如果要删除整个段落，可以将w换成p。 如何简单的给数字进行加操作或者减操作？ &lt;数字&gt;&lt;C-a&gt;用来进行加操作，&lt;数字&gt;&lt;C-x&gt;用来进行减操作，光标并非一定要在数字上，当光标不在数字上，它会正向对最近的一个数字进行操作。 盛世美颜谨慎出场？ 《Vim实用技巧》提到：能用重复就别用次数。 d3w和3dw效果一样(这里的次数3用来泛指)，迭戈科斯塔只在必须时使用。 如何一次将某单词全部字母大写或者小写？ 操作符g和动作命令组合可以形成一个操作，这里g~aw可以在大小写转换中切换，gUaw用来将单词转换成大写，guaw将单词转换成小写。它们都是一个操作，可以用.来进行重复操作。 如何将对单词的操作用于行？ 操作符通常连续调用两次会把对单词的操作作用于行，但是这里gUgU可以简化为gUU。 除了&lt;esc&gt;，还有什么方式可以将Insert模式切换回Normal模式？ 可以使用Vim默认提供的&lt;C-[&gt;，也可以在.vimrc中进行修改。 Insert-Normal模式是什么鬼？ 在该模式下，用户可以执行一次Normal模式的命令，然后界面又切换回Insert模式。例如在该模式下，键下u不会是在文本中输入u字符。进入该模式的方法是：在Insert模式下按&lt;C-o&gt;。 如何在Insert模式进行单词自动补全？ 在该模式下键入&lt;C-p&gt;即可。 Insert模式如何粘贴寄存器文本？ 首先是复制一块内容，采用y + t + “截止位置(不包含该位置)”，例如有一行文字：“Cgrw, hello!”，光标停留在“C”位，如果要复制Cgrw，可以采用yt,的组合。 然后进入Insert模式，按下&lt;C-r&gt;0，此时文字粘贴到了期望处，这里0是寄存器名字。 Insert模式如何简单的进行算数？ 可以借助＝寄存器来实现，进入Insert模式按下&lt;C-r&gt;=，然后回车。 如何在Insert模式输入特殊符号？ 首先查询符号的字符编码，如果是三位以内，例如A是065，那么直接输入&lt;C-v&gt;065；如果字符编码超过三位，例如倒立的?，则输入&lt;C-v&gt;u00bf。 Replace模式是什么模式？ Replace模式相比Insert模式可以直接在文本上替换，而非插入新的内容，除此之外和Insert模式基本相同，比如在该模式下，前述的Insert模式粘贴寄存器文本、进行算数以及输入特殊符号等方法都适用该模式。 如何通过Visual模式将某个单词修改成另一个单词？ 这里提供两种方法： 首先将光标停留在待修改的单词上，键入viw(vaw会选中单词正方向后的空格)，然后键入c，之前的字符就全部删除，于是可以输入新的字符； 同样先键入viw，然后再键入&lt;C-g&gt;，将Visual模式切换成Select模式，接下来无需键入c，直接输入新的字符进行替换； gv和o的作用是什么？ gv用来重选上次Visual模式选定的文本范围，o用来切换活动端，比如跳跃光标从最右跳到最左。 Visual模式下，怎么画一行分割线？ 可以采用以下策略： 复制一行内容(什么内容都可以)，通常为要画的分割线的上一行，采用的命令是yyp； 键入大写V表示欲对行操作，然后键入r表示替换，最后接上要替换的内容，整个命令为：Vr-(-为要替换的内容)； 如何在长短不一的高亮块后添加文本？ 相比{% post_link Learning_Vim %}文中内马尔的操作，这里只需注意在进入Visual模式后，还需先添加一个$，它可以到达每行文本的末尾。 小结本文主要用于熟悉一些Vim常用的操作。 参考《Vim实用技巧》]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再次更新的NIO：NIO2实现多路复用]]></title>
    <url>%2F2018%2F12%2F17%2FNetty00%2F</url>
    <content type="text"><![CDATA[本篇将用NIO2实现一个简单的IO多路复用程序并分析它，其中涉及到了ServerSocketChannel的configureBlocking()、Selector的select()、ServerSocketChannel的accept()等方法的理解。 单线程模型实例先放上代码： 1234567891011121314151617181920212223242526272829303132public class ServerNio2 &#123; public static void main(String[] args) throws IOException &#123; ServerSocketChannel ssChannel = ServerSocketChannel.open(); int port = 1024; ssChannel.bind(new InetSocketAddress(port)); Selector selector = Selector.open(); ssChannel.configureBlocking(false); ssChannel.register(selector, SelectionKey.OP_ACCEPT); while (true) &#123; selector.select(); Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); for (SelectionKey key : keys) &#123; if (key.isAcceptable()) &#123; ServerSocketChannel ssc = (ServerSocketChannel) key .channel(); // 常常要判断sc是否为null，但这里用key规避掉了 SocketChannel sc = ssc.accept(); sc.configureBlocking(false); sc.register(selector, SelectionKey.OP_READ); &#125; if (key.isReadable()) &#123; SocketChannel sc = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(1024); sc.read(buffer); buffer.flip(); sc.write(buffer); &#125; &#125; keys.clear(); &#125; &#125;&#125; 命令行执行如下代码： 1yin@chenguoMacBook-Pro:~$telnet 127.0.0.1 1024 输入想要打印的内容会出现echo效果。 这段代码有三个比较重要的节点，分别是configureBlocking()的调用、selector.select()的调用以及ssc.accept()的调用，后续讲对其进行展开分析。 configureBlocking()所谓非阻塞同步的非阻塞，说的就是这里。在Stackoverflow: Socket Channel configureBlocking to false下的答案给出了该方法的使用说明，通道默认是阻塞模式(也就是true)，调用每个I/O操作都将引起通道的阻塞，直到操作完成。在register()之前应该设置其为false，如果取消了注册，通道可能不会返回阻塞模式。 selector.select()接下来看看select()调用的底层脉络。 Selector是抽象类，代码中是通过Selector.open()来返回具体实例的： 123public static Selector open() throws IOException &#123; return SelectorProvider.provider().openSelector();&#125; 查看provider()代码： 1234567891011121314151617public static SelectorProvider provider() &#123; synchronized (lock) &#123; if (provider != null) return provider; return AccessController.doPrivileged( new PrivilegedAction&lt;SelectorProvider&gt;() &#123; public SelectorProvider run() &#123; if (loadProviderFromProperty()) return provider; if (loadProviderAsService()) return provider; provider = sun.nio.ch.DefaultSelectorProvider.create(); return provider; &#125; &#125;); &#125;&#125; 当provider为空则通过provider = sun.nio.ch.DefaultSelectorProvider.create();产生实例。继续追踪有： 123public static SelectorProvider create() &#123; return new KQueueSelectorProvider();&#125; 以及： 123public AbstractSelector openSelector() throws IOException &#123; return new KQueueSelectorImpl(this);&#125; 因为本实验环境为MacOX，所以Selector.open()返回的对象是一个KQueueSelectorImpl，它是一个Selector实现类。该类方法select()的实现在抽象父类SelectorImpl中，代码如下： 123456789101112131415public int select(long var1) throws IOException &#123; if (var1 &lt; 0L) &#123; throw new IllegalArgumentException("Negative timeout"); &#125; else &#123; return this.lockAndDoSelect(var1 == 0L ? -1L : var1); &#125;&#125;public int select() throws IOException &#123; return this.select(0L);&#125;public int selectNow() throws IOException &#123; return this.lockAndDoSelect(0L);&#125; 继续查看lockAndDoSelect()有： 123456789101112131415161718private int lockAndDoSelect(long var1) throws IOException &#123; synchronized(this) &#123; if (!this.isOpen()) &#123; throw new ClosedSelectorException(); &#125; else &#123; Set var4 = this.publicKeys; int var10000; synchronized(this.publicKeys) &#123; Set var5 = this.publicSelectedKeys; synchronized(this.publicSelectedKeys) &#123; var10000 = this.doSelect(var1); &#125; &#125; return var10000; &#125; &#125;&#125; 这个doSelect()经由KQueueSelectorImpl实现： 12345678910111213141516171819protected int doSelect(long var1) throws IOException &#123; boolean var3 = false; if (this.closed) &#123; throw new ClosedSelectorException(); &#125; else &#123; this.processDeregisterQueue(); int var7; try &#123; this.begin(); var7 = this.kqueueWrapper.poll(var1); &#125; finally &#123; this.end(); &#125; this.processDeregisterQueue(); return this.updateSelectedKeys(var7); &#125;&#125; poll()源码为： 12345int poll(long var1) &#123; this.updateRegistrations(); int var3 = this.kevent0(this.kq, this.keventArrayAddress, 128, var1); return var3;&#125; kevent0()是一个native方法：private native int kevent0(int kq, long keventAddress, int keventCount, long timeout);。 本地方法的实现： 12345678910111213141516171819202122232425262728293031323334JNIEXPORT jint JNICALLJava_sun_nio_ch_KQueueArrayWrapper_kevent0(JNIEnv *env, jobject this, jint kq, jlong kevAddr, jint kevCount, jlong timeout)&#123; struct kevent *kevs = (struct kevent *)jlong_to_ptr(kevAddr); struct timespec ts; struct timespec *tsp; int result; // Java timeout is in milliseconds. Convert to struct timespec. // Java timeout == -1 : wait forever : timespec timeout of NULL // Java timeout == 0 : return immediately : timespec timeout of zero if (timeout &gt;= 0) &#123; ts.tv_sec = timeout / 1000; ts.tv_nsec = (timeout % 1000) * 1000000; //nanosec = 1 million millisec tsp = &amp;ts; &#125; else &#123; tsp = NULL; &#125; result = kevent(kq, NULL, 0, kevs, kevCount, tsp); if (result &lt; 0) &#123; if (errno == EINTR) &#123; // ignore EINTR, pretend nothing was selected result = 0; &#125; else &#123; JNU_ThrowIOExceptionWithLastError(env, "KQueueArrayWrapper: kqueue failed"); &#125; &#125; return result;&#125; 结合之前本人关于Kqueue的文章，就不难理解这段代码的原理，select()底层还是调用的kevent()，所以Java NIO.2的相关方法是对底层的更高级抽象。注释表明，Java的timeout参数小于0时，相当于给kevent()的timeout参数传入NULL，表示一直等待。 ssc.accept()ServerSocketChannel是一个可以监听新的TCP连接的通道。看看该通道accept()的注释： Accepts a connection made to this channel’s socket. If this channel is in non-blocking mode then this method willimmediately return null if there are no pending connections.Otherwise it will block indefinitely until a new connection is availableor an I/O error occurs. The socket channel returned by this method, if any, will be inblocking mode regardless of the blocking mode of this channel. 也就是说，在非阻塞模式，如果没有连接将立即返回，在阻塞模式将一直阻塞等待新的可用连接或者一个I/O错误的发生。 返回的SocketChannel通道将为阻塞模式，无论ServerSocketChannel方法调用之前是什么模式。 小结本文分析的多路复用程序可以看作是Epoll、Kqueue在Java层面的实现，Java将底层的系统调用进行了很好的封装。本篇文章为后续Netty框架的学习进一步打下了基础。 参考Socket Channel configureBlocking to false Stackoverflow: What is “jobject thiz” in JNI and what is it used for?]]></content>
      <categories>
        <category>NIO2</category>
      </categories>
      <tags>
        <tag>Kqueue</tag>
        <tag>多路复用</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin语言实现AOP框架]]></title>
    <url>%2F2018%2F12%2F17%2FAOP01%2F</url>
    <content type="text"><![CDATA[本文将简单介绍如何用Kotlin实现一个AOP框架(在此之前本人先行编写了IOC框架，IOC实现为采用xml配置的方式，比较简单，可直接在GitHub参阅源码，这里就不赘述了)。 基本注意事项Spring AOP构建在动态代理基础之上，因此Spring对AOP的支持局限于方法的拦截； 目标对象实现了接口，Spring默认采用JDK动态代理实现AOP； 条件满足时，CGLIB可以强行取代JDK动态代理来实现AOP； 如果目标对象没有实现接口，则采用CGLIB实现AOP； 框架类/接口介绍Spring AOP的核心是代理模式，而代理模式有多种，包括JDK动态代理以及CGLIB，这里首先采用JDK动态代理来实现。 和Spring一样，本框架倚赖AspectJ框架，以期快速完成框架的编写。 下面介绍一些主要的类/接口。 TargetSource被代理的目标对象包，之所以称之为包是因为它除了包含目标对象，还包含目标对象的元数据。 Advisor用于获得Advice，Advice是AspectJ框架提供的接口。 Pointcut切点接口，表示在哪里切入，它包括两个方法，分别用来获取ClassFilter和MethodMatcher，一个是类过滤器，一个是方法匹配器。 ClassFilter &amp; MethodMatcher类过滤器接口和方法匹配器接口，分别包含匹配方法判断是否满足匹配条件。 PointcutAdvisor切面接口，提供切点和advice的获取方法。 AdvisedSupport一个支持类，它包含目标对象包引用、拦截器对象引用以及判断方法匹配接口的引用。MethodInterceptor是拦截器接口，本质上仍然是一个Advice，MethodMatcher代表切点，所以AdvisedSupport提供了“在什么地方对什么样的目标对象进行什么样的拦截”的信息。 AopProxy代理类的接口，不同模式的代理都实现该接口。 ReflectiveMethodInvocation该类的作用主要是通过反射调用目标对象的方法。ReflectiveMethodInvocation是MethodInvocation的具体实现，MethodInvocation是AspectJ框架提供的接口，该接口还继承了AspectJ提供的另一接口Invocation。 AspectJExpressionPointcut切点的具体实现类。AspectJ框架提供了AspectJExpressionPointcut类，本人在此基础上修改了一些内容，去掉了暂时不需要的部分。 AspectJExpressionPointcutAdvisor切面的实现类。 BeanFactoryAware设置工厂类的接口。 JdkDynamicAopProxyJDK动态代理类，实现AOP的核心。 AspectJAwareAdvisorAutoProxyCreator它是一个BeanPostProcessor的实现类，用于给拦截到的Bean对象创建代理实例。 JDK动态代理首先贴出代码： 1234567891011121314151617181920class JdkDynamicAopProxy(var advised: AdvisedSupport) : AopProxy, InvocationHandler&#123; override fun getProxy(): Any? &#123; return Proxy.newProxyInstance(advised.targetSource!!.target!!.javaClass.classLoader, advised.targetSource!!.targetClass, this) &#125; override fun invoke(proxy: Any?, method: Method?, args: Array&lt;Any&gt;?): Any? &#123; var methodInterceptor = advised.methodInterceptor var methodMatcher = advised.methodMatcher if (methodMatcher != null &amp;&amp; methodMatcher.matches(method!!, advised.targetSource!!.target!!::class.java)) // 匹配时返回拦截器的处理方法 return methodInterceptor?.invoke(ReflectiveMethodInvocation(advised.targetSource!!.target, method, args)) else &#123; // 不匹配时返回目标对象的原本方法 return method?.invoke(advised.targetSource!!.target, *(p2 ?: arrayOfNulls&lt;Any&gt;(0))) &#125; &#125;&#125; 和通常JDK动态代理的实现最大区别是，增加了MethodInterceptor和ReflectiveMethodInvocation对象的参与，比较if…else的两个返回部分就可以知道一切都是为了将逻辑更进一层的封装，这样通过实现MethodInterceptor就可以完成前置Advice、后置Advice等等切面工作。 比如在后文还将运用于项目代码的SimpleInterceptor： 12345678public class SimpleInterceptor : MethodInterceptor &#123; override fun invoke(invocation: MethodInvocation?): Any? &#123; println("Before ...") var rval = invocation!!.proceed() println("After ...") return rval &#125;&#125; 这就是一个简单的环绕Advice拦截器。 测试JDK动态代理写一个测试来检测目前写的代码。 首先写一个环切Advice： 12345678public class SimpleInterceptor : MethodInterceptor &#123; override fun invoke(invocation: MethodInvocation?): Any? &#123; println("Before ...") var rval = invocation!!.proceed() println("After ...") return rval &#125;&#125; 然后是目标被代理类： 123456789101112interface HelloJDKFather &#123; fun helloMethod(x: Int)&#125;interface HelloJDKMotherclass HelloJDKProxy : HelloJDKFather, HelloJDKMother &#123; override fun helloMethod(x: Int) &#123; println("I am Hello! $x") &#125;&#125; 测试： 1234567891011121314151617181920212223class JdkDynamicAopProxyTest &#123; @Test fun getProxy() &#123; var helloJDKProxy = HelloJDKProxy() var aspectJExpressionPointcut = AspectJExpressionPointcut() var expression = "execution(* testresources.beans.*.*(..))" var advisedSupport = AdvisedSupport() var simpleInterceptor = SimpleInterceptor() aspectJExpressionPointcut.expression = expression var targetSource = TargetSource(helloJDKProxy, *helloJDKProxy.javaClass.interfaces) var methodMatcher = aspectJExpressionPointcut.getMethodMatcher() advisedSupport.targetSource = targetSource advisedSupport.methodMatcher = methodMatcher advisedSupport.methodInterceptor = simpleInterceptor var jdkDynamicAopProxy = JdkDynamicAopProxy(advisedSupport).getProxy() as HelloJDKFather jdkDynamicAopProxy.helloMethod(5) &#125;&#125; 输出为： 12345Before ...I am Hello! 5After ...Process finished with exit code 0 成功完成动态代理的工作。 Kotlin编写问题 &amp; 解决暂时停下框架的编写，讨论在之前使用Kotlin语言的过程中积累的几个问题。 问题一这是编写ReflectiveMethodInvocation的方法proceed()时产生的问题。如果是代理没有显示参数的方法，原本的代码在IDE下会报IllegalArgumentException异常。内部调用的是public Object invoke(Object obj, Object… args)，由于可变参数需要星号投影，且如果args是null需要生成零长null型数组，所以解决代码如下： 1234override fun proceed(): Any? &#123; var re = method!!.invoke(target, *(args ?: arrayOfNulls&lt;Any&gt;(0))) return re&#125; 问题二编写TargetSource类时传入的可变参数(vararg)赋值给数组出现Type mismatch问题。本人解决的方法： 1234constructor(target: Any, vararg targetClass: Class&lt;*&gt;) &#123; this.target = target this.targetClass = Array(targetClass.size) &#123; i -&gt; targetClass[i] &#125;&#125; 问题三在编写initializeBean方法时，出现参数Val cannot be reassigned的问题。用代码描述就是： 12345678fun testMethod(bean: Bean) &#123; bean = otherMethod(bean)&#125;protected fun initializeBean(bean: Any, id: String) &#123; for (beanPostProcessor in beanPostProcessors) &#123; bean = beanPostProcessor.postProcessAfterInitialization(bean, id) &#125;&#125; 在本文最后的参考链接Function parameters are “val” not “var”?下的回答中，语言设计的作者给出了问题产生原因。在这里，本人用返回值来解决，结合 1234567protected fun initializeBean(_bean: Any, id: String): Any &#123; var bean = _bean for (beanPostProcessor in beanPostProcessors) &#123; bean = beanPostProcessor.postProcessAfterInitialization(bean, id) &#125; return bean&#125; 问题四继承父类get、set方法和Kotlin的属性机制冲突。这个问题可以通过@JvmField解决： 1234567class ReflectiveMethodInvocation(var target: Any?, @JvmField var method: Method?, var args: Array&lt;Any&gt;?) : MethodInvocation &#123; override fun getMethod(): Method? &#123; return method &#125; ...&#125; CGLIB动态代理继续代码的编写，创造一个类CglibAopProxy，整个代码结构和JdkDynamicAopProxy是很相似的，直接贴出： 123456789101112131415161718192021222324252627class CglibAopProxy(var advised: AdvisedSupport) : MethodInterceptor, AopProxy &#123; var targetObject = advised.targetSource!!.target override fun getProxy(): Any? &#123; return createProxyInstance() &#125; fun createProxyInstance(): Any? &#123; var enhancer = Enhancer() enhancer.setSuperclass(this.targetObject!!::class.java) enhancer.setCallback(this) return enhancer.create() &#125; override fun intercept(p0: Any?, p1: Method?, p2: Array&lt;Any&gt;?, p3: MethodProxy?): Any? &#123; var methodInterceptor = advised.methodInterceptor var methodMatcher = advised.methodMatcher if (methodMatcher != null &amp;&amp; methodMatcher.matches(p1!!, advised.targetSource!!.target!!::class.java)) // 匹配时返回拦截器的处理方法 return methodInterceptor?.invoke(ReflectiveMethodInvocation(advised.targetSource!!.target, p1, p2)) else &#123; // 不匹配时返回目标对象的原本方法 return p1?.invoke(advised.targetSource!!.target, *(p2 ?: arrayOfNulls&lt;Any&gt;(0))) &#125; &#125;&#125; intercept方法中的逻辑和JDK动态代理的一样，AspectJ框架能将引用部分的代码和被代理的方法解耦合。 测试CglibAopProxy1234567891011121314151617181920212223class CglibAopProxyTest &#123; @Test fun intercept() &#123; var helloJDKProxy = HelloJDKProxy() var aspectJExpressionPointcut = AspectJExpressionPointcut() var expression = "execution(* testresources.beans.*.*(..))" var advisedSupport = AdvisedSupport() var simpleInterceptor = SimpleInterceptor() aspectJExpressionPointcut.expression = expression var targetSource = TargetSource(helloJDKProxy, *helloJDKProxy.javaClass.interfaces) var methodMatcher = aspectJExpressionPointcut.getMethodMatcher() advisedSupport.targetSource = targetSource advisedSupport.methodMatcher = methodMatcher advisedSupport.methodInterceptor = simpleInterceptor var CglibAopProxy = CglibAopProxy(advisedSupport).getProxy() as HelloJDKProxy CglibAopProxy.helloMethod(5) &#125;&#125; 测试逻辑基本上和JdkDynamicAopProxyTest一摸一样，只有两点不同： HelloJDKProxy要声明为open； 生成的代理对象转换为被代理类而非公共接口； 这也说明了JDK动态代理和CGLIB动态代理的区别：前者被代理的类需要实现接口，而后者被代理的类不需要实现接口，但是该类不能是final的，是需要open的。 完成框架主逻辑这一步即完善程序，在和之前测试条件相同的情况下，运行Main方法达到环切的效果。 整个程序的执行流程在于方法refresh： 12345fun refresh() &#123; loadBeanDefinitions(beanFac) registerBeanPostProcessors(beanFac) onRefresh()&#125; loadBeanDefinitions方法用来将对xml解析的(name, BeanDef)键值对装入工厂的容器中； registerBeanPostProcessors方法用来注册BeanPostProcessor，BeanPostProcessor对象可以在initializeBean方法中拦截bean，并将动态代理作用在他们身上； onRefresh方法通过beanId获得创建的bean对象，其中最重要的是getBean方法； getBean()代码如下： 1234567891011override fun getBean(id: String): Any &#123; var beanDef = beanDefMap[id] // Elvis操作符的作用是为null则返回":"右边的表达式 beanDef ?: throw IllegalArgumentException("该bean没有定义") var bean = beanDef.bean // 添加bean初始化处理 return bean ?: initializeBean(doCreateBean(beanDef)!!, id)&#125; 如果只是创建对象，那么应该使用doCreateBean()而不是getBean()： 123456789101112// 依赖注入产生beanfun doCreateBean(beanDef: BeanDef): Any? &#123; // 添加判断语句避免重复创建对象 if (beanDef.bean != null) return beanDef.bean var bean = createBeanInstance(beanDef) applyPropertyValues(bean, beanDef) beanDef.bean = bean return bean&#125; 在代码中为避免创建多个对象产生覆盖问题，可以使用if语句在创建前先进行判断bean是否已然存在。 最后要说明的是，动态代理产生的代理对象需要在beandefMap中取代原本的bean，不然在最终调用时获得的仍然是没有被代理的对象，例如： 123456 ...beanFac!!.beanDefMap[beanName]!!.bean = CglibAopProxy(advisedSupport).getProxy()!! return beanFac!!.beanDefMap[beanName]!!.bean!! ... 小结通过编写本项目了解AOP的实现原理，对用Kotlin编程中遇到的问题进行了分析和解决。 参考Spring AOP对AspectJ的支持：介绍了几种原语； Why is Kotlin throw IllegalArgumentException when using Proxy Kotlin function parameter: Val cannot be reassigned Function parameters are “val” not “var”? Parameters are Immutable What’s the difference between Foo::class.java and Foo::javaClass? Spring Aop原理之Advisor过滤：内有matches方法的详解]]></content>
      <categories>
        <category>自实现AOP框架</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之Kotlin实现(下)]]></title>
    <url>%2F2018%2F11%2F26%2FKotlin04%2F</url>
    <content type="text"><![CDATA[本篇涉及11种行为型设计模式，分别是职责链模式、命令模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式和解释器模式。 职责链模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657interface Thing &#123;&#125;class Apple : Thing &#123;&#125;class Orange : Thing &#123;&#125;abstract class Member(open var name: String) &#123; var next: Member? = null fun doThing(thing: Thing) &#123; if (resolve(thing)) &#123; done(thing); &#125; else &#123; next?.doThing(thing)?: fail(thing) &#125; &#125; abstract fun resolve(thing: Thing): Boolean protected fun done(thing: Thing) &#123; println("被$&#123;this&#125;吃掉") &#125; protected fun fail(thing: Thing) &#123; println("不能被吃掉") &#125; override fun toString(): String &#123; return "[$&#123;name&#125;]" &#125;&#125;class Child(override var name: String): Member(name) &#123; override fun resolve(thing: Thing): Boolean &#123; return false &#125;&#125;class Mom(override var name: String) : Member(name) &#123; override fun resolve(thing: Thing): Boolean &#123; if (thing is Apple) return true return false &#125;&#125;class Father(override var name: String) : Member(name) &#123; override fun resolve(thing: Thing): Boolean &#123; return true &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var child = Child("小宝贝") child.next = Mom("妈妈") child.next?.next = Father("爸爸") child.doThing(Orange())&#125; 构造一个链表，然后依次让链表上的元素处理事物，期间一旦某元素能处理事物则不会再让后续元素处理。 命令模式123456789101112131415161718192021222324252627282930class Receiver &#123; fun rMethod01(name: String) &#123; println("方法的名称是：$name") &#125; fun rMethod02(name: String) &#123; println("方法的名称是：$name") &#125;&#125;class Invoker &#123; var command: Command? = null constructor(command: Command) &#123; this.command = command &#125; fun invoker() &#123; command?.let &#123; it.command01("command01") &#125; &#125;&#125;class Command() &#123; var receiver: Receiver? = Receiver() var command01: ((String) -&gt; Unit) = &#123; name -&gt; receiver?.rMethod01(name) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; Invoker(Command()).invoker()&#125; Kotlin自称把函数当第一公民，但是表达能力是没有Scala强的，不过在这里可以使用Lambda表达式替代传统面向对象编程来对命令模式进行编写。 编写中遇到了bug，详细描述见文末参考。 迭代器模式1234567891011121314151617181920212223242526272829303132333435363738394041interface Iterator &#123; fun next(): Any fun hasNext(): Boolean&#125;class ImlIterator(var imlIteratorProduct: ImlIteratorProduct) : Iterator &#123; var index: Int = 0 override fun next(): Any &#123; var s = imlIteratorProduct.arr[index] index++ return s &#125; override fun hasNext(): Boolean &#123; if (index &lt; imlIteratorProduct.arr.size) return true return false &#125;&#125;interface IteratorProduct &#123; fun iterator(): Iterator&#125;class ImlIteratorProduct : IteratorProduct &#123; var arr = arrayListOf&lt;String&gt;("chenchen", "guoguo", "nini", "haohao") override fun iterator(): Iterator &#123; return ImlIterator(this) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var imlIteratorProduct = ImlIteratorProduct() var iter = imlIteratorProduct.iterator() while (iter.hasNext()) &#123; println(iter.next() as String) &#125;&#125; 迭代器模式旨在实现一个简单的迭代器。 中介者模式123456789101112131415161718192021222324252627282930313233343536373839class AA(var name: String) &#123; fun doSomething(mediator: Mediator) &#123; mediator.aMethod() &#125;&#125;class BB(var name: String) &#123; fun doSomething(mediator: Mediator) &#123; mediator.bMethod() &#125;&#125;class Mediator &#123; var a: AA var b: BB constructor(a: AA, b: BB) &#123; this.a = a this.b = b &#125; fun aMethod() &#123; println("$&#123;a.name&#125; 在前，$&#123;b.name&#125; 在后。") &#125; fun bMethod() &#123; println("$&#123;b.name&#125; 在前，$&#123;a.name&#125; 在后。") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var a = AA("小A") var b = BB("小B") var mediator = Mediator(a, b) a.doSomething(mediator) b.doSomething(mediator)&#125; 避免对象之间直接交互，彼此实现看不见对方，中介者作为平台处理对象之间的关系。 备忘录模式1234567891011121314151617181920212223242526272829303132333435363738class Memento(var state: String?)class Originator &#123; var state: String? = null fun saveState(): Memento &#123; return Memento(state) &#125; fun restoreState(memento: Memento) &#123; this.state = memento.state &#125;&#125;class CareTaker &#123; private var list = ArrayList&lt;Memento&gt;() fun add(memento: Memento) &#123; list.add(memento) &#125; fun get(index: Int): Memento &#123; return list[index] &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var originator = Originator() var careTaker = CareTaker() originator.state = "存档01" careTaker.add(originator.saveState()) originator.state = "存档02" println("当前存档：$&#123;originator.state&#125;") originator.restoreState(careTaker.get(0)) println("当前存档：$&#123;originator.state&#125;")&#125; 这里涉及到三个角色Memento、Originator以及CareTaker，本人将Memento理解为记忆点，将Originator理解为记忆点的创造者，而把CareTaker理解为记忆点的存储者。 观察者模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677internal interface Subject &#123; fun registerObserver(o: Observer) fun removeObserver(o: Observer) fun notifyObserver()&#125;// 具体被观察者internal class ConcreteSubject : Subject &#123; private val cs: ArrayList&lt;Observer&gt; = ArrayList() private var `when`: String? = null private var where: String? = null private var what: String? = null override fun registerObserver(o: Observer) &#123; cs.add(o) &#125; override fun removeObserver(o: Observer) &#123; val i = cs.indexOf(o) if (i &gt;= 0) &#123; cs.removeAt(i) &#125; &#125; override fun notifyObserver() &#123; for (i in cs.indices) &#123; val o = cs[i] o.update(`when`, where, what) &#125; &#125; fun reSetData(`when`: String?, where: String?, what: String?) &#123; this.`when` = `when` this.where = where this.what = what notifyObserver() &#125;&#125;// 观察者internal interface Observer &#123; fun update(`when`: String?, where: String?, what: String?)&#125;// 具体观察者internal class ConcreteObserver : Observer, Message &#123; private var `when`: String? = null private var where: String? = null private var what: String? = null private var subject: Subject? constructor(subject: Subject?) &#123; this.subject = subject subject?.registerObserver(this) &#125; override fun update(`when`: String?, where: String?, what: String?) &#123; this.`when` = `when` this.where = where this.what = what message() &#125; override fun message() &#123; println("收到订阅通知：\n时间：$`when`\n地点：$where\n事件：$what") &#125;&#125;internal interface Message &#123; fun message()&#125;fun main(args: Array&lt;String&gt;) &#123; var s = ConcreteSubject() var o = ConcreteObserver(s) s.reSetData("早上十点", "叙利亚", "停战")&#125; 代码的核心在于对被观察者、具体的被观察者、观察者、具体的观察者的编写。订阅的行为交给观察者，而信息的通知对于观察者来说是被动的。 状态模式123456789101112131415161718192021222324252627282930313233internal abstract class State &#123; abstract fun addContext(context: Context) override fun toString(): String &#123; return this.javaClass.simpleName &#125;&#125;internal class Context &#123; var state: State? = null&#125;internal class StartState : State() &#123; override fun addContext(context: Context) &#123; println("打印开始状态名：") context.state = this &#125;&#125;internal class StopState : State() &#123; override fun addContext(context: Context) &#123; println("打印停止状态名：") context.state = this &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var context = Context() StartState().addContext(context) println(context.state) StopState().addContext(context) println(context.state)&#125; 不用方法来判断状态，而是采用类。 策略模式123456789101112131415161718192021222324252627282930313233343536373839404142interface Strategy &#123; fun algori(num01: Double, num02: Double): Double&#125;class `加` : Strategy &#123; override fun algori(num01: Double, num02: Double): Double &#123; return num01 + num02 &#125;&#125;class `减` : Strategy &#123; override fun algori(num01: Double, num02: Double): Double &#123; return num01 - num02 &#125;&#125;class `乘` : Strategy &#123; override fun algori(num01: Double, num02: Double): Double &#123; return num01 * num02 &#125;&#125;class `除` : Strategy &#123; override fun algori(num01: Double, num02: Double): Double &#123; if (num02.equals(0.0)) &#123; throw IllegalArgumentException("错误的被除数输入！") &#125; return num01 / num02 &#125;&#125;class StrategyContext(var strategy: Strategy) &#123; fun operator(num01: Double, num02: Double): Double &#123; return strategy.algori(num01, num02) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; // 计算除法 var context = StrategyContext(`除`()) println(context.operator(5.0, 0.0))&#125; 不用if语句切换算法，而是采用类的多态。这里和观察者模式一样采用了``。 模板方法模式12345678910111213141516171819202122232425abstract class AbstractClass &#123; abstract fun doThing01() abstract fun doThing02() fun display() &#123; doThing01() doThing02() &#125;&#125;class ConcreteClass : AbstractClass() &#123; override fun doThing01() &#123; println("我是doThing01！") &#125; override fun doThing02() &#123; println("我是doThing02！") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var concreteClass = ConcreteClass() concreteClass.display()&#125; 模版方法模式就是在父类中定义流程框架，在子类中实现具体处理。 访问者模式12345678910111213141516171819abstract class Element(open var name: String) &#123; fun accept(visitor: Visitor) &#123; visitor.visit(this) &#125;&#125;class Element01(override var name : String) : Element(name)class Visitor &#123; fun visit(element: Element) &#123; println("被访问者的名字是：$&#123;element.name&#125;") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var visitor = Visitor() var element01 = Element01("Element01") element01.accept(visitor)&#125; 公共接口为被访问者提供接受访问的方法(也就是以访问者为参数传入)，在接受方法内，访问者调用访问方法访问被访问者。 解释器模式小结Why must class member function types be called with invoke? Smart cast doesn’t work for nullable value of functional type]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之Kotlin实现(上)]]></title>
    <url>%2F2018%2F11%2F25%2FKotlin03%2F</url>
    <content type="text"><![CDATA[设计模式主要分创建型、结构型、行为型，这篇文章主要记录本人使用Kotlin实现的创建型和结构型的12种设计模式，包括工厂模式、抽象工厂模式、单例模式、原型模式、建造者模式、适配器模式、组合模式、装饰器模式、享元模式、桥接模式、外观模式、静态代理模式。行为型设计模式在下一篇推出。 创建型工厂模式1234567891011121314151617181920212223242526272829interface Product &#123; fun printProductId()&#125;abstract class Factory &#123; fun product(productId: String): Product &#123; var p = createProduct(productId) return p &#125; protected abstract fun createProduct(productId: String): Product;&#125;class Pen(var productId: String) : Product &#123; override fun printProductId() &#123; println("该笔的ID是：$productId") &#125;&#125;object PenFactory : Factory() &#123; override fun createProduct(productId: String): Product &#123; return Pen(productId) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var oneProduct = PenFactory.product("1024") oneProduct.printProductId()&#125; 将工厂抽象出来，每次生成不同ID的相同产品时，使用相同的工厂生产同种产品。 抽象工厂模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768interface ProductA &#123; fun printProductId()&#125;interface ProductB &#123; fun printProductId()&#125;abstract class AbstractFactory &#123; var producta: ProductA? = null var productb: ProductB? = null fun product(id01: String?, id02: String?) &#123; producta = createProductA(id01) productb = createProductB(id02) &#125; abstract fun createProductA(id: String?): ProductA abstract fun createProductB(id: String?): ProductB&#125;class CompA_ProductA(var id: String?) : ProductA &#123; override fun printProductId() &#123; id?.let &#123;println("组合A的产品A的ID是：$it")&#125; ?: println("没有生产组合A的产品A") &#125;&#125;class CompA_ProductB(var id: String?) : ProductB &#123; override fun printProductId() &#123; id?.let &#123;println("组合A的产品B的ID是：$it")&#125; ?: println("没有生产组合A的产品B") &#125;&#125;class CompB_ProductA(var id: String) : ProductA &#123; override fun printProductId() &#123; println("组合B的产品A的ID是：$id") &#125;&#125;class CompB_ProductB(var id: String) : ProductB &#123; override fun printProductId() &#123; println("组合B的产品B的ID是：$id") &#125;&#125;class CompAFactory(id01: String?, id02: String?) : AbstractFactory() &#123; init &#123; super.product(id01, id02) &#125; override fun createProductA(id: String?): ProductA &#123; return CompA_ProductA(id) &#125; override fun createProductB(id: String?): ProductB &#123; return CompA_ProductB(id) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var compAFactory = CompAFactory("01", null) var compA_ProductA = compAFactory.producta var compA_ProductB = compAFactory.productb compA_ProductA?.printProductId() compA_ProductB?.printProductId()&#125; 每次生成不同ID的相同产品族(比如这里可以指CompA_ProductA、CompA_ProductB构成的族等)，使用相同工厂(这里指CompAFactory)生产同一族产品。 单例模式原型模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253open class Fruitprototype : Cloneableclass FruitImpl : Fruitprototype &#123; var name: String? var orange: Orangeprototype? constructor(name: String, orange: Orangeprototype) &#123; this.name = name this.orange = orange &#125; fun getClone(): FruitImpl? &#123; var fruit: FruitImpl? = null try &#123; fruit = super.clone() as FruitImpl // 对内部引用对象进行拷贝操作 fruit.orange = this.orange?.getClone() &#125; catch (e: CloneNotSupportedException) &#123; e.printStackTrace() &#125; return fruit &#125;&#125;class Orangeprototype : Fruitprototype &#123; var name: String? var id: Int? constructor(name: String, id: Int) &#123; this.name = name this.id = id &#125; fun getClone(): Orangeprototype? &#123; var orange: Orangeprototype? = null try &#123; orange = super.clone() as Orangeprototype &#125; catch (e: CloneNotSupportedException) &#123; e.printStackTrace() &#125; return orange &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val orange01 = Orangeprototype("orange01", 1) val fruit01 = FruitImpl("fruit01", orange01) val fruit02 = fruit01.getClone() (fruit02 as FruitImpl).orange?.let &#123; it.id = 2 &#125; fruit02.orange?.let &#123; it.name = "orange02" &#125; println(orange01.id.toString() + " " + orange01.name)&#125; 程序具体分析见本站之前的原型模式相关文章。 换了一种方式来写类的构造器，可见如果类名后没有显式添加()，那么constructor方法不用写返回类型，而创建类的对象时不能省略参数。 Java里面采用super.clone()是因为对象调用clone()实际是委托了Object类的clone()，具体可以见文章最后的参考，Kotlin应该类似。 如果Fruitprototype声明为接口，那么运行时会报错，目前没有找到具体原因。 建造者模式123456789101112131415161718192021222324252627282930313233343536373839404142class BuilderProduct &#123; val color: String? val id: Int val size: Int companion object Builder &#123; private var color: String? = null private var id: Int = 0 private var size: Int = 0 fun builderColor(color: String): Builder &#123; this.color = color return this &#125; fun builderId(id: Int): Builder &#123; this.id = id return this &#125; fun builderSize(size: Int): Builder &#123; this.size = size return this &#125; fun build(): BuilderProduct &#123; return BuilderProduct(this) &#125; &#125; private constructor(builder: Builder) &#123; this.color = builder.color this.id = builder.id this.size = builder.size &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var builderProduct = BuilderProduct.Builder.builderColor("Red") .builderId(1).builderSize(5000).build() println(builderProduct.size)&#125; 这里的建造者模式参照《Effective Java》来实现，有些设计模式的书籍强调建造者、监工、使用者等角色，在这里监工和使用者合二为一，监工表现为代码编写时的方法调用顺序(Builder方法的连环调用)。 结构型适配器模式1234567891011121314151617181920interface Target &#123; fun targetMathod()&#125;class Adaptee &#123; fun adapteeMethod() &#123; println("我是adaptee！") &#125;&#125;class Adapter(var adaptee: Adaptee) : Target&#123; override fun targetMathod() &#123; adaptee.adapteeMethod() &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var ada = Adapter(Adaptee()) as Target ada.targetMathod()&#125; 有委托的实现方式就不采用继承，最后的as Target说明适配成功，可以应用在使用Target的场景。 组合模式123456789101112131415161718192021222324252627282930313233343536373839abstract class Component(open var size: Int) &#123; abstract fun getId(): String override fun toString(): String &#123; return "$&#123;getId()&#125;大小为：$&#123;size&#125;" &#125;&#125;class Leaf(val id: Int, override var size: Int): Component(size) &#123; override fun getId(): String &#123; return "ID是$&#123;id&#125;的Leaf" &#125;&#125;class Composite(val id: Int, override var size: Int = 0) : Component(size) &#123; var composite = ArrayList&lt;Component&gt;() override fun getId(): String &#123; return "ID是$&#123;id&#125;的Composite" &#125; fun add(e: Component) &#123; composite.add(e) size = composite.size &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var component01 = Composite(1) var component02 = Composite(2) var component03 = Composite(3) var component04 = Composite(4) component01.add(component02) component02.add(component03) component02.add(component04) component02.add(Leaf(11, 100)) println(component01) println(component02)&#125; Leaf、Composite、Component是三个关键角色，Component是Leaf、Composite相似部分的抽象，包括getSize方法，toString方法等。Kotlin和Java的不同之一是Kotlin因为声明的不是字段而是属性，所以涉及到属性的override。 装饰器模式12345678910111213141516171819202122232425interface DecComponent &#123; fun DecPrint()&#125;class ConcreteComponent : DecComponent &#123; override fun DecPrint() &#123; println("我是被装饰的对象！") &#125;&#125;abstract class Decorator(open var decComponent: DecComponent) : DecComponent &#123;&#125;class ConcreteDecorator(override var decComponent: DecComponent) : Decorator(decComponent) &#123; override fun DecPrint() &#123; println("－－－－－我是装饰物－－－－－") decComponent.DecPrint() println("－－－－－我是装饰物－－－－－") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var c = ConcreteComponent() var decorator = ConcreteDecorator(c) decorator.DecPrint()&#125; 代理模式和装饰器模式很像，有的时候也没必要分那么细，如果我问自己它们有什么区别，也只会从“哲学”的角度来回答：代理模式侧重“他是他你是你”，而装饰器模式侧重“你始终是你”。代理模式虽然代理了被代理对象的功能，但是终究不应该是原对象，所以需要new一个新的对象，再就是可能代理模式更强调代理动作的同一性吧(代理方法名相同)，所以装饰器模式未必需要相同方法名的方法来装饰被装饰的方法。至于功能扩展什么的，从实现效果来看代理模式和装饰器模式都能扩展功能。 享元模式123456789101112131415161718192021222324252627interface FruitFlyweight &#123; fun printColor()&#125;class OrangeFlyweight(var color: String) : FruitFlyweight &#123; override fun printColor() &#123; println("$color $this") &#125;&#125;class FruitFactoryFlayweight &#123; companion object &#123; val fruitMap = HashMap&lt;String, FruitFlyweight&gt;() fun getFruitflyweight(color: String): FruitFlyweight &#123; var flyweight = fruitMap[color] flyweight = flyweight ?: OrangeFlyweight(color) fruitMap.put(color, flyweight) return flyweight &#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; FruitFactoryFlayweight.getFruitflyweight("Red").printColor() FruitFactoryFlayweight.getFruitflyweight("Red").printColor()&#125; 基本代码和本站之前的文章一样，区别在于使用了伴生对象。在本站其它文章中的解析已经说明，伴生对象内的属性，实际上是外围类的属性，所以fruitMap声明在伴生对象内。 桥接模式12345678910111213141516171819202122232425262728293031323334353637interface Student &#123; fun study() fun sleep()&#125;// 学生的具体实现class ChinaStudent: Student &#123; override fun study() &#123; println("非常努力！") &#125; override fun sleep() &#123; println("没有时间休息！") &#125;&#125;// 学生参加课外活动功能扩展open class Activities(private var student: Student) &#123; fun study() &#123; student.study() &#125; fun sleep() &#123; student.sleep() &#125;&#125;class ExActivities(var student: Student) : Activities(student) &#123; fun exActivity() &#123; if (student is ChinaStudent) println("中国学生太累不参加活动！") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; ExActivities(ChinaStudent()).exActivity()&#125; 桥接模式在本人看来属于“功能代理实现”，这样新增功能和原本实现可以解耦合。在本例中，学生类的实现在一边，而活动的功能扩展在另一边，最基本的活动“代理”了学生的功能，但是扩展功能并不直接涉及学生类，这样就完成了解耦合。 外观模式12345678910111213141516171819202122232425class A &#123; init &#123; println("我是A！") &#125;&#125;class Bclass Cclass Facade &#123; var a: A? = null var b: B? = null var c: C? = null fun facadeMethod() &#123; a = A() b = B() c = C() &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var facade = Facade() facade.facadeMethod() facade.a&#125; 例子中facadeMethod方法给出了一个一致的界面，实现了一个简单的外观模式。 代理模式123456789101112131415161718192021interface Proxy &#123; fun doSomething()&#125;class ProxyIml : Proxy &#123; override fun doSomething() &#123; println("我是被代理的对象！") &#125;&#125;class RealProxy(var proxy: Proxy = ProxyIml()) : Proxy &#123; override fun doSomething() &#123; println("我是代理人！") proxy.doSomething() &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; RealProxy().doSomething()&#125; 这里暂时只给出静态代理，动态代理在本站关于AOP的部分中已经提到过。 参考http://www.runoob.com 图解设计模式 Why when implementing clone method we return super.clone() not this clone()]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些Java场景在Kotlin下的解决之道]]></title>
    <url>%2F2018%2F11%2F20%2FKotlin02%2F</url>
    <content type="text"><![CDATA[Kotlin的设计主管宣称“Kotlin修复了Joshua Bloch的Java Puzzlers丛书中提及的半数问题”，《Effective Java》应该也算丛书的一本吧。本人在使用Kotlin时已经强烈的感受到了这一点。此篇主要记录本人在使用Kotlin重构Java代码时中遇到的一些问题。 命令行编译与运行假设现在有一个写好的kotlin文件Ak.kt，首先对其进行编译： 1$ kotlinc Ak.kt -include-runtime -d Ak.jar -include-runtime用来打包kotlin运行时库。 接下来运行程序： 1$ java -jar Ak.jar 伴生对象硬核原理虽然在Kotlin的世界里，人们一直强调没有static没有static，但本人还是想通过查看字节码文件这种硬核的方式理解一些概念。编写一个Kotlin例子，package为ObjectDemo： 123456789101112class AA &#123; var i = 19 fun methodA() &#123;&#125; companion object BB&#123; var j = 29 fun methodB() &#123;&#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;&#125; 这个例子在AA中放一个i属性，一个methodA方法；伴生对象内放一个j属性以及methodB方法。 编译之后会生成三个文件AA$BB.class、AA.class、ObjectDemoKt.class。 虽说main在源文件里是一个所谓的顶层函数，但其实编译后会将其放入一个ObjectDemoKt类中，默认类名就是包名+Kt。 接下来本人将主要分析AA$BB.class、AA.class这两个文件。 首先是AA.class，对其进行反编译有： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public final class ObjectDemo.AA &#123; public static final ObjectDemo.AA$BB BB; public final int getI(); Code: 0: aload_0 1: getfield #10 // Field i:I 4: ireturn public final void setI(int); Code: 0: aload_0 1: iload_1 2: putfield #10 // Field i:I 5: return public final void methodA(); Code: 0: return public ObjectDemo.AA(); Code: 0: aload_0 1: invokespecial #20 // Method java/lang/Object."&lt;init&gt;":()V 4: aload_0 5: bipush 19 7: putfield #10 // Field i:I 10: return static &#123;&#125;; Code: 0: new #43 // class ObjectDemo/AA$BB 3: dup 4: aconst_null 5: invokespecial #46 // Method ObjectDemo/AA$BB."&lt;init&gt;":(Lkotlin/jvm/internal/DefaultConstructorMarker;)V 8: putstatic #48 // Field BB:LObjectDemo/AA$BB; 11: bipush 29 13: putstatic #27 // Field j:I 16: return public static final int access$getJ$cp(); Code: 0: getstatic #27 // Field j:I 3: ireturn public static final void access$setJ$cp(int); Code: 0: iload_0 1: putstatic #27 // Field j:I 4: return&#125; 通过这个反编译结果，可以迅速得到一些结论： 写在伴生对象内j属性会被编译成AA的静态字段j； 写在AA中的var属性i会被编译为普通字段i，并配有final的普通get、set方法； j还会在AA中被编译出隐含的static final的get、set方法 ； methodA()在AA中是final的普通方法； AA内还会存在一个static、final的BB对象的静态初始化器； 再来看看AA$BB.class： 12345678910111213141516171819202122public final class ObjectDemo.AA$BB &#123; public final int getJ(); Code: 0: invokestatic #11 // Method ObjectDemo/AA.access$getJ$cp:()I 3: ireturn public final void setJ(int); Code: 0: iload_1 1: invokestatic #18 // Method ObjectDemo/AA.access$setJ$cp:(I)V 4: return public final void methodB(); Code: 0: return public ObjectDemo.AA$BB(kotlin.jvm.internal.DefaultConstructorMarker); Code: 0: aload_0 1: invokespecial #27 // Method "&lt;init&gt;":()V 4: return&#125; 通过这个反编译结果，又可以得出些结论： BB按照Java中来理解，相当于是AA的内部类； 在BB内会编译出j的get、set方法，它们是普通的、final的，包装了AA中隐含的static final的get、set方法； methodB()也是final、非静态的； 由此很多概念就不陌生了。 Java静态块改写Kotlin中没有静态的概念，可以使用伴生对象来实现。例如： 123456789101112class StaticDemo &#123; companion object &#123; var i: Int = 3 var j: Int = 7 init &#123; j = 4 &#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;&#125; 对其使用javap反编译，摘取其中static{}部分： 1234567891011121314static &#123;&#125;; Code: 0: new #42 // class kotlindemo01/StaticDemo$Companion 3: dup 4: aconst_null 5: invokespecial #45 // Method kotlindemo01/StaticDemo$Companion."&lt;init&gt;":(Lkotlin/jvm/internal/DefaultConstructorMarker;)V 8: putstatic #47 // Field Companion:Lkotlindemo01/StaticDemo$Companion; 11: iconst_3 12: putstatic #20 // Field i:I 15: bipush 7 17: putstatic #26 // Field j:I 20: iconst_4 21: putstatic #26 // Field j:I 24: return 内部会创建静态字段i、j以及指向内部类对象的静态引用(public static final kotlindemo01.StaticDemo$Companion Companion)。 在上面的例子中，StaticDemo可以直接调用i或j属性，和Java不一样的是，StaticDemo对象并不能调用i或j的属性。在main方法中执行StaticDemo.i语句，反编译有： 123456789public static final void main(java.lang.String[]); Code: 0: aload_0 1: ldc #9 // String args 3: invokestatic #15 // Method kotlin/jvm/internal/Intrinsics.checkParameterIsNotNull:(Ljava/lang/Object;Ljava/lang/String;)V 6: getstatic #21 // Field kotlindemo01/StaticDemo.Companion:Lkotlindemo01/StaticDemo$Companion; 9: invokevirtual #27 // Method kotlindemo01/StaticDemo$Companion.getI:()I 12: pop 13: return 可见StaticDemo.i会被编译器编译为内部类的实例调用后者的getI方法(结合后文另一种调用方式解释了为什么在Java中需要写全为StaticDemo.Companion.j，Java的编译器不会编译出Kotlin编译器的结果)，反编译该内部类： 1234567891011121314151617181920212223242526272829public final class kotlindemo01.StaticDemo$Companion &#123; public final int getI(); Code: 0: invokestatic #11 // Method kotlindemo01/StaticDemo.access$getI$cp:()I 3: ireturn public final void setI(int); Code: 0: iload_1 1: invokestatic #18 // Method kotlindemo01/StaticDemo.access$setI$cp:(I)V 4: return public final int getJ(); Code: 0: invokestatic #24 // Method kotlindemo01/StaticDemo.access$getJ$cp:()I 3: ireturn public final void setJ(int); Code: 0: iload_1 1: invokestatic #28 // Method kotlindemo01/StaticDemo.access$setJ$cp:(I)V 4: return public kotlindemo01.StaticDemo$Companion(kotlin.jvm.internal.DefaultConstructorMarker); Code: 0: aload_0 1: invokespecial #34 // Method "&lt;init&gt;":()V 4: return&#125; 每一个普通方法调用的又是StaticDemo下的kotlindemo01/StaticDemo.access$getI$cp等静态方法。这也解释了为什么StaticDemo.Companion.j也可以运行的原因。 通过反编译还可以了解的是：companion object括号内声明的属性，是属于StaticDemo的字段(kotlindemo01/StaticDemo.i:I)，而且是静态字段。 使用@JvmStatic可以将半生对象中的字段转化为纯Java中的静态字段。 避免双感叹号使用在改写Java代码的时候，最常遇见的问题是IDE提示“Only safe(?.) or non-null asserted(!!.)…”，例如： 1234567891011121314151617class NotNullDemo &#123; var b: B? = null fun testMethod() &#123; var s = b.pr // 点号处报错 print(s) &#125;&#125;class B &#123; var pr:Int = 3&#125;fun main(args: Array&lt;String&gt;) &#123; var n = NotNullDemo() n.testMethod()&#125; 此时采用双感叹号会立马解决问题，但是本人认为采用了这种方法后和在Java中使用null指针别无二致了，因为一旦方法接收者或者字段持有对象等为空就会抛出异常。另外的方法： 123var s = b?.let &#123; it.pr &#125;// 或者： var s = b?.pr// 如果希望返回指定值： var s = b?.pr?: 2 注释中?:是猫王操作符，用法类似三元运算符。 Kotlin之迭代通常一般性的迭代可以有两种等价的方式，下面用一个小例子说明： 123456789101112fun main(args: Array&lt;String&gt;) &#123; var l = listOf&lt;Int&gt;(2, 1, 3, 4) for (i in l.iterator()) print("$i ") println() var iter = l.iterator() while (iter.hasNext()) &#123; var e = iter.next() print("$e ") &#125;&#125; 在Java中对集合进行迭代时不能进行remove等操作，在Kotlin中分可变集合和不可变集合，对不可变集合可以进行相应的更改操作，通常后者类名或接口名的前缀会多出“Mutable”字样，表示可变。 在写代码的过程中，forEach可能嵌套多层，这个时候可能出现it重复的问题，可以更改一层的it： 1l?.let &#123; it.forEach &#123;e -&gt; print("$e ")&#125; &#125; 数组的运用用一组代码比较Java和Kotlin： 123int[] intArr = &#123;1, 2&#125; // var intArr = arrayOf(1, 2)int[] intArr01 = new int[3] // var intArr01 = InitArray(3)String[] intArr02 = new String[4] // var arr04 = arrayOfNulls&lt;String&gt;(4) 采用Array(3)编译不会通过，基本类型的Array可以采用类型名加Array加数组范围的初始化形式(例如InitArray(3))，非基本类型可以使用arrayOfNulls。 Array初始化的基本方法： 1var arr = Array(3) &#123;Array(3, &#123;it -&gt; it.inc() - 1&#125;) &#125; 相当于对一个[0, 1, 2]数组的每个元素进行Lambda表达式的处理，上述代码是支持Lambda柯里化的： 1var arr = Array(3) &#123; Array(3) &#123;it -&gt; it.inc() - 1&#125; &#125; 当然参数也可以传入函数变量： 12345var f = (fun(x: Int): Int &#123; return x&#125;)var arr02 = Array(3, f) 创建空数组： 1var empty = emptyArray&lt;Int&gt;() 必须配置泛型。 小结本人在重构Java代码的时候遇到了一些常见的代码问题，以上是解决这些问题后的总结，后续还会适时更新。 参考Kotlin的诞生：专访JetBrains的Andrey Breslav How to overcome “same JVM signature” error when implementing a Java interface?]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>重构</tag>
        <tag>持续更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再次更新的NIO：NIO2之底层基础]]></title>
    <url>%2F2018%2F11%2F17%2FNIO2%2F</url>
    <content type="text"><![CDATA[过往写过的一些小case，读取文件的字节还在使用while循环，后来发现Java 7提供的新特性能很轻松的调用相关方法实现，遂感慨：这个版本的更新还是有些东西的。于是以此为契机，从Java NIO说开去，本篇主讲Java NIO基本的底层基础。 缓存区、DMA缓存区的理解可以阅读《Linux/UNIX系统编程手册》，虽然感觉写得不是很深入，但是作为Java程序员来讲似乎够用。 通常来说read()和write()不会直接发起磁盘访问，而是从用户空间缓冲区到内核缓冲区高速缓存(kernel buffer cache)之间复制数据。 缓冲区设计目的： 使read()和write()调用操作更快； 减少内核的磁盘传输次数； 受限因素： 可用的物理内存总量； 出于其他目的对物理内存的需求； 可见缓冲区也是物理内存的一部分，而不是单独设定的区域。如果没有缓冲区，对磁盘的读写将进行多次的系统调用，虽然这比磁盘操作快，但是并不能提高I/O的性能。设定一定大小的缓冲区进行I/O，可以拥有更少的系统调用和更高的I/O性能。 DMA：直接内存读取。通过DMA磁盘把数据直接写入内核缓冲区，不需要CPU协作。 此时就会产生一个疑问：为什么要经过内核缓冲区绕一圈进行读写呢？ 两个原因： 硬件通常不能直接访问用户空间； 磁盘操作的是固定大小的数据块(这个涉及到物理构造)，而用户请求的通常是任意大小的数据或非对齐的数据块； 内核缓冲区就像中央政府，它把数据汇聚在一起，然后发散到多个用户空间缓冲区，“聚是一团火，散是满天星”。 虚拟内存MMU：负责虚拟内存的“总管”，它来负责虚拟地址映射的操作，没有它CPU直接访问内存芯片的地址。 我们知道无论是内核空间地址还是用户空间地址，他们都不是真正的物理地址，如果用户空间的地址和内核地址映射到同一物理地址，那么就可以免去内核和用户空间的拷贝(这里涉及到零拷贝，后续将深入)。所以虚拟内存的一个好处就是：一个以上的虚拟地址可以指向同一个物理内存地址。 内存映射文件 &amp; 零拷贝这是一波大节奏，因为相关的底层实现并没有想象中的那么简单，但是作为Java程序员如果只是了解了基本的抽象，似乎也不会完全阻碍实际代码的编写，本小结就来领略这些抽象。 普通磁盘I/O首先看一张图： 可以看出一次IO的过程通常是：hard drive -&gt; kernel buffer -&gt; user buffer -&gt; socket buffer -&gt; protocol engine。会经历两次DMA copy，两次CPU copy。 mmapmmap如何工作的呢？引用一段知乎上某答案的解释(具体答案见文末链接)： mmap的工作原理，当你发起这个调用的时候，它只是在你的虚拟空间中分配了一段空间，连真实的物理地址都不会分配的，当你访问这段空间，CPU陷入OS内核执行异常处理，然后异常处理会在这个时间分配物理内存，并用文件的内容填充这片内存，然后才返回你进程的上下文，这时你的程序才会感知到这片内存里有数据… 这正是前面内存映射文件的具体实现。如此一来，IO的过程变成如下新图： 通过这种方法，减少了一次CPU copy，也就是磁盘到用户缓冲区的拷贝。 sendfile01snedfile的原理见下图： 它连shared的部分都不存在了，也是减少了内核态到用户态上下文的切换，进一步优化了mmap。 sendfile02sendfile02比起sendfile01更进一步减少了CPU copy，继续看下图： 免去了一次kernel buffer到socket buffer的CPU拷贝，Zero Copy I: User-Mode Perspective中这样描述这一步骤： No data is copied into the socket buffer. Instead, only descriptors with information about the whereabouts and length of the data are appended to the socket buffer. The DMA engine passes data directly from the kernel buffer to the protocol engine, thus eliminating the remaining final copy. 小节sendfile01和小节sendfile02介绍的方法在api调用层面是相同的： 1sendfile(socket, file, len); 所以，具体采用哪一种需要知道操作系统的内核版本。如果是2.4以前版本则使用的是sendfile01。 绕过缓冲区高速缓存：直接I/O前面介绍的方法，很多人认为就是零拷贝，但是也有很多人认为不是。差别就在于是否认可将数据拷贝到内核缓冲区。在《Linux/UNIX系统编程手册》的十三章介绍了绕过缓冲区的方法和原理。Linux在进行直接I/O的过程中，也要遵守一些限制： 缓冲区内存边界必须对齐为块的整数倍； 传输起点也应该是块大小的整数倍； 传输的数据长度也应该是块大小的整数倍； 这里的缓冲区指的是用户空间缓冲区，块大小是设备的物理块大小，通常为512字节。 关于直接I/O还可以看看IBM Developer：Linux 中直接 I/O 机制的介绍这篇文字的相关段落： 凡是通过直接 I/O 方式进行数据传输，数据均直接在用户地址空间的缓冲区和磁盘之间直接进行传输，完全不需要页缓存的支持。操作系统层提供的缓存往往会使应用程序在读写数据的时候获得更好的性能，但是对于某些特殊的应用程序，比如说数据库管理系统这类应用，他们更倾向于选择他们自己的缓存机制，因为数据库管理系统往往比操作系统更了解数据库中存放的数据，数据库管理系统可以提供一种更加有效的缓存机制来提高数据库中数据的存取性能。 Channel理解《Java NIO》作者: Ron Hitchens将Channel比做银行出纳使用的气动导管，载体就是缓冲区，支票是data，将data填充缓冲区，接着再通过Channel传递到另一侧。 所以本人认为Channel抽象了端到端的信息传送。不同的Channel，通过前面的底层实现，进行data的不同方式的传递。 小结本篇主要介绍了NIO.2实现的底层基础，这和操作系统的实现细节密切相关，通过本篇有助于进一层理解Java NIO.2，而非局限于api的调用。 参考《Linux/UNIX系统编程手册》(主要是第十三章) MMU 维基百科：内存映射文件 《Java NIO》作者: Ron Hitchens 并发编程网：Linux零拷贝原理 Zero Copy I: User-Mode Perspective 知乎问题：Linux 中 mmap() 函数的内存映射问题理解？ IBM Developer：Linux 中直接 I/O 机制的介绍]]></content>
      <categories>
        <category>NIO2</category>
      </categories>
      <tags>
        <tag>内存映射文件</tag>
        <tag>mmap</tag>
        <tag>Channel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kqueue ooo...]]></title>
    <url>%2F2018%2F11%2F10%2Fkqueue%2F</url>
    <content type="text"><![CDATA[实在不想起一个犯困的标题了，但也没想好要起什么，就这样吧，本篇主要涉及的对象是kqueue。 主要APIEV_SETEV_SET是一个宏： 123456789#define EV_SET(kevp, a, b, c, d, e, f) do &#123; \ struct kevent *__kevp__ = (kevp); \ __kevp__-&gt;ident = (a); \ __kevp__-&gt;filter = (b); \ __kevp__-&gt;flags = (c); \ __kevp__-&gt;fflags = (d); \ __kevp__-&gt;data = (e); \ __kevp__-&gt;udata = (f); \&#125; while(0) kevent结构体代码如下： 12345678struct kevent &#123; uintptr_t ident; /* identifier for this event */ int16_t filter; /* filter for event */ uint16_t flags; /* general flags */ uint32_t fflags; /* filter-specific flags */ intptr_t data; /* filter-specific data */ void *udata; /* opaque user data identifier */&#125;; ident：文件描述符，比如打开一个新的文件，它的文件描述符会是3； filter：过滤器，可被注册监控的事件； flags：传入的filter事件如何设置 EV_ADD：添加该事件到kqueue EV_DELETE：从kqueue删除该事件 EV_ENABLE：该事件是否可用，默认可用 … fflags：特定的过滤器flag； data：特定的过滤器数据值； opaque user data identifier； filter &amp; fflagsfilter比较重要，需要单独列出。 filter： #define EVFILT_READ (-1)； #define EVFILT_WRITE (-2)； #define EVFILT_AIO (-3)； #define EVFILT_VNODE (-4)：检测文件改动，fflags可以具体到特定事件； fflags： #define NOTE_DELETE 0x0001：文件删除； #define NOTE_WRITE 0x0002：文件写入； #define NOTE_EXTEND 0x0004：文件扩展； #define NOTE_ATTRIB 0x0008：属性改变； #define NOTE_LINK 0x0010：文件被链接的数量改变； #define NOTE_RENAME 0x0020：文件重命名； #define NOTE_EXIT 0x80000000：文件退出； … kevent()代码如下： 1234567int kevent( int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout); kq：kqueue返回值； changelist &amp; nchanges：注册／反注册事件数组； eventlist &amp; nevents：向调用进程返回的事件数组； timeout：功能如其名，设置为NULL时，一直等待； 本人并没有找到kevent函数的源码，一切都封装好，两个数组如何使用，见后面内容。 逻辑解析kqueue由于高度封装，模仿示例(man)就能写出代码。下面先按照本人的理解整理一下基本的逻辑思路，这里以监控文件改动为例(为了方便理解采用了面向对象的角度)： 创建kqueue对象kq(由kqueue()返回)、创建一个kevent结构体ev，作用是收集参数、创建用于监控的打开文件fd。 使用宏EV_SET，把ev参数初始化，那么就需要对这些参数有了解： 第一个参数就是监控打开文件fd； 第二个参数filter就是事件； 如何处理filter事件？是设定入kq，还是从kq中删除？这就引入了第三个参数flag，常用的包括EV_ADD、EV_ENABLE等等； 有些事件需要更细的设定，比如监控改动这个事件EVFILT_VNODE，改动的方式有很多，删除(NOTE_DELETE)、写入、属性改变等等，那么也应该将“关注”的这些动作进行设定声明，这些设定需要传给第四个参数； 第五个参数data用于返回一些特定数据； 第六个udata用于携带一些信息，可以在一些情形发挥作用； 这个饱含信息量的结构体最后会进入kevent中和kq发生化学反应，什么反应就需要知道源码，前面说了我不知道，但是通常也不需要知道，只需要明白这个函数的效果就足够。 一开始看代码的时候没有弄清楚changelist和eventlist的用处，后来发现并不复杂，前者用来注册事件，后者用来实际监控注册的事件。 比如先初始化一个结构体数据： 1234567EV_SET(&amp;ev, fd, EVFILT_VNODE, EV_ADD | EV_ENABLE, NOTE_DELETE|NOTE_WRITE, 0, 0) 注册就可以通过下面代码完成： 1kevent(kq, &amp;ev, 1, NULL, 0, &#123;1, 0&#125;) 而监控的时候可以使用代码： 12struct kevent eve[1];kevent(kq, NULL, 0, eve, 1, &#123;1, 0&#125;); 一开始本人困惑于eve如何初始化，不过很快就会发现，kevent函数完成了一切工作，这里eve就是之前注册的ev，在kevent()内部应该完成了一次数据的传递。 总之很奇怪的写法，但又不得不接受，这么写可能有一些基于性能的考虑，也可能，就是早起代码不规范的产物，又或者是为了隐匿具体实现，但是只要能用，就是好的。 实例写一个最简单的实例来进行说明，这个例子主要是监控本地磁盘上readme.md文件的写事件： 1234567891011121314151617181920212223242526int main(int argc, char *argv[]) &#123; int fd, kq, n; struct kevent rege[1]; struct kevent e[1]; fd = open(argv[1], O_RDWR); kq = kqueue(); EV_SET(rege, fd, EVFILT_VNODE, EV_ADD | EV_ENABLE | EV_CLEAR, NOTE_WRITE, 0, 0); for (;;) &#123; n = kevent(kq, rege, 1, e, 1, NULL); if (n == -1) err(1, "出现错误！");// if (nev == 0)// continue; if (e-&gt;fflags &amp; NOTE_WRITE) &#123; printf("出现了写事件！"); e-&gt;fflags &amp;= ~NOTE_WRITE; &#125; printf("\n"); if (e-&gt;fflags) &#123; warnx("无法解析的事件！"); &#125; &#125;&#125; 当对readme.md进行写操作的时候，代码可以对该事件进行捕捉。 如果设置了timeout，那么不能取消注释。 小结IO多路复用是Java NIO的基础，kqueue通过kevent函数对底层的实现进行了很好的封装，调用就完事。 参考 reebsd高级I/O,kevent的资料很详细 FreeBSD Manual Pages: kqueue 每天进步一点点——Linux中的文件描述符与打开文件之间的关系 IBM：使用 kqueue 在 FreeBSD 上开发高性能应用服务器 kqueue示例：1.标准输入流到标准输出流 2.TCP服务器]]></content>
      <categories>
        <category>IO多路复用</category>
      </categories>
      <tags>
        <tag>Kqueue</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala入门，以Java程序员的视角(三)：孤立对象和伴生对象]]></title>
    <url>%2F2018%2F11%2F10%2FScala04%2F</url>
    <content type="text"><![CDATA[孤立对象和伴生对象都是单例对象，这是Scala和Java语法很大差别的地方，本篇将对这两个概念进行深入研究。 孤立对象解析前的准备工作先写一个最简单的例子： 12345678object Testdemo01 &#123; val a = 3 def add(x: Int) = x * 2 def main(args: Array[String]): Unit = &#123; add(a) &#125;&#125; 这段代码编译后会产生两个.class文件，首先反编译Testdemo01.class(使用javap -c -p会省略常量池，常量池显现可以采用javap -c -v)，得到： 123456789101112131415161718192021public final class scala.C2.Testdemo01 &#123; public static void main(java.lang.String[]); Code: 0: getstatic #16 // Field scala/C2/Testdemo01$.MODULE$:Lscala/C2/Testdemo01$; 3: aload_0 4: invokevirtual #18 // Method scala/C2/Testdemo01$.main:([Ljava/lang/String;)V 7: return public static int add(int); Code: 0: getstatic #16 // Field scala/C2/Testdemo01$.MODULE$:Lscala/C2/Testdemo01$; 3: iload_0 4: invokevirtual #22 // Method scala/C2/Testdemo01$.add:(I)I 7: ireturn public static int a(); Code: 0: getstatic #16 // Field scala/C2/Testdemo01$.MODULE$:Lscala/C2/Testdemo01$; 3: invokevirtual #26 // Method scala/C2/Testdemo01$.a:()I 6: ireturn&#125; 接下来反编译Testdemo01$.class，得到： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public final class scala.C2.Testdemo01$ &#123; public static scala.C2.Testdemo01$ MODULE$; private final int a; public static &#123;&#125;; Code: 0: new #2 // class scala/C2/Testdemo01$ 3: invokespecial #14 // Method "&lt;init&gt;":()V 6: return public int a(); Code: 0: aload_0 1: getfield #17 // Field a:I 4: ireturn public int add(int); Code: 0: iload_1 1: iconst_2 2: imul 3: ireturn public void main(java.lang.String[]); Code: 0: aload_0 1: aload_0 2: invokevirtual #26 // Method a:()I 5: invokevirtual #28 // Method add:(I)I 8: pop 9: return private scala.C2.Testdemo01$(); Code: 0: aload_0 1: invokespecial #30 // Method java/lang/Object."&lt;init&gt;":()V 4: aload_0 5: putstatic #32 // Field MODULE$:Lscala/C2/Testdemo01$; 8: aload_0 9: iconst_3 10: putfield #17 // Field a:I 13: return&#125; 字节码解析为了方便描述，将反编译Testdemo01.class的内容称为为A，将反编译Testdemo01$.class的内容称为B，将改动源码并反编译后的相异部分称为B_change； 从内容上来看，作为程序执行唯一入口的public static void main方法出现在A，所以Java虚拟机主要是通过对Testdemo01.class解释、编译来执行程序的。 A的public static void main方法 getstatic #16：访问类字段，将其压入操作数栈的栈顶；这里的类就是Testdemo01$，而类字段就是它的一个实例MODULE$； aload_0：将局部变量表索引为0的位置保存的引用型数值复制一份到操作数栈的栈顶A的main是静态方法，所以局部变量表索引为0的位置存放传入参数java.lang.String[]的字符串数组引用； invokevirtual #18：先确定从操作数栈顶开始索引为方法显式参数个数值的元素，然后找到该元素所指向的对象的实际类型，记作C，然后查询并验证C中简单名和描述符都match的方法，如果失败则根据类的继承关系从下往上顺序查询，直到成功或失败，整个过程中栈顶的引用元素和方法的参数也随着命令的执行从栈顶推出[《深入理解Java虚拟机(第2版)》](https://book.douban.com/subject/24722612/)写道的“找到操作数栈顶的第一个元素所指向的对象的实际类型记作C”有误。回到原例，invokevirtual会找到getstatic得到的对象的实际类型，于是找到Testdemo01$并执行它的main方法； Scala编译出的Testdemo01类下的方法都是静态方法，和上述中的main方法类似，这里就不多言了，可以发现这些静态方法全部封装了反编译出的Testdemo01$类的方法。 B的public void main方法 aload_0：将局部变量表索引为0的位置保存的引用型数值复制一份到操作数栈的栈顶B的main不是静态方法，所以索引为0的位置保存的是this，这里将其复制到栈顶； aload_0：重复上一步的工作执行两次该字节码指令是因为下面会相继调用两个方法，每个方法调用默认需要传入参数this； invokevirtual #26：原理同前文中的invokevirtual #18这里相当于执行this.a()，并将结果返回main方法的操作数栈； invokevirtual #28：同上这里相当于执行this.add(x)，这里的x是上一步this.a()返回的值； 孤立对象总结现在一切都明了了，Scala将object Testdemo01{…}编译成Testdemo01类和Testdemo01$类，践行的是《Effective Java》中提到的静态工厂方法，只不过在Scala里，整个过程分配在了两个类中； 伪代码类似： 12345678910111213141516171819202122232425262728293031323334353637public final class TestDemo01 &#123; public static void main(String args[]) &#123; MODULE$.main(args); &#125; public static int add(int a) &#123; return MODULE$.add(a); &#125; public static int a() &#123; return MODULE$.a(); &#125;&#125;final class Testdemo01$ &#123; private final int a; public static Testdemo01$ MODULE$ = new Testdemo01$(); private Testdemo01$() &#123; a = 3; &#125; public void main(String args[]) &#123; add(a()); &#125; public int a() &#123; return a; &#125; public int add(int a) &#123; return a * 2; &#125;&#125; 伴生对象伴生对象的产生，是在之前的基础上，于同一文件中添加一个同名class。由于之前的分析，当知道这一规则后，本人多少能猜测到一些Scala语言设计者的设计意图，因为之前Testdemo01类都是静态方法，如若单独添加一个同名Class应该是相当于可以添加独立的字段和方法，下面印证一下。 在前文的代码基础上添加一个同名class： 12345678class Testdemo01 &#123; val s01 = "chenchen" var s02 = "guoguo" def newAdd(b: Int) = &#123; b + 1 &#125;&#125; 之前反编译得到的Testdemo01$类没有任何变化，变化的是反编译产生的Testdemo01类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class scala.C2.Testdemo01 &#123; private final java.lang.String s01; private java.lang.String s02; public static void main(java.lang.String[]); Code: 0: getstatic #19 // Field scala/C2/Testdemo01$.MODULE$:Lscala/C2/Testdemo01$; 3: aload_0 4: invokevirtual #21 // Method scala/C2/Testdemo01$.main:([Ljava/lang/String;)V 7: return public static int add(int); Code: 0: getstatic #19 // Field scala/C2/Testdemo01$.MODULE$:Lscala/C2/Testdemo01$; 3: iload_0 4: invokevirtual #25 // Method scala/C2/Testdemo01$.add:(I)I 7: ireturn public static int a(); Code: 0: getstatic #19 // Field scala/C2/Testdemo01$.MODULE$:Lscala/C2/Testdemo01$; 3: invokevirtual #29 // Method scala/C2/Testdemo01$.a:()I 6: ireturn public java.lang.String s01(); Code: 0: aload_0 1: getfield #32 // Field s01:Ljava/lang/String; 4: areturn public java.lang.String s02(); Code: 0: aload_0 1: getfield #36 // Field s02:Ljava/lang/String; 4: areturn public void s02_$eq(java.lang.String); Code: 0: aload_0 1: aload_1 2: putfield #36 // Field s02:Ljava/lang/String; 5: return public int newAdd(int); Code: 0: iload_1 1: iconst_1 2: iadd 3: ireturn public scala.C2.Testdemo01(); Code: 0: aload_0 1: invokespecial #46 // Method java/lang/Object."&lt;init&gt;":()V 4: aload_0 5: ldc #48 // String chenchen 7: putfield #32 // Field s01:Ljava/lang/String; 10: aload_0 11: ldc #50 // String guoguo 13: putfield #36 // Field s02:Ljava/lang/String; 16: return&#125; main、add、a方法之后就是新增的方法，它们是s01、s02、s02_$eq、newAdd以及Testdemo01方法。其中s01、s02是程序隐藏的get方法，s02_$eq是set方法，成功印证了我的猜测； 从字节码可以看出，首先编译的是object存在的部分，如果在class中间添加一个和object签名相同的方法，那么object的这个方法将被覆盖为class的方法，然后被编译，限于篇幅实验略； 小结本篇主要探讨的是孤立对象和伴生对象，Scala号称没有静态方法域，但通过分析可以很清楚的直到，孤立对象和伴生对象底层是通过静态工厂方法实现的。]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Scala</tag>
        <tag>字节码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读《Go程序设计语言》：从Java的视角掌握Go(二)]]></title>
    <url>%2F2018%2F11%2F07%2Fgo-learning02%2F</url>
    <content type="text"><![CDATA[本人在阅读《Go程序设计语言》时，通过比较Java和Go的不同来快速掌握Go语言，这是第二篇。 基本数据本章的主题是基础类型：数字、字符串和布尔类型。 整数和Java不同的是，Go同时具备符号整数和无符号整数：int8、int16、int32、int64以及uint8、uint16、uint32、uint64； Go还提供int和uint，它们的大小取决于所处的硬件平台和使用的编译器，在本人的机器上测试： 12345678package mainimport "unsafe"func main() &#123; println(unsafe.Sizeof(int(0))) println(unsafe.Sizeof(uint(0)))&#125; 输出为： 1288 各占8个字节。 rune和byte分别是int32和uint8的同义词，所谓同义词就是它们满足前面提到的可赋值性： 123456789var ww bytevar www uint8var rr runevar rrr int32func main() &#123; fmt.Println(ww == www) fmt.Println(rr== rrr)&#125; 输出结果是： 12truetrue Go还存在一种无符号整数uintptr，它的大小不定，但可以存放指针； 和Java不一样的是，Go的取模运算符%只能用于整数； Go没有&gt;&gt;&gt;位运算符； 浮点数和Java不一样的是，Go具有两种大小的浮点数float32和float64，他们的最大值分别是math.MaxFloat32和math.MaxFloat64，绝大多数情况优先使用float64，因为float32会迅速累计误差； 和Java一样，浮点数可写成小数形式，小数点前的数字可以省略，后面也可以省略： 123456func main() &#123; var ff01 = 1. var ff02 = .7 println(ff01) println(ff02)&#125; 在Go中正无穷大和负无穷大分别用+Inf和-Inf来表示，在Java中则用Infinity和-Infinity表示； 在Go中用代表0值的变量作为分母进行运算，得到的结果是NaN； 复数略。 布尔值和Java一样，&amp;&amp;表示逻辑乘法，||表示逻辑加法； 布尔值无法隐式转换成数值(0或1)，需要手写函数变换： 1234i := 0if b &#123; i = 1&#125; 字符串和Java不同，由于Go的变量声明存在零值机制，在没有手动初始化之前，字符串变量默认为&quot;&quot;； 在Go中，子串生成操作s[i:j]产生新字符串，如果下标越界可以躲过IDE的检查，但是运行会触发宕机异常； 加号运算符可以连接两个字符串生成新的字符串； Go提供了原生的字符串字面量的书写形式：`…`，例如： 12345func main() &#123; var s string = `asdadsasdad dsad` println(s[3])&#125; 输出为： 197]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读《Go程序设计语言》：从Java的视角掌握Go(一)]]></title>
    <url>%2F2018%2F11%2F05%2Fgo-learning%2F</url>
    <content type="text"><![CDATA[本人在阅读《Go程序设计语言》时，通过比较Java和Go的不同来快速掌握Go语言。 程序结构名称Go和Java一样，存在一定数量的关键字，不能被用作名称，但Go有三十多个内置的预声明常量、类型和函数，它们不是预留的，是可以重声明的； 和Java不同的是，Go没有复杂的访问修饰符，基本上只包括函数内访问(这里暂时不考虑闭包)、包访问、跨包访问。实体在函数内声明就只在该函数内部局部有效，函数外声明则对包里的所有源文件可见，如果名称以大写字母开头则支持跨包访问。 Go的编程风格偏向于短名称，特别是作用域小的局部变量，名称作用域越大，越使用长和更有意义的名称； 缩写词通常使用统一的大小写，比如HTML或者html，但不用Html； 变量变量的声明形式和Java存在一定的区别，如下所示： 1var name type = expression type和expression不能同时省略，当expression省略时，Go存在零值机制保障。 在Java中，如果是类变量，在连接的准备阶段会赋类型的零值(暂不讨论static final修饰的变量，后续会和const一起讨论)，类初始化的时候会赋上声明的初始值；如果是类的普通变量，在本站内的文章Java虚拟机之对象探秘有介绍，new等编译成的指令为普通字段赋上该类型的零值，但初始化器会在每个构造方法中被执行，而且是在显式写进构造方法内的内容执行前执行；如果是方法内的局部变量，必须手动赋值，否则不能使用； Go和Java不同的是，Go不存在未初始化的变量，也就是前面提到的，它具有零值机制保障； Go和Java不同的是，在函数中存在短变量声明，用来声明和初始化局部变量； :=表示声明，=表示赋值，但是如果:=左边存在多变量，并不要求全部声明这些变量(但也要保证声明的变量至少有一个)，对其中已经声明过的变量来说，:=相当于=，例如： 123456func main() &#123; var i int a, i := 1, 4 fmt.Println(i) fmt.Println(a)&#125; i在a声明之前已然声明过，所以在执行a, i := 1, 4时，i相当于赋值为4，而非再次声明； 指针与Java不同的是，Go语言存在指针，指针的值是变量的地址，并非所有的值都有地址，但所有变量都有地址； 借用书中的例子： 12345x := 1p := &amp;x // p是整型指针，只想xfmt.Println(*p) // "1"*p = 2 // 等于 x = 2fmt.Println(x) // 结果 "2" Go语言的指针形式上类似C指针，但是却也存在明显区别：Go指针可以比较，但是不能运算； 书中提到“每次使用变量的地址或者复制一个指针，我们就创建了新的别名或者方式来标记同一变量”。所以在本人看来，Go指针形式上和C指针相近，但是行为上更像Java的引用； 地址符加上变量名构成的表达式不能被赋值： 123456789func main() &#123; var i int var ii *int a, i := 1, 4 ii = &amp;i &amp;a = ii // 出错 fmt.Println(i) fmt.Println(a)&#125; 这段代码通过了GoLand的语法检查，但build会出现cannot assign to &amp;a的错误； new函数和Java不同的是，Go可以采用new函数创建未命名的某个类型的变量，受零值机制保障，返回其地址，使用new创建变量和一般方法创建相比没有什么不同，只是语法上看似便利罢了； 变量生存周期首先是变量指代的内存被回收的问题。 在Java中，一切都是对象，垃圾回收与否取决于对象是否是根对象，根对象大体上来说包含以下几种： 虚拟机栈（栈帧中的本地变量表）中的引用的对象； 方法区中的类静态属性引用的对象； 方法区中的常量引用的对象； 本地方法栈中JNI引用的对象； Go与Java不同的是，它没有对象的概念，但判断变量是否要被垃圾回收器回收的方式和Java一样，皆不是采用的引用计数，具体来说是一种Mark Sweep。包级别的变量，以及每个当前执行函数的局部变量，类似Java中的所谓根对象，可以理解为是“根变量”； Java所谓的闭包，采用的是capture-by-value，而非capture-by-reference，具体做法是在内部类或者Lambda表达式里将引用的外部变量的值拷贝一份，所以为了引用一致以及线程安全，外部变量会被设定为final，或者如Java 8中那样，隐式设定为final； Go是capture-by-reference的，下面给出一个例子： 12345678910111213141516func add() func() uint&#123; i := uint(0) return func() (ret uint) &#123; ret = i i += 2 return &#125;&#125;func main() &#123; add0 := add() fmt.Println(add0()) fmt.Println(add0()) fmt.Println(add0())&#125; 输出为： 123024 i是add()的局部变量，但是它从add中逃逸出来，所以是在堆空间分配的内存，add返回的匿名函数会获取i的地址，并在方法体内进行赋值与运算； 赋值HotSpot虚拟机采用的是直接指针访问，不同变量传递的是字符串对象的地址； Go语言采用的是值传递，例子见下： 12345678func printAddr() &#123; x := "Hello" fmt.Println(&amp;x) y := x fmt.Println(&amp;y) x = y fmt.Println(&amp;x)&#125; 输出为： 1230xc42007a1d00xc42007a1e00xc42007a1d0 Go打印的是变量的地址，传递的是变量内承载的值，接下来看看这里的值，指的是什么。 扩展前面的例子，添加代码： 12345678lenx := unsafe.Sizeof(x)fmt.Println(lenx)p01 := (* uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;x))))fmt.Println(*p01)p02 := (* uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;y))))fmt.Println(*p02)plen := (* uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;x)) + 8))fmt.Println(*plen) 打印为： 12341617558375175583755 可以看出，x变量的大小为16个单位(字节)，正好是&amp;x和&amp;y值的差，从两个变量的起始地址开始计算32位的值，结果都是17558375，说明它们都引用了同一地址的数据；从x变量的起始位置开始，计算出偏移量为8的字节表示的值为5，正好是“Hello”字符串的长度。 所以一个字符串变量承载的信息包括了字符串数据和字符串长度，用一个图简单表示： 和Java相同的是，Go的字符串也是不可变的。虽然Go采用的是所谓的值传递，但是不同的变量共用同一段底层数据，所以变量间的赋值开销都很低廉。 多重赋值和Java不同的是，Go可以多重赋值，例如交换两个变量的值可以用很简单的形式表达： 1x, y = y, x 多重赋值常常搭配函数的多重返回，但有时候返回的值并非都是需要的，不需要的值可以赋给空标识符： 1_, ok = method() 可赋值性Java和Go在很多地方都是隐式赋值，比如函数隐式的将参数的值赋给对应参数的变量等； 但是Go和Java不同的地方在于，赋值语句是显示赋值，也就是类型必须精准匹配(赋值左右变量类型相同)，nil可以被赋给任何借口变量或引用类型； ==和!=首先需要满足可赋值性； 类型声明和Java不同的是，Go提供关键字type来声明定义一个新的命名类型，它和某个已有的类型使用同样的底层类型，但是它们并不兼容，也就是说它们不是同一类型，不满足前面提到的可赋值性； 如果两个类型具有相同的底层类型或二者都是指向相同底层类型变量的未命名指针类型，则二者是可以相互转换的； 包导入在Java中，包名和文件夹名是一样的，包下的每个Java文件内只存在一个public类，且类名和文件名必须相同； 和Java类似的是，在Go中一个文件夹下(不包括子文件夹)通常也只存在一个包，例外是如果存在测试文件，那么测试文件象征的代码属于测试相关包； 和Java不同的是，文件夹名和包名并不要求一定一致； 和Java不同的是，Go并不存在类的概念，Go文件名也不需要和代码中的相关模块名称一致； 在Go中，import的是具体的路径，但是在代码中，如果要引用其它包的成员，则需要用包名来调用； 通常存在这样的约定：导入路径的最后一段(也就是文件夹名)和包名相匹配，这样方便预测包名是什么； 不能导入没有被引用的包； 包初始化在Java中以下情形变量声明初始化的顺序是不能通过编译的： 12int a = b; // 错误处int b = 4; static块还存在一种非法的向前引用： 123456static &#123; a = 2; System.out.println(a); // 错误处&#125;static int a = 3; 和Java不同的是，Go变量通常是按照顺序从前往后初始化，但在某个变量的初始化需要依赖其它变量时，被依赖的变量先初始化； 和Java不同的是，Go存在一种默认的函数init，它的作用类似Java类初始化的static，或者Java对象初始化的构造器。 考虑这样一种情形，在同一个包下，不同的go文件包含各自的字段和init函数，首先是main.go： 1234567891011121314151617package mainimport "fmt"var bbb = ppr()func ppr() int &#123; fmt.Println("Hello bbb") return 77&#125;func init() &#123; fmt.Println("main")&#125;func main() &#123; fmt.Println(aa)&#125; 接下来是submain.go： 123456789101112131415package mainimport "fmt"var aa = 3var aaa = pr()func pr() int &#123; fmt.Println("Hello aaa") return 7&#125;func init() &#123; fmt.Println("Submain")&#125; 它们在同一个包里，执行打印的顺序如下： 12345Hello bbbHello aaamainSubmain3 由此可知： 字段的初始化先于init函数，包内所有的字段都初始化后，init函数才执行； 包内包含main函数的文件的打印语句先于未包含main函数的文件的打印语句执行，字段先于字段，init方法先于init方法； 但如果不在同一个包下，比如A文件import了B，那么B内的初始化先执行(包括init函数)，然后再进行A的初始化； 作用域Go和Java不同的是，在一个作用域内，如果变量未被使用，编译会报错： 123if f, err := os.Open(fname); err != nil &#123; // 编译错误：未使用f return err&#125; 参考Go程序设计语言 What is the difference between a virtual machine and any runtime environment? Golang闭包的实现 Go closure variable scope 如何获得java对象的内存地址]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速复习C语言语法(TCPL)]]></title>
    <url>%2F2018%2F10%2F20%2FReview_TCPL%2F</url>
    <content type="text"><![CDATA[一篇快速复习C语言语法的小文。 走马观花 C语言和Java语言一样，变量使用前需要先声明，但是由于Java特有的初始化机制，使得声明的语句并非一定要显式摆放在执行的方法之前，但C语言在调用函数之前需要显式声明。 1234567891011int a; // 声明字段avoid method01(); // 声明方法method01int main() &#123; method01(); printf("%d", a);&#125;void method01() &#123; printf("Hello!\n");&#125; int和float等类型的取值范围取决于机器。 #define在预编译阶段将符号名或者符号常量定义为特定的字符串，指令的末尾没有分号。 C语言的函数参数通过值传递。 自动变量对标Java中局部变量，每次entry函数时都需要显式为其赋值，如果没有，那么存放的将是“garbage”。 外部变量指的是函数外的变量，可以在函数内显式声明，即用“extern”关键字，也可以通过上下文隐式声明，即比如定义在使用函数之前就可以不使用“extern”关键字。 通常习惯把extern声明的变量和函数放在单独的一个文件中，该文件成为头文件。 类型、操作符和表达式 C中的const对标Java中的final，但是和Java又有区别，例如如果用const修饰数组，那么数组中的元素就不能改变了，而且在声明的同时就应该初始化赋值： 12345int main() &#123; const char i[] = "abc";// i[0] = 'c'; 这里修改值是错误的做法 printf("%s", i);&#125; 下划线在C中被看作是字母，但是通常不应以下划线开头来命名变量或函数，因为library routines常常使用这样的方式命名。 C的字符串和Java的相比，最后多了一个\0字符，程序是需要扫描整个字符串才能确定字符串的长度，该长度不包括\0字符。 取模运算符％不能作用于float活着double类型。 C没有指定char类型的变量是无符号还是带符号变量，这个由不同的机器决定。 全局变量 、静态变量初始值为0，局部变量，自动变量如果没有初始化值随机分配(“garbage”)。 函数 和Java不同，C中函数的定义中各个部分都可以省略，比如dumy() {}的书写是合法的，这种函数可以作为钩子函数在开发期间进行保留。 外部变量或函数的作用域和Java中的各种变量的相比并不相同，它是从声明的地方开始，在其所以在的文件的末尾结束。 静态变量只供所在源文件的函数使用，其他函数不能访问。 静态变量也可以存在于函数内，这和局部变量一样，但它不仅是该函数私有的，而且无论函数调用是否结束，它仍然占据内存空间。所以静态变量和外部变量相比，能让编码者更细腻地控制作用范围。 寄存器变量只适用于自动变量以及函数的形参。 寄存器变量的地址不能访问，且过量使用没有什么害处。 外部变量和静态变量在没有显式初始化的时候都被初始化为0，而自动变量和寄存器变量不会，它们的值是“garbage”。 指针和数组结构体结构体可以视为一种数据结构，它集合了一个或者多个变量，这些变量可以是不同类型的。 结构体的形式一般如下： 1struct [&lt;structuretag&gt;] &#123;&#125; structuretag是可选的，可以作为括号内声明部分的简写形式。 结构体声明在通过struct &lt;structuretag&gt; {...} &lt;var&gt;进行声明后，可以用struct &lt;structuretag&gt; &lt;var&gt;进行简化声明，例如： 123456struct s &#123; char number[3]; int age;&#125; ss;struct s dd; 结构体与函数给函数传入一个结构体参数很像Java中的引用传递，毕竟很多人可能将结构体类比为Java中的类或对象，但结构体依然是值传递，例如： 12345678910111213141516171819202122#include &lt;stdio.h&gt;struct s &#123; char number[3]; int age;&#125;;struct s dd;void changeStruct(struct s);int main() &#123; printf("age01: %d\n", dd.age); changeStruct(dd); printf("age02: %d\n", dd.age); return 0;&#125;void changeStruct(struct s a1) &#123; a1.age = 7;&#125; 打印为： 12age01: 0age02: 0 结构体会在函数内整个复制，如果该结构体很大，那么采用这种方式效率较低，好的方法是使用指针。 使用指针时首先要注意的是*的优先级低于.，所以*p.x和(*p).x是不一样的。 其次，指针的使用频率很高，所以可以采用一种简写方式p-&gt;x来代替前面(*p).x的写法。 结构体数组借助结构体，可以将多个长度相同的数组构成的集合，改写成数组相同索引下数据的集合(结构体)构成的数组。 初始化的格式： 1234struct arr &#123; char *word; int count;&#125; keytab[] = &#123;"aaa", 1, "bbb", 2&#125;; 如果要求结构体数组的长度，可以使用sizeof函数，它会返回无符号整型值，类型为size_t。 sizeof接结构体参数时，可以采用sizeof(struct )的形式。 预处理器不对类型名进行分析，但预处理器并不计算#define里的表达式，所以可以用#define搭配sizeof函数使用。 指向结构体指针这里要注意的是，指针的加法运算是非法的，而减法是合法的。 其次，C中的结构体内存在字节对齐现象，所以结构体的长度未必等于它成员长度只和。 再次，返回结构体指针的函数，可以用如下格式来书写： 12struct key *binsearch(char *word, struct key *tab, int n) typedeftypedef的功能一言以蔽之：“it merely adds a new name for some existing type”。 下面举一个最简单的typedef例子来说明： 1typedef int Len; 此时Len和int具有等同意涵。这里最好遵照一定的规范，即typedef定义的类型名首字母大写。 编写了一个函数如下： 123int method(int a, int b) &#123; return a + b;&#125; 现在假设需要声明一个变量，它的类型是指向函数的指针，该函数是这样一种函数：参数是(int, int)，返回值是int，该指针变量指向之前编写的method函数，所以有： 1int (*methodref02)(int, int) = method; 总是这样写相较麻烦，为这种类型创建一个新名称吧： 1typedef int (*methodref)(int, int); 此时之前的methodref02可以这样定义： 1methodref methodref02 = method; 联合体联合体开辟的内存，等于它所有成员中所占内存最大的成员的内存。读取的类型必须是最近一次存入的类型，初始化的时候使用第一个成员类型的值进行初始化，其它操作大体和结构体相同。 123456789int main() &#123; union u &#123; int val01; long val02; &#125; a = &#123;1&#125;; a.val01 = 7; a.val02 = 12; printf("%zu %i %li\n", sizeof(a), a.val01, a.val02);&#125; 打印结果： 18 12 12 位字段位字段一个主要的作用就是节约内存，在Java中boolean类型的变量在虚拟机占用了一个int的大小，也就是四个字节。实际上，原本一个bit就能完成同样功能。Java这样做当然有它自己的实现机理，而在C语言中，为了节约内存采用了一种新的手段，即位字段。来看一个例子： 12345678910111213141516int main() &#123; struct Bitfield &#123; unsigned int a : 1; unsigned int b : 2; unsigned int c : 20; &#125; bf; bf.a = 1; bf.b = 2; bf.c = 503432; int testBitfield = 3; printf("%d\n", testBitfield &amp; (bf.b | bf.a)); printf("%d\n", bf.c); printf("unsigned int字节数：%zu\n", sizeof(bf));&#125; 运行结果： 1233503432unsigned int字节数：4 a占了一比特，b占了2比特，c占了20比特，如果单独声明，它们可能会占用更多的内存，但是现在仅仅一个unsigned int大小的内存就能搞定，也就是4字节。 小结以上就是本人针对Java和C的语法区别做的一个记录，旨在复习C语法。 参考The C Programming Language]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>持续更新</tag>
        <tag>review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python元类、monkey patch以及类装饰器]]></title>
    <url>%2F2018%2F10%2F19%2FPython_Metaclass%2F</url>
    <content type="text"><![CDATA[本篇简单记录一些关于Python如何利用元类、monkey patch以及类装饰器来动态修改类的知识。 Python元类基本观点这些观点主要来自What are metaclasses in Python?： type是Python的内建元类； __metaclass__实际上可以被任意调用，它并不需要是一个正式的类； 当使用class关键字时，Python解释器自动创建类对象； 如果不希望自动创建，可以采用type，type能动态的创建类。它接受类的描述作为参数，然后返回一个类； 创建类会经历的查找过程：编写的类中查找有__metaclass__，没有就继续在父类找，没有就在模块层次找，最终都没找到，就用内置的type创建类对象； __metaclass__可以放置type，或者任何使用到type或者子类化type的东东都可以； 元类的主要目的就是为了创建类时能够自动地改变类，具体实现为：（1）拦截类的创建，（2）修改类，（3）返回修改后的类； __new 是在init__之前被调用的特殊方法； __new__是用来创建对象并返回之的方法； \而init只是用来将传入的参数初始化给对象； type.__new__创建type对象并返回； 代码实践type创建类对象的基本格式：type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）) 下面是一个元编程的例子： 12345678910111213141516171819202122232425262728&gt;&gt;&gt; def upper_attr(future_class_name, future_class_parents, future_class_attr):... attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))... uppercase_attr = dict((name.upper(), value) for name, value in attrs)... return type(future_class_name, future_class_parents, uppercase_attr)...&gt;&gt;&gt; class Foo(object):... bar = 'bip'... __metaclass__ = upper_attr... chen = 'cg'...&gt;&gt;&gt; f = Fool()Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'Fool' is not defined&gt;&gt;&gt; f = Foo()&gt;&gt;&gt; print f.chenTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Foo' object has no attribute 'chen'&gt;&gt;&gt; print f.CHENcg&gt;&gt;&gt; print f.barTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Foo' object has no attribute 'bar'&gt;&gt;&gt; print f.BARbip&gt;&gt;&gt; __metaclass__所处的位置不影响构建类对象； monkey patchmonkey patch：概念上类似于Java里面的热修复，主要作用是在不更改源代码的情况下，动态追加和变更类的功能； 一个简单的例子： 12345678910111213&gt;&gt;&gt; class Moneky(object):... def eat(self):... print "i want to eat banana"...&gt;&gt;&gt; m = Moneky()&gt;&gt;&gt; m.eat()i want to eat banana&gt;&gt;&gt; def common_eat(self):... print "sorry"...&gt;&gt;&gt; Moneky.eat = common_eat&gt;&gt;&gt; m.eat()sorry eat方法在运行时成功替换成common_eat方法。 类装饰器首先明确functools包下的wraps，它可以使函数在调用name和doc属性时，打印被装饰的函数的信息，而非装饰函数的信息。 写一个类装饰器的例子，下面是写法一： 1234567891011121314151617181920212223# 写法一from functools import wrapsclass A(): def route(self, func): @wraps(func) def wrapper(*arg, **args): self.printA() return func(*arg, **args) return wrapper def printA(self): print "hello"app = A()@app.route # 不写括号传参def hello(): '''hellodoc''' print "I am hello"if __name__ == '__main__': hello() print(hello.__doc__) route参数只有一个且就是被装饰的函数时(这里指不包含self)，可以直接不写括号； 在看另一种写法： 123456789101112131415161718192021# 写法二class A(): def route(self, str): def wrapper(func): self.printA() return func # 返回的不再是函数求得的值，而是函数对象 return wrapper def printA(self): print "hello"app = A()@app.route("/")def hello(): '''hellodoc''' print "I am hello"if __name__ == '__main__': hello() print(hello.__doc__) 这里的route设定的是要传入一个str参数，在书写装饰器时显式给出，在构造装饰器逻辑的时候，嵌套的方法wrapper被返回的是func函数对象而不是函数运算求得的值，所以只是函数的引用改变了，那么打印函数的doc仍是原函数的内容； 类装饰器有一个好处是装饰的逻辑可以通过类继承，这样能方便程序的扩展； 参考What are metaclasses in Python? What is monkey patching? 深刻理解Python中的元类(metaclass)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python元类</tag>
        <tag>monkey patch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈阻塞(3)：cxq、EntryList与WaitSet]]></title>
    <url>%2F2018%2F10%2F17%2FBlocked03%2F</url>
    <content type="text"><![CDATA[通过上一篇的分析，我们知道当一个线程尝试获取monitor锁失败后，最终会被封装成一个ObjectWaiter对象，放入一个以_cxq为头节点的队列中，这个队列通过一个简单链表实现。每当有新来的节点入队，它的next指针总是指向之前队列的头节点，而_cxq指针会指向该新入队的节点，这就是后来者当头。实际上synchronized锁机制内维护了三个队列，除了cxq，还包括EntryList与WaitSet，本篇将以此为研究对象，弄清内置锁队列的运作机制。 并发示例这里提供一个新的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142public class SynchronizedDemo02 &#123; public static void main(String[] args) throws InterruptedException &#123; byte[] lock = new byte[0]; Runnable task01 = () -&gt; &#123; synchronized (lock) &#123; System.out.println(Thread.currentThread().getName() + ": begin"); try &#123; Thread.sleep(3000); lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + ": finish"); &#125; &#125;; Runnable taskOpen = () -&gt; &#123; synchronized (lock) &#123; System.out.println(Thread.currentThread().getName() + ": begin"); lock.notify(); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + ": finish"); &#125; &#125;; Thread t1 = new Thread(task01, "t1"); Thread t2 = new Thread(taskOpen, "t2"); Thread t3 = new Thread(taskOpen, "t3"); t1.start(); Thread.sleep(1000); t2.start(); Thread.sleep(2000); // 设置不同的睡眠时间，可能会产生不同的打印效果； System.out.println("t1: " + t1.getState()); t3.start(); &#125;&#125; 本示例包括三个线程和两个任务，线程t1先开启并获得锁，t2、t3后续开启。t1睡眠三秒后挂起，t2拿到锁，执行过程中调用notify，并睡眠三秒。先看看输出是怎样的： 1234567t1: begint2: begint1: WAITINGt2: finisht1: finisht3: begint3: finish 观察这个输出结果可以发现两个表象： 表象1： t1: finish出现在t2: finish后，哪怕t2调用notify方法后三秒才执行t2: finish的打印语句； 表象2： t3在t1后拿到锁； 现在将源代码稍稍更改一下，把带有注释的语句Thread.sleep(2000);更改为Thread.sleep(1500);，再次运行，输出变更为： 1234567t1: begint1: TIMED_WAITINGt3: begint3: finisht2: begint2: finisht1: finish 从输出结果可以看出： 表象3：t3的打印出现在t2的打印之前； 表象4：t1: finish在最后打印； 仅仅将代码稍作改动就出现了不同的打印结果，下面将深入代码探寻其原因。 线程调用wait()进入WaitSet前一篇文章探索了一个线程从尝试获取重量级锁到失败的过程，线程随即进入到了cxq队列并将自己挂起。挂起的线程还可能存在于WaitSet中，t1是通过调用lock.wait();来实现的。在objectMonitor.cpp下，查看void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS)函数，一开始有： 1234ObjectWaiter node(Self);node.TState = ObjectWaiter::TS_WAIT ;Self-&gt;_ParkEvent-&gt;reset() ;OrderAccess::fence(); 底层的wait函数仍然是先将当前线程封装成一个ObjectWaiter，设置其TState状态为TS_WAIT，接下里执行最重要的入队代码： 123Thread::SpinAcquire (&amp;_WaitSetLock, "WaitSet - add") ;AddWaiter (&amp;node) ;Thread::SpinRelease (&amp;_WaitSetLock) ; 这段代码的背景注释给出了很清晰的介绍： WaitSet是一个双向环形链表实现的等待队列，但它可以是优先级队列或任何数据结构； _WaitSetLock用来保护该等待队列。通常只有monitor owner能访问等待队列，除非有一个超时中断将其唤醒； 竞争并不激烈，所以我们使用简单的旋转锁而不是更重的阻塞锁来保障同步； 继续追踪AddWaiter： 12345678910111213141516171819inline void ObjectMonitor::AddWaiter(ObjectWaiter* node) &#123; assert(node != NULL, "should not dequeue NULL node"); assert(node-&gt;_prev == NULL, "node already in list"); assert(node-&gt;_next == NULL, "node already in list"); // put node at end of queue (circular doubly linked list) if (_WaitSet == NULL) &#123; _WaitSet = node; node-&gt;_prev = node; node-&gt;_next = node; &#125; else &#123; ObjectWaiter* head = _WaitSet ; ObjectWaiter* tail = head-&gt;_prev; assert(tail-&gt;_next == head, "invariant check"); tail-&gt;_next = node; head-&gt;_prev = node; node-&gt;_next = head; node-&gt;_prev = tail; &#125;&#125; 以上是将node入队一个双向环形链表末尾(这里的末尾参照物是head指针)的简单操作。 当一个线程调用了wait()后，不仅会挂起自己，还会释放锁，涉及到如下代码： 1234567 ...exit (true, Self) ; // exit the monitorguarantee (_owner != Self, "invariant") ; ... exit()的解析后续会展开。 顺便也将出队操作列出： 12345678inline ObjectWaiter* ObjectMonitor::DequeueWaiter() &#123; // dequeue the very first waiter ObjectWaiter* waiter = _WaitSet; if (waiter) &#123; DequeueSpecificWaiter(waiter); &#125; return waiter;&#125; 可见每次出队都是单个头节点，而非倾倒(drain)。DequeueSpecificWaiter函数完全从链表中删除了waiter节点，这里就不贴码了。 notify()的底层实现为了解释本文开篇列举的并发示例的输出现象，我们还需要先了解notify()的底层实现。这个底层实现通过objectMonitor.cpp下的void ObjectMonitor::notify(TRAPS)来完成。 浏览代码会发现，存在不同的策略可供选择，而int Policy = Knob_MoveNotifyee ;，查询相关字段有static int Knob_MoveNotifyee = 2;，所以默认为Policy = 2时的策略。这里仅为说明原理，所以暂时只分析默认策略，代码如下： 123456789101112131415161718192021222324ObjectWaiter * iterator = DequeueWaiter() ; ...ObjectWaiter * List = _EntryList ; ...if (Policy == 2) &#123; // prepend to cxq // prepend to cxq if (List == NULL) &#123; iterator-&gt;_next = iterator-&gt;_prev = NULL ; _EntryList = iterator ; &#125; else &#123; iterator-&gt;TState = ObjectWaiter::TS_CXQ ; for (;;) &#123; ObjectWaiter * Front = _cxq ; iterator-&gt;_next = Front ; if (Atomic::cmpxchg_ptr (iterator, &amp;_cxq, Front) == Front) &#123; break ; &#125; &#125; &#125;&#125; Policy == 2在这段代码中表达的策略： 如果EntryList是空队列，则iterator单个节点构成一个双向环形链表，然后_EntryList指向该节点； 如果EntryList不为空，通过CAS将iterator入队cxq，并将_cxq指针指向iterator； 现在可以解释表象1： 由于notify()在默认策略下只是将代表线程的节点由WaitSet转移到其它队列，并没有唤醒线程，所以即便调用了notify方法后继续执行三秒，线程t2也只有等待被唤醒后才能打印语句，所以t1: finish出现在t2: finish后。 那究竟什么时候才唤醒线程？ ObjectMonitor::exit函数解析在虚拟机层线程的唤醒是通过ObjectMonitor::ExitEpilog函数完成的，该函数同时还完成释放锁的操作。把核心代码抽离出来： 12345678910111213141516171819void ObjectMonitor::ExitEpilog (Thread * Self, ObjectWaiter * Wakee) &#123; // Exit protocol: // 1. ST _succ = wakee // 2. membar #loadstore|#storestore; // 2. ST _owner = NULL // 3. unpark(wakee) _succ = Knob_SuccEnabled ? Wakee-&gt;_thread : NULL ; ParkEvent * Trigger = Wakee-&gt;_event ; Wakee = NULL ; // 释放锁； OrderAccess::release_store_ptr (&amp;_owner, NULL) ; OrderAccess::fence() ; // 线程唤醒； Trigger-&gt;unpark() ;&#125; ExitEpilog又封装在ObjectMonitor::exit函数中，当Java虚拟机执行代表退出monitor锁的字节码指令时，会调用ObjectMonitor::exit函数。为了保证鲁棒性，该函数还会考虑轻量级锁的情况，轻量级锁在这里用一个BasicLock指针代表，会被当成重量级锁来处理，所以会有一些设定。 在这里本人重点关心的是各队列中节点的变化。实际上，在一个线程释放锁之后，关于如何唤醒后继线程，Java虚拟机也提供了几种模式，前面分析notify采用的是默认策略，这里也只单讲默认模式，代码中的设定是int QMode = Knob_QMode ;，查询相关字段有static int Knob_QMode = 0 ;，所以默认模式是QMode == 0;，抽离出关键代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void ObjectMonitor::exit(bool not_suspended, TRAPS) &#123; ... for(;;) &#123; ObjectWaiter * w = NULL ; w = _EntryList ; if (w != NULL) &#123; assert (w-&gt;TState == ObjectWaiter::TS_ENTER, "invariant") ; ExitEpilog (Self, w) ; return ; &#125; w = _cxq ; if (w == NULL) continue ; for (;;) &#123; assert (w != NULL, "Invariant") ; ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL, &amp;_cxq, w) ; if (u == w) break ; w = u ; &#125; assert (w != NULL , "invariant") ; assert (_EntryList == NULL , "invariant") ; // 抽离出来的QMode == 0 or QMode == 2情况下代码； _EntryList = w ; ObjectWaiter * q = NULL ; ObjectWaiter * p ; // 将单向链表构造成双向环形链表； for (p = w ; p != NULL ; p = p-&gt;_next) &#123; guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, "Invariant") ; p-&gt;TState = ObjectWaiter::TS_ENTER ; p-&gt;_prev = q ; q = p ; &#125; // _succ表示已经存在唤醒的线程； if (_succ != NULL) continue; w = _EntryList ; if (w != NULL) &#123; guarantee (w-&gt;TState == ObjectWaiter::TS_ENTER, "invariant") ; ExitEpilog (Self, w) ; return ; &#125; &#125; ...&#125; 这段代码的含义： 若EntryList队列的头节点_EntryList不为null，那么直接唤醒该头节点封装的线程，然后返回； 1的条件不满足，程序继续向下执行，若cxq队列的头节点_cxq为null，则跳过当次循环； 若程序继续向下执行说明cxq队列不为空，EntryList队列为空。接下来是一个内嵌的for循环，目的是取出cxq队列中的所有元素，方法是通过一个临时变量指针获得构成队列的整个链表，然后将_cxq指针置为NULL； 第二个内嵌for循环是QMode == 0策略的内容，目的在于将第三步得到的单向链表倾倒(drain)进EntryList队列，具体方法是将_EntryList指针指向单向链表的头节点，然后通过for循环将单向链表构造成双向环形链表； 通过ExitEpilog函数释放monitor锁并唤醒EntryList队列的头节点； 解释开篇并发示例输出表象首先解释未改动之前的代码输出结果。 表象1已经在之前解析notify方法的时候解释过了，notify并不唤醒线程； 接着解释表象2(即：t3在t1后拿到锁)： 首先要了解t3启动的时机，当t3启动，此时的t1已经睡眠了1+2秒(这里是近似值，实际上线程启动挂起会有时间消耗，后文出现时间常量亦是近似处理)，并通过调用wait()将自己挂起在WaitSet并释放锁； 而t2已经被挂起多时，它之前在cxq队列中，t3释放锁后它被drain入EntryList队列，并被ExitEpilog函数唤醒； t2运行3秒后释放锁，现在的情况是，t3在cxq中，t1在WaitSet中，而EntryList此时为空，根据notify()的默认策略，处于WaitSet中封装了t1线程的节点会从WaitSet出队，转而进入EntryList，构成一个双向环形链表； 根据exit()的默认模式，EntryList队列的头节点_EntryList不为null，直接唤醒该头节点封装的线程t1，所以t3在t2后拿到锁； 接下来解释表象3和表象4，这里再将它们列出方便查看： 表象3：t3的打印出现在t2的打印之前； 表象4：t1: finish在最后打印； 首先解释表象3： 改动代码后，t3启动时，t1已经sleep()了2.5秒，还处在TIMED_WAITING状态，t3在尝试获取锁失败后会和t2一样，进入cxq，但由于cxq特殊的入队规则，t3后来者当头，构成t3 -&gt; t2的单链表形式； t1调用wait()后将自己挂起，并调用exit()，此时EntryList为空而cxq不为空，cxq中的链表整条drain入EntryList，并通过for循环将其构成双向环形链表； 通过ExitEpilog函数释放monitor锁并唤醒EntryList队列的头节点，也就是t3了，所以t3的打印在t2之前； 承接前面的内容，再来解释表象4： t3调用notify()，此时t2处在EntryList，所以按照notify默认策略，EntryList不为空，通过CAS将t1入队cxq，并将_cxq指针指向t1； 当t3执行exit()，t1处在cxq，t2处在EntryList，按照策略，t2先行执行，所以t1的finish打印出现在最后； 小结本篇通过对源码进行分析，解释了开篇运行示例后出现的四个表象。经此一役，本人对内置锁队列的运作机制有了一个比较清晰的认识。 参考ObjectMonitor日文源码注释]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[套接字复习笔记]]></title>
    <url>%2F2018%2F10%2F16%2FSocket%2F</url>
    <content type="text"><![CDATA[本篇是对《深入理解计算机系统(原书第三版3)》第十一章网络编程关于套接字的内容的复习笔记。 基本概念一个套接字是连接的一个端点； 每个套接字都有相应的套接字地址：因特网地址 + 一个16位的整数端口组成(格式为地址：端口)； 客户端套接字地址中端口通常由内核自动分配，称为临时端口；服务器套接字地址中的端口通常为知名端口； /etc/services 包含一张本机器提供的知名名字和知名端口之间的映射； 一个连接由套接字对唯一确定； 套接字接口是一组函数，它们和Unix函数结合起来，用以创造网络应用； AF_INET：IPv4 网络协议的套接字类型； 为什么会出现sockaddr_in和sockaddr？书中给了一个解释是方便定义connect、bind、accept这些函数，使它们能接受各种类型的套接字地址结构； socket连接机制 socket函数： 客户端和服务器使用socket函数来创建一个套接字描述符： 1clientfd = Socket(AF_INET, SOCK_STREAM, 0); SOCK_STREAM表示这个套接字是连接的一个端点； connect函数： 客户端通过调用connect函数来建立和服务器的连接： 1int connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen); 其中sockaddr是服务器的套接字地址，addrlen是sizeof(sockaddr_in)； 如果连接成功，clientfd描述符就“打开”，准备好可以读写了； bind函数： 1int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 将addr中的服务器套接字地址和套接字描述符sockfd联系起来； listen函数： 123#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog); listen将sockfd从一个主动套接字转化为一个监听套接字，然后接受来自客户端的连接请求； backlog参数暗示了内核在开始拒绝连接请求之前，队列中要排队完成的连接请求数量，通常设置为一个较大值，比如1024； accept函数： 123#include &lt;sys/socket.h&gt;int accept(int listenfd, struct sockaddr *addr, int *addrlen); accept函数等待来自客户端的连接请求到达监听描述符listenfd，然后在addr中填写客户端的套接字地址，并返回一个已连接描述符； getaddrinfo函数： 将主机名、主机地址、服务名和端口号的字符串转化成套接字地址结构； getnameinfo函数： getnameinfo函数和getaddrinfo是相反的，将一个套接字地址结构转换成相应的主机和服务名字符串； getaddrinfo和getnameinfo可以用来为一些函数自动生成并提供参数； 套接字的连接机制可以大致用一张图来表示： Java编写socket接下来用Java编写一个简单的socket程序。 首先是客户端： 1234567891011121314151617public class Client &#123; public static void main(String[] args) &#123; String host = "127.0.0.1"; int port = 8091; try &#123; Socket client = new Socket(host, port); OutputStream out = client.getOutputStream(); out.write("你好".getBytes("GBK")); out.flush(); out.close(); client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在这段代码中并没有connect()，当然，即便有，它也并不是前文中那个connect()，从这点就能看出Java对底层代码进行了封装，如果要模拟底层的构造但不连接形式，可以将Socket client = new Socket(host, port);替换成： 123Socket client = new Socket();SocketAddress address = new InetSocketAddress("127.0.0.1", 8091);client.connect(address); 接下来再写一个简单的服务器端： 1234567891011121314151617181920public class Server &#123; public static void main(String[] args) &#123; int port = 8091; try &#123; ServerSocket server = new ServerSocket(port); Socket socket = server.accept(); InputStream input = socket.getInputStream(); byte[] b = new byte[2]; int i = 0; while ((i = input.read(b)) != -1) &#123; String str = new String(b, "GBK"); System.out.print(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ServerSocket将底层的函数封装起来，提供简便的api，运行服务器端，然后执行客户端，服务器端打印出”你好”； 小结本篇算是对套接字进行了一个简单的复习，了解了套接字的连接机制。 参考《深入理解计算机系统（原书第3版）》 问题客户端需要将套接字描述符和客户端套接字地址联系起来吗？？ listenfd是怎么产生的？]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Socket</tag>
        <tag>套接字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin之Get和Set]]></title>
    <url>%2F2018%2F10%2F15%2FKotlin01%2F</url>
    <content type="text"><![CDATA[Kotlin中存在默认添加get或set方法的语法，这点和Java有很大的区别，本篇将反编译字节码来解析其中的奥义。 开胃菜首先看一个例子： 123456class KotlinNew &#123; private val a :Int get() = 3 var isEm: Boolean = true get() = true&#125; 配合IDE，通过局部调整这个例子中的代码至少可以揭示以下几点： val字段如果有get()语句，可以不用首先初始化，当然既没有get也没有初始化也不行； 而var字段必须初始化，即便有get()语句也不行； 因为var和val的区别，所以var有get()和set()，但是val()只有get()； 通过这个例子可以了解一些基本概念，也能快速进入读代码状态。 编译示例并解析给出一个示例： 12345678910111213141516class KotlinGetAndSet01 &#123; var a: Int = 1 var b: Int = 2 get() = field set(value) &#123; if (value &gt;= 0) field = value &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; var k = KotlinGetAndSet01(); k.a&#125; 编译后产生两个文件，反编译其中的KotlinGetAndSet01.class有： 1234567891011121314151617181920212223242526272829303132333435363738394041public final class kotlindemo01.KotlinGetAndSet01 &#123; public final int getA(); Code: 0: aload_0 1: getfield #10 // Field a:I 4: ireturn public final void setA(int); Code: 0: aload_0 1: iload_1 2: putfield #10 // Field a:I 5: return public final int getB(); Code: 0: aload_0 1: getfield #19 // Field b:I 4: ireturn public final void setB(int); Code: 0: iload_1 1: iflt 9 4: aload_0 5: iload_1 6: putfield #19 // Field b:I 9: return public kotlindemo01.KotlinGetAndSet01(); Code: 0: aload_0 1: invokespecial #25 // Method java/lang/Object."&lt;init&gt;":()V 4: aload_0 5: iconst_1 6: putfield #10 // Field a:I 9: aload_0 10: iconst_2 11: putfield #19 // Field b:I 14: return&#125; 反编译KotlinGetAndSet01Kt.class有： 123456789101112131415public final class kotlindemo01.KotlinGetAndSet01Kt &#123; public static final void main(java.lang.String[]); Code: 0: aload_0 1: ldc #9 // String args 3: invokestatic #15 // Method kotlin/jvm/internal/Intrinsics.checkParameterIsNotNull:(Ljava/lang/Object;Ljava/lang/String;)V 6: new #17 // class kotlindemo01/KotlinGetAndSet01 9: dup 10: invokespecial #21 // Method kotlindemo01/KotlinGetAndSet01."&lt;init&gt;":()V 13: astore_1 14: aload_1 15: invokevirtual #25 // Method kotlindemo01/KotlinGetAndSet01.getA:()I 18: pop 19: return&#125; 乍一看可以得到这几个结论： 无论类中的字段有没有显式给出get()或set()，编译后都会产生get和set方法； main函数中调用对象的字段实际上是调用方法，且属于动态分派； 代码中显式给出get()或set()会覆盖默认方法； 在get、set方法中都包含getfield或者putfield，这两个字节码指令处理的都是对象的字段，这里以putfield为例来说明； 在setA方法中，aload_0将this压入操作数栈，iload_1将传入的参数压入操作数栈，putfield会将这两个数据都弹出，然后根据它接收的操作数，来给this代表的对象中的相关字段赋值； 小结本篇只是从源码解析的角度来了解Kotlin中的get和set，并没从设计的角度。默认的时候访问对象的字段，实际上已经调用了该字段的get或set方法，而Java是需要手动添加的，当需要更改逻辑的时候，可以显式更改get或set内的代码。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FL Studio 12.0.2 Mac版本开箱指南]]></title>
    <url>%2F2018%2F10%2F15%2FFL_Studio_12_Mac%2F</url>
    <content type="text"><![CDATA[Image-Line正式开发原生非移植版FL Studio for Mac三年多，期间Cakewalk就放弃了把SONAR移植到Mac，可见任务的艰难，最终在上半年，FL Studio 20 for Mac正式版终于推出，实在可喜可贺，特别是对中国的玩家，毕竟国内拥有大量的水果用户。但本篇将开箱的是一款FL Studio在Mac平台上的移植版本，供折腾、学习和研究所用。 还要说明的是，这也不是指官方推出的FL Studio 12 Native OS X ALPHA那个测试版本，而是Crossover Wrap版本，使用了CodeWeavers公司的一种叫做CrossOver的技术（这项技术是基于Wine），可以让原生Windows程序在Mac上运行。 初体验解压后直接移动到应用程序文件夹中，单击图标后就能运行软件。 注册时点开左上角的选项（如上图），然后选择FLRegKey.reg文件，注册成功。 播放演示工程歌曲，非常流畅，不得不说这是一次相当满意的体验。 设置&amp;安装插件要想真正制作点什么，加载第三方插件是最基本的要求。如果是要加载Nexus 2等软音源，常常会出现“cannot import isskin.dll”之类的错误。解决方法如下： 下载Vs6sp6.exe：点击下载链接 解压Vs6sp6.exe文件 在解压得到的Vs6sp6文件夹中解压vcredist.exe文件 在解压得到的vcredist文件夹中找到mfc42.dll, msvcrt.dll, msvcp60.dll三个dll文件 把找到的三个dll文件放在/Users/yourname/Library/Application Support/FL Studio/Bottles/flstudio/drive_c/windows路径下 这里安装的插件也是Windows版本而不是苹果系统的版本，所以安装文件都是exe格式，要运行exe文件可以点击文件-&gt;打开： 安装完成后就能正常打开插件了： 遇到的问题目前遇到的问题还是在安装某些插件上，主要反映为以下两个： 安装Sylenth1 v3以前的版本，发不出声音，这个问题应该是插件本身所致，因为Sylenth1的官网已经发布消息称新的版本已经解决了在Crossover中运行的问题。 另一个是安装相当一部分插件的时候会出现Runtime Error(at -1:0)错误，具体描述是：Cannot Import dll:&lt;UTF8&gt;C:\users\crossover\Temple\is-CA80N.tmp\ISSKINU.DLL.如下图： 小结通过上述折腾，可以很轻松的得出此版本存在兼容问题的结论，但程序的运行还算稳定，甚至可以完成基本的单曲创作。]]></content>
      <categories>
        <category>DAW</category>
      </categories>
      <tags>
        <tag>FL Studio</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈阻塞(2)：获取重量级锁从尝试到失败]]></title>
    <url>%2F2018%2F10%2F14%2FBlocked02%2F</url>
    <content type="text"><![CDATA[本篇将从源码角度，了解竞争重量级锁失败的过程，解释了为什么t2启动后，立马调用getState方法，会显示处于RUNNABLE状态，也说明了在Java线程中的Blocked状态并非是完全挂起状态，入队_cxq前后都可能进行TryLock()和自旋。 竞争重量级锁之前稍微熟悉synchronized就会知道，Java编译器在编译带有该关键字的代码块后，会插入monitorenter以及monitorexit指令到字节码中，monitorenter也就是进入内置锁机制的入口，看看虚拟机内部的部分实现： 12345678910111213141516 ...// traditional lightweight lockingif (!success) &#123; markOop displaced = lockee-&gt;mark()-&gt;set_unlocked(); entry-&gt;lock()-&gt;set_displaced_header(displaced); bool call_vm = UseHeavyMonitors; if (call_vm || Atomic::cmpxchg_ptr(entry, lockee-&gt;mark_addr(), displaced) != displaced) &#123; // Is it simple recursive case? if (!call_vm &amp;&amp; THREAD-&gt;is_lock_owned((address) displaced-&gt;clear_lock_bits())) &#123; entry-&gt;lock()-&gt;set_displaced_header(NULL); &#125; else &#123; CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception); &#125; &#125;&#125; ... 为了聚焦问题，所以上一篇已经强调过本系列主要研究的对象是重量级锁，获取轻量级锁失败后会去调用InterpreterRuntime::monitorenter方法，继续追踪有： 1234567891011121314151617181920212223//%note monitor_1IRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))#ifdef ASSERT thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);#endif if (PrintBiasedLockingStatistics) &#123; Atomic::inc(BiasedLocking::slow_path_entry_count_addr()); &#125; Handle h_obj(thread, elem-&gt;obj()); assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()), "must be NULL or an object"); if (UseBiasedLocking) &#123; // Retry fast entry if bias is revoked to avoid unnecessary inflation ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), true, CHECK); &#125; else &#123; ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK); &#125; assert(Universe::heap()-&gt;is_in_reserved_or_null(elem-&gt;obj()), "must be NULL or an object");#ifdef ASSERT thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);#endifIRT_END fast_enter方法的作用注释已经充分的说明： Retry fast entry if bias is revoked to avoid unnecessary inflation 所以主要看slow_enter方法，毕竟本人关注的是获取重量级锁的机制： 123456789101112131415161718192021222324252627282930313233343536void ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) &#123; markOop mark = obj-&gt;mark(); assert(!mark-&gt;has_bias_pattern(), "should not see bias pattern here"); if (mark-&gt;is_neutral()) &#123; // Anticipate successful CAS -- the ST of the displaced mark must // be visible &lt;= the ST performed by the CAS. lock-&gt;set_displaced_header(mark); if (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()-&gt;mark_addr(), mark)) &#123; TEVENT (slow_enter: release stacklock) ; return ; &#125; // Fall through to inflate() ... &#125; else if (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) &#123; assert(lock != mark-&gt;locker(), "must not re-lock the same lock"); assert(lock != (BasicLock*)obj-&gt;mark(), "don't relock with same BasicLock"); lock-&gt;set_displaced_header(NULL); return; &#125;#if 0 // The following optimization isn't particularly useful. if (mark-&gt;has_monitor() &amp;&amp; mark-&gt;monitor()-&gt;is_entered(THREAD)) &#123; lock-&gt;set_displaced_header (NULL) ; return ; &#125;#endif // The object header will never be displaced to this lock, // so it does not matter what the value is, except that it // must be non-zero to avoid looking like a re-entrant lock, // and must not look locked either. lock-&gt;set_displaced_header(markOopDesc::unused_mark()); ObjectSynchronizer::inflate(THREAD, obj())-&gt;enter(THREAD);&#125; 可见在正式竞争重量级锁之前，还会有一个锁膨胀的过程，当调用enter方法后，就正式开始竞争重量级锁了。 本小节跳过了无锁、偏向锁、轻量级锁以及锁膨胀的实现，但在追踪代码的过程中，对竞争重量级锁之前的流程有了大致的了解。 t2的失败之旅延用前篇最后列举的例子，看看t2是如何获取锁未遂的。 ObjectMonitor::enter()ObjectMonitor::enter()可以说是真正开始竞争重量级锁的入口，当t2启动后尝试去拿锁，此时t1持有锁并处在操作系统的IO阻塞状态，这是一个竞争重量级锁的过程(在此之前会通过一系列判断后膨胀锁)，ObjectMonitor::enter一开始进行是否重入的检查： 1234567891011121314151617Thread * const Self = THREAD ;void * cur ;cur = Atomic::cmpxchg_ptr (Self, &amp;_owner, NULL) ;if (cur == NULL) &#123; // Either ASSERT _recursions == 0 or explicitly set _recursions = 0. assert (_recursions == 0 , "invariant") ; assert (_owner == Self, "invariant") ; // CONSIDER: set or assert OwnerIsThread == 1 return ;&#125;if (cur == Self) &#123; // TODO-FIXME: check for integer overflow! BUGID 6557169. _recursions ++ ; return ;&#125; cmpxchg_ptr (Self, &amp;_owner, NULL)的规则： &amp;_owner和NULL相等，则将Self指向的内容赋给&amp;_owner，返回NULL； &amp;_owner和NULL不相等，则返回_owner； 第一个if语句用来处理CAS返回NULL的情形，此情形说明_owner指向的内容为空，没有线程持有锁，CAS将_owner指向当前线程，进行断言判断后直接返回； 第二个if语句用来处理其它的情形，&amp;_owner和NULL不相等会返回_owner，此时如果_owner == Self，说明线程重入，那么重入游标_recursions将自增。 接下来的代码涉及到之前锁膨胀的内容： 123456789if (Self-&gt;is_lock_owned ((address)cur)) &#123; assert (_recursions == 0, "internal state error"); _recursions = 1 ; // Commute owner from a thread-specific on-stack BasicLockObject address to // a full-fledged "Thread *". _owner = Self ; OwnerIsThread = 1 ; return ;&#125; 之前已经说明，竞争重量级锁之前的“故事”暂不深入。这里大致思想应该是轻量级锁膨胀为重量级锁后，若获得了轻量级锁又再次获得重量级锁，还是相当于锁重入了，所以_recursions设置为1，表示重入1次。 紧接着有： 12345678910111213141516171819// We've encountered genuine contention.assert (Self-&gt;_Stalled == 0, "invariant") ;// 设置线程的_Stalled字段，自旋模式下的一个设定；Self-&gt;_Stalled = intptr_t(this) ;// Try one round of spinning *before* enqueueing Self// and before going through the awkward and expensive state// transitions. The following spin is strictly optional ...// Note that if we acquire the monitor from an initial spin// we forgo posting JVMTI events and firing DTRACE probes.// 设置Knob_SpinEarly来进行优化，// 采用TrySpin方法自旋；if (Knob_SpinEarly &amp;&amp; TrySpin (Self) &gt; 0) &#123; assert (_owner == Self , "invariant") ; assert (_recursions == 0 , "invariant") ; assert (((oop)(object()))-&gt;mark() == markOopDesc::encode(this), "invariant") ; Self-&gt;_Stalled = 0 ; return ;&#125; 自旋拿锁失败，可用断言验证此时Java线程的状态不为blocked状态： 1assert (jt-&gt;thread_state() != _thread_blocked , "invariant") ; 所以t2启动后一开始处于runnable状态。 12// Change java thread status to indicate blocked on monitor enter. JavaThreadBlockedOnMonitorEnterState jtbmes(jt, this); 上面的代码将线程状态设置为blocked状态，此时没有拿到monitor锁，也没有在任何队列，不会突然的被JVMTI_EVENT_MONITOR_CONTENDED_ENTER事件unpark()。 后续会出现for循环： 123456789101112131415161718192021for (;;) &#123; jt-&gt;set_suspend_equivalent(); // cleared by handle_special_suspend_equivalent_condition() // or java_suspend_self() EnterI (THREAD) ; if (!ExitSuspendEquivalent(jt)) break ; // // We have acquired the contended monitor, but while we were // waiting another thread suspended us. We don't want to enter // the monitor while suspended because that would surprise the // thread that suspended us. // _recursions = 0 ; _succ = NULL ; exit (false, Self) ; jt-&gt;java_suspend_self();&#125; 这里先关注EnterI (THREAD)。 ObjectMonitor::EnterI()该方法是最终没有拿到锁的线程入队的关键方法，但在入队前后，还会不停尝试获取锁。 进入该方法首先会断言判断线程状态为_thread_blocked，所以进入该方法时的状态确定是blocked状态，接着还会TryLock()和一轮TrySpin()。在通过断言确定没有拿到锁之后，开始入队操作： 1234ObjectWaiter node(Self) ;Self-&gt;_ParkEvent-&gt;reset() ;node._prev = (ObjectWaiter *) 0xBAD ;node.TState = ObjectWaiter::TS_CXQ ; 可见，方法将线程包装成一个ObjectWaiter对象，继续下面的代码： 123456789101112131415161718// Push "Self" onto the front of the _cxq.// Once on cxq/EntryList, Self stays on-queue until it acquires the lock.// Note that spinning tends to reduce the rate at which threads// enqueue and dequeue on EntryList|cxq.ObjectWaiter * nxt ;for (;;) &#123; node._next = nxt = _cxq ; if (Atomic::cmpxchg_ptr (&amp;node, &amp;_cxq, nxt) == nxt) break ; // Interference - the CAS failed because _cxq changed. Just retry. // As an optional optimization we retry the lock. if (TryLock (Self) &gt; 0) &#123; assert (_succ != Self , "invariant") ; assert (_owner == Self , "invariant") ; assert (_Responsible != Self , "invariant") ; return ; &#125;&#125; cmpxchg_ptr()之前已经解析过了，在这里，当_cxq指向内容和nxt的相等时，node就赋给_cxq，完成入队并跳出循环；否则继续TryLock()，没拿到锁就循环再次尝试入队。将关键代码再单独拿出来： 12node._next = nxt = _cxq ;if (Atomic::cmpxchg_ptr (&amp;node, &amp;_cxq, nxt) == nxt) break ; 这里的逻辑表明，当有新来的node时，它的next总是指向当前头节点，而当cmpxchg_ptr成功后，头节点指针_cxq就会指向新来的node，所以后来者当头。 此时如若仍然没有获得锁，将进入最后的一个for循环中，这里列出主要代码： 12345678910111213141516171819202122232425262728293031for (;;) &#123; if (TryLock (Self) &gt; 0) break ; assert (_owner != Self, "invariant") ; if ((SyncFlags &amp; 2) &amp;&amp; _Responsible == NULL) &#123; Atomic::cmpxchg_ptr (Self, &amp;_Responsible, NULL) ; &#125; // park self if (_Responsible == Self || (SyncFlags &amp; 1)) &#123; TEVENT (Inflated enter - park TIMED) ; Self-&gt;_ParkEvent-&gt;park ((jlong) RecheckInterval) ; // Increase the RecheckInterval, but clamp the value. RecheckInterval *= 8 ; if (RecheckInterval &gt; 1000) RecheckInterval = 1000 ; &#125; else &#123; TEVENT (Inflated enter - park UNTIMED) ; Self-&gt;_ParkEvent-&gt;park() ; &#125; if (TryLock(Self) &gt; 0) break ; ... if ((Knob_SpinAfterFutile &amp; 1) &amp;&amp; TrySpin (Self) &gt; 0) break ; ... OrderAccess::fence() ;&#125; 代码中，每次循环中会进行数次TryLock()尝试拿锁，期间会执行Self-&gt;\_ParkEvent-&gt;park() ;将自己挂起。 小结通过本文可以知道一个线程在拿锁失败的过程中是如何切换Java状态的。在解读源码的过程中，弄清楚了cmpxchg_ptr()的比较规则，而后续文章将深入队列的唤醒机制。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala中一些符号组合用法的总结]]></title>
    <url>%2F2018%2F10%2F13%2FScala03%2F</url>
    <content type="text"><![CDATA[本篇总结一些符号的组合用法，未完待续。 符号“:”用法用法1：构造List示例： 1234scala&gt; val l0 = 1::2::3::4::Nill0: List[Int] = List(1, 2, 3, 4)scala&gt; 用法1：元素与List连接示例： 123456789101112scala&gt; val l = List(1,2,3,4)l: List[Int] = List(1, 2, 3, 4)scala&gt; val ll = 5::lll: List[Int] = List(5, 1, 2, 3, 4)scala&gt; val ll = l::5&lt;console&gt;:13: error: value :: is not a member of Int val ll = l::5 ^scala&gt; 用法2：组合成“:::”来拼接List用来作为List的拼接： 1234567scala&gt; val l2 = List(9,8,7,6)l2: List[Int] = List(9, 8, 7, 6)scala&gt; l:::l2res18: List[Int] = List(1, 2, 3, 4, 9, 8, 7, 6)scala&gt; 符号“_”用法用法1：“_*”将参数作为序列进行操作，用一个实例进行说明： 12345678910111213scala&gt; def sum(args: Int*): Int = &#123; | var total: Int = 0 | for(arg &lt;- args) &#123; | total = total + arg | &#125; | total | &#125;sum: (args: Int*)Intscala&gt; val s = sum(1 to 5: _*)s: Int = 15scala&gt; 1 to 5: _*足以说明问题； 用法2：导包类似Java中的*：import java.util._； 用法3：变量初始化默认值var i: String = _； 用法4：访问元组元素1234567scala&gt; val a = ( 1 -&gt; "nihao", 2 -&gt; "nihao01", 3-&gt; "nihao03")a: ((Int, String), (Int, String), (Int, String)) = ((1,nihao),(2,nihao01),(3,nihao03))scala&gt; a._1res10: (Int, String) = (1,nihao)scala&gt; 下划线后面跟的数字表示元组中从左数第几个出现的元素； 用法5：占位符利用类型推导极简代码，比如将匿名函数赋值给变量： 1234scala&gt; val a: Int =&gt; Int = _ * 2a: Int =&gt; Int = &lt;function1&gt;scala&gt; 此种方法特别适合于已知返回值的类型的情况； 用法6：作为通配符为函数赋值12345678910scala&gt; def add(x: Int) = x * 2add: (x: Int)Intscala&gt; val a = add _a: Int =&gt; Int = &lt;function1&gt;scala&gt; a(3)res17: Int = 6scala&gt; 这样可以省去书写显示类型，否则将这样书写： 1234scala&gt; val aa: Int =&gt; Int = addaa: Int =&gt; Int = &lt;function1&gt;scala&gt; 符号“=&gt;”用法用法1：函数类型输入类型 =&gt; 返回类型 1234scala&gt; def func(f: Int =&gt; String): Unit = &#123;&#125;func: (f: Int =&gt; String)Unitscala&gt; 用法2：Lambda表达式1234scala&gt; def tes(x: Int): Int =&gt; Unit = &#123; _ =&gt; print("asd")&#125;tes: (x: Int)Int =&gt; Unitscala&gt; 用法3：模式匹配12345678910111213141516scala&gt; def chen(x: Int): String = x match &#123; | case 1 =&gt; "One" | case 2 =&gt; "Two" | case _ =&gt; throw new IllegalArgumentException | &#125; chen: (x: Int)Stringscala&gt; chen(1)res6: String = Onescala&gt; chen(3)java.lang.IllegalArgumentException at .chen(&lt;console&gt;:14) ... 32 elidedscala&gt; 用法4：为倒入库提供别名1234scala&gt; import java.util.&#123;List=&gt;JList&#125;import java.util.&#123;List=&gt;JList&#125;scala&gt; 用法5：传名参数123456789scala&gt; def byname(in: =&gt; Int) = &#123;&#125;byname: (in: =&gt; Int)Unitscala&gt; def f(in: Int) = inf: (in: Int)Intscala&gt; byname(f(3))scala&gt; 用法6：自引用类型http://hongjiang.info/scala-type-system-self-type/ 小结Scala里一些符号的组合用法广泛，写本篇方便快速查询。 参考Scala可变长度参数与:_*使用 scala类型系统：9) this别名&amp;自身类型]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Scala</tag>
        <tag>未完待续</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala入门，以Java程序员的视角(二)：first-class函数]]></title>
    <url>%2F2018%2F10%2F12%2FScala02%2F</url>
    <content type="text"><![CDATA[《Scala学习手册》中文版将first-class翻译成首类，在这里不过多纠结这个翻译。实际上first-class表明了函数在函数式编程中的地位，它属于第一公民！ 函数类型、函数值在Scala里，函数本身也可以当作实例传入传出，那么可以用如下形式表示函数的类型：([&lt;type&gt;, ...]) =&gt; &lt;type&gt;； 在def的函数标识符double(即函数名)赋给val变量时，需要有显示的类型，例如： 1234567891011121314scala&gt; def double(x: Int): Int = x * 2double: (x: Int)Intscala&gt; val myDouble = double&lt;console&gt;:12: error: missing argument list for method doubleUnapplied methods are only converted to functions when a function type is expected.You can make this conversion explicit by writing `double _` or `double(_)` instead of `double`. val myDouble = double ^scala&gt; val myDouble: Int =&gt; Int = doublemyDouble: Int =&gt; Int = &lt;function1&gt;scala&gt; 没有显示的类型会报错，在REPL不能单独输入double这个函数的标识符； 、等中间的数字表明参数列表的大小(即多少个参数)； 如果不想有显示的类型，可以使用通配符_： 1234scala&gt; val myDouble = double _myDouble: Int =&gt; Int = &lt;function1&gt;scala&gt; 函数字面量(匿名函数)一个函数可以让某个函数类型的值作为输入参数或返回值，那么这个函数就是高阶函数； 传递函数给高阶函数，可以采用函数字面量内联定义； 这里的函数字面量对应的是Java 8中的Lambda表达式； 接下来看看函数字面量的表示形式： 1234scala&gt; val doubler = (x: Int) =&gt; x * 2doubler: Int =&gt; Int = &lt;function1&gt;scala&gt; 可以看到一个匿名函数，他有输入(即(x: Int))，有返回(即x * 2)，但是就是没有函数名； 在上一篇文章中，我说“＝”相当于Java 8的“-&gt;”，那是根据“＝”之于后面出现的大括号的作用而言的，在这里“=&gt;”也相当于Java 8中的“-&gt;”，这也是根据“=&gt;”对前后承接的内容产生的作用而言的； 下面看看函数字面量对函数值的修改： 1234scala&gt; val maximize = (a: Int, b: Int) =&gt; if (a &gt; b) a else bmaximize: (Int, Int) =&gt; Int = &lt;function2&gt;scala&gt; 可以看出，此时给maximize赋值不需要添加显示类型； 占位符语法使用条件书中列了两条： 外置位已经指定了类型：只有这样，当你使用_，函数能匹配出其类型； 参数不重复使用：重复使用你就不知道哪个_代表哪个参数了； 这里用一个简单的例子说明： 12345678910scala&gt; def add(a: Int, b: Int, f: (Int, Int) =&gt; Int) = f(a, b)add: (a: Int, b: Int, f: (Int, Int) =&gt; Int)Intscala&gt; add(3, 5, _ * _)res52: Int = 15scala&gt; add(3, 5, (a: Int,b: Int) =&gt; a * b)res53: Int = 15scala&gt; 可见，占位符能对匿名函数进行很好的缩写； 部分应用函数和柯里化这一小节主要讲用单参数函数“解构”多参数函数，柯里化可以使获得部分应用函数更加简洁； 普通方式123456789101112scala&gt; def factorOf01(x: Int): Int =&gt; Boolean = &#123; | def temp(y: Int): Boolean = &#123; | y % x == 0 | &#125; | temp | &#125;factorOf01: (x: Int)Int =&gt; Booleanscala&gt; factorOf01(4)(4)res7: Boolean = truescala&gt; 普通方式是用内嵌函数实现的，外围函数接收一个内嵌函数的返回； 通配符赋值的方式123456789scala&gt; def factorOf(x: Int, y: Int) = y % x == 0factorOf: (x: Int, y: Int)Booleanscala&gt; val test = factorOf(3, _)&lt;console&gt;:12: error: missing parameter type for expanded function ((x$1) =&gt; factorOf(3, x$1)) val test = factorOf(3, _) ^scala&gt; 此时需要显示指定类型； 更正后： 1234567scala&gt; val test = factorOf(3, _: Int)test: Int =&gt; Boolean = &lt;function1&gt;scala&gt; test(4)res2: Boolean = falsescala&gt; 用通配符_替代参数，当继续调用函数时，不需要再输入3； 柯里化方式柯里化方式就是第一篇末尾提到的参数组： 12345678910scala&gt; def factorOf03(x: Int)(y: Int) = y % x == 0factorOf03: (x: Int)(y: Int)Booleanscala&gt; val test03 = factorOf03(4) _test03: Int =&gt; Boolean = &lt;function1&gt;scala&gt; test03(4)res8: Boolean = truescala&gt; 可以发现柯里化比起前面两种更清晰和简洁； 传名参数传名参数类似Java 8里的行为参数化，将函数作为参数传入时并不进行计算，而在方法体内，每调用一次执行一次。接下来会首先采用传名参数的方法来使用函数调用，之后会采用类似Java 8中Lambda表达式实现的方式给出另一个效果相同的版本； 传名参数的方法首先定义被传入参数的函数doubles： 1234567scala&gt; def doubles(x: =&gt; Int) = &#123; | println("Now doubling " + x) | x * 2 | &#125;doubles: (x: =&gt; Int)Intscala&gt; 现在它接受一个Int值，也接受一个返回Int值的函数，在定义返回Int值的函数f： 1234scala&gt; def f(i: Int) = &#123; println(s"Hello from f($i)"); i&#125;f: (i: Int)Intscala&gt; 测试输出结果： 1234567891011scala&gt; doubles(4)Now doubling 4res48: Int = 8scala&gt; doubles(f(8))Hello from f(8)Now doubling 8Hello from f(8)res49: Int = 16scala&gt; f(8)的计算延迟到方法体中进行，每次调用都会执行一次f(8)； 类似Java 8中的方法在Scala中不采用传名参数也是可以的： 12345678910111213scala&gt; def doubles(x: Int =&gt; Int, y: Int) = &#123; | println("Now doubling " + x(y)) | x(y) * 2 | &#125;doubles: (x: Int =&gt; Int, y: Int)Intscala&gt; doubles(f, 8)Hello from f(8)Now doubling 8Hello from f(8)res50: Int = 16scala&gt; 可见打印出的结果和之前采用传名参数的方法相同； 在Java 8中，doubles函数传入的x参数通常是Lambda表达式，而这里直接传入函数值； 这样做的好处其实在《Java 8实战》中有提到，比如打印日志，不必每次都执行而是视条件是否满足而定，这样会在一些场景下节约不必要的开销； 偏函数有的资料中中文翻译的偏函数和部分应用函数彼此是颠倒的，这里还是按照本书中文翻译为准； 只能部分应用于输入数据的函数称为偏函数，即对有些传入的参数，函数将不能工作； 用函数字面量块调用高阶函数实际在上一篇已经讨论过一些()和{}，这里先放上一些实例； 实例1： 123456789101112scala&gt; def ni01(f: String =&gt; String) = &#123; | f("nihao") | &#125;ni01: (f: String =&gt; String)Stringscala&gt; ni01(&#123; s =&gt; "Hello"&#125;)res10: String = Helloscala&gt; ni01&#123; s =&gt; "Hello"&#125;res11: String = Helloscala&gt; 从这个例子可以看出，Scala的匿名函数是可以通过{}包裹后传入函数的，()是{}那么()可以省略； 实例2： 12345678910111213141516scala&gt; def ni02(s: String)(f: String =&gt; String) = &#123; | f(s) | &#125;ni02: (s: String)(f: String =&gt; String)Stringscala&gt; ni02("Hello 02")&#123;s =&gt; s&#125;res12: String = Hello 02scala&gt; ni02("Hello 02")&#123; s =&gt; &#123; println(s) | s | &#125; | &#125;Hello 02res17: String = Hello 02scala&gt; 从这个例子可以看出，参数组在遇到{}同样可以省略()； 实例3： 123456789101112131415scala&gt; def aca[A](f: =&gt; A) = faca: [A](f: =&gt; A)Ascala&gt; def ff(i: Int) = iff: (i: Int)Intscala&gt; aca(ff(4))res9: Int = 4scala&gt; val bbb = aca &#123; print("hello") | 3 | &#125;hellobbb: Int = 3scala&gt; 可以看到aca是传名函数，参数可以是函数值、函数的调用以及{}块，这里{}虽然可以复合语句，但是其实是将其当作传入的函数值来运用，值是最后的的表达式或者语句返回的内容； 小结本篇算是上一篇的进阶，重要的知识点包括函数类型、匿名函数、传名函数啊等等，通过研究这些知识点，本人对Scala函数有了更深入的理解。]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala入门，以Java程序员的视角(一)：函数]]></title>
    <url>%2F2018%2F10%2F11%2FScala01%2F</url>
    <content type="text"><![CDATA[本人将结合《Scala学习手册》一书的内容，以Java程序员的视角为第一视角，用几篇小文来快速入门Scala。本篇内容为Scala函数。 函数编写形式在Scala中编写函数和在Java中编写方法，形式上还是存在一些差别的。 普遍式这种我称之为普遍式： 1def &lt;identifier&gt;(&lt;identifier&gt;: &lt;type&gt;, ...)[: &lt;type&gt;] = &lt;expression&gt; 和Java不同，Scala类型的写法后置了。比如小括号内的: &lt;type&gt;表示行参的类型，中括号内的可选内容: &lt;type&gt;表示expression的返回类型； 这里的=类似Java 8里Lambda表达式的-&gt;； 实例： 1234567scala&gt; def a1(i1: Int, i2: Int): Int = i1 + i2a1: (i1: Int, i2: Int)Intscala&gt; a1(1, 2)res1: Int = 3scala&gt; 大括号式这种方式我称之为大括号式，因为采用{}： 1def &lt;identifier&gt;(&lt;identifier&gt;: &lt;type&gt;, ...)[[: &lt;type&gt;] = ]&#123;&#125; 实例： 1234scala&gt; def b1(a: Int) &#123; a + 1; val b = 1; print(s"sdsd$a") &#125;b1: (a: Int)Unitscala&gt; 讨论[: &lt;type&gt;] =存在与否的情况； 不存在[: &lt;type&gt;] = 的情况： 大括号内只可出现初始化声明，表达式以及语句； 这实际上是一个procedure，没有返回值的函数，通常并不推荐，因为它会“沉默”带返回值的表达式，例如： 1234scala&gt; def b1(a: Int) &#123;a + 1&#125;b1: (a: Int)Unitscala&gt; 可见虽然a + 1是一个有返回的表达式，但是返回值被忽略了； 存在[: &lt;type&gt;] = 的情况： 当添加了=后，就不是一个procedure了，大括号也可以单纯是{a}这种形式了，稍加更改前文中的实例再次运行： 12345scala&gt; def b1(a: Int) = &#123;a + 1&#125;b1: (a: Int)Intscala&gt; b1(2)res2: Int = 3 调用函数后有输出结果：Int = 3； 无参式这里指的是定义无参数输入的函数形式也存在两种，分别是无括号和有括号； 无括号： 12345scala&gt; def c1 = "Ni Hao"c1: Stringscala&gt; c1res14: String = Ni Hao 注意c1:后直接是String，调用函数直接在REPL输入c1，此时不能输入c1()； 有括号： 1234567scala&gt; def c2() = "ni hao"c2: ()Stringscala&gt; c2res15: String = ni haoscala&gt; 此次c2:后接的是()String，通过输入c2而非c2()来调用该函数也是可以的； 关于使用括号的约定：若函数有副作用，定义时应该加空括号，比如函数向控制台写数据等； 递归函数本站文章《学习Java函数式编程(五)：函数式思维与尾递归》已经提到了Java不支持尾递归优化，而Scala等JVM平台下的语言是通过将递归转化为循环来实现伪递归优化的。维基百科和相关文章都提到了，此方法不能优化交叉调用的尾递归，这里不深入说开去，毕竟本篇核心是入门Scala，但是并不难理解，文章末尾给出一些参考链接。 Scala提供了伪递归注解： 1scala&gt; @annotation.tailrec 该注解用来帮助程序员进行伪递归优化； 嵌套函数Scala函数按照函数名以及其参数类型列表来区分彼此； Scala支持嵌套函数，下面列举一例： 1234567891011scala&gt; def max(a: Int, b: Int, c: Int) = &#123; | def max(x: Int, y: Int) = if (x &gt; y) x else y | max(a, max(b, c)) | &#125;max: (a: Int, b: Int, c: Int)Intscala&gt; max(1, 2, 3)res16: Int = 3scala&gt; max(10, 21, 3)res17: Int = 21 函数的调用由内层层到外，所以即便内外函数名以及参数类型列表彼此相等，函数内也是优先调用内部函数； 为指定形参进行传参也就是说，如果在传入参数的过程中，指定了要赋值给哪一个参数，那么就可以不按照原本的顺序传参，看下面的实例： 12345678910111213object Hello &#123; def main(args: Array[String]): Unit = &#123; print(max(b = 10,a = 21,c = 3)) &#125; def max(a: Int, b: Int, c: Int) = &#123; def max(x: Int, y: Int)= &#123; println(s"输入：$x, $y") if (x &gt; y) x else y &#125; max(a, max(b, c)) &#125;&#125; 输出为： 123输入：10, 3输入：21, 1021 可见虽然传入的参数依次是10、21、3，但是由于指定了要赋值给哪一个参数，所以a、b、c分别为21、10、3； Vararg参数在Java中，该功能底层是通过数组实现的。Scala的书写与Java有差别，采用的是参数类型后面添加*，此后不能再跟非Varalg参数，下面用一个例子说明： 123456789scala&gt; def prin(nums: Int*) = &#123; | for (i &lt;- nums) print(i + " ") | &#125;prin: (nums: Int*)Unitscala&gt; prin(1, 2, 3, 4)1 2 3 4scala&gt; prin(1, 5, 3, 4)1 5 3 4 类型参数(Scala泛型)这里要讨论的实际上就是Scala中的泛型，基本的格式如下： 1def &lt;function-name&gt;[type-name](&lt;parameter-name&gt;: &lt;type-name&gt;): &lt;type-name&gt;... Java中泛型的作用不必多言，如果不用泛型采用Any，最后进行类型转换凑合使用： 12345678910scala&gt; def ide(a: Any): Any = aide: (a: Any)Anyscala&gt; ide(3)res24: Any = 3scala&gt; val s: String = ide("hello").toStrings: String = helloscala&gt; 采用泛型来重写ide函数： 1234scala&gt; def ide[A](a: A): A = aide: [A](a: A)Ascala&gt; 此时再调用ide函数将不需要显示转换类型： 1234567scala&gt; val ss = ide("Hello")ss: String = Helloscala&gt; ssres25: String = Helloscala&gt; 也可以写成val ss: String = ide[String](&quot;Hello&quot;)，但是即便不写上类型，Scala可以通过类型推导得出正确的类型； 小结“参数组”和“方法调用”因为和后续内容有关，本篇没有涉及。本篇主要探讨了Scala函数书写的形式和用法，每个小节都多少和Java相关内容进行了类比。 参考知乎提问：Scala是如何实现尾递归优化的？ Java存在尾递归调用优化吗？ 知乎提问：为什么 JVM 下的语言尾递归优化似乎都不完美？]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈阻塞(1)：从探究Java线程的状态开始]]></title>
    <url>%2F2018%2F10%2F10%2FBlocked01%2F</url>
    <content type="text"><![CDATA[本人在《线程生命周期 &amp; 中断机制》一文中提到，可以使用Thread类提供的getState()来获取线程状态，这些状态包括NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED。而在实践中，BLOCKED似乎状态只出现在synchronized内置锁机制里。那么blocked状态是怎样一种存在？它和waiting状态的区别是什么？一切就从探究Java线程的状态开始。 需要说明的是，本系列不讨论内置锁的膨胀过程，主要研究对象是重量级锁，内置锁的优化会另开文章解析。 Linux线程状态简介首先查看JDK文档内容java.lang Enum Thread.State，关于BLOCKED状态是这样解释的： A thread that is blocked waiting for a monitor lock is in this state. 此状态是等待一个monitor lock时的状态，所以它基本上是一个synchronized锁机制的专属状态。 文档还说： A thread can be in only one state at a given point in time. These states are virtual machine states which do not reflect any operating system thread states. 意思是这些状态属于虚拟机状态，并不反映操作系统的线程状态。 那么操作系统都有那些状态？接下来就以Linux为例进行简要分析。这里要说明的是Linux对线程和进程不特别区分，线程只是一种特殊的进程。 Linux内核设计与实现(原书第3版)介绍了系统中每个进程/线程都处于下列五种状态的一种： TASK_RUNNING：或者正在执行，或者在运行队列中等待执行； TASK_INTERRUPTIBLE：进程睡眠，等待条件，可接受信号并被其提前唤醒； TASK_UNINTERRUPTIBLE：进程睡眠，不响应信号； __TASK_TRACED：被其它进程跟踪； __TASK_STOPPED：停止执行，没有投入运行也不能投入运行； 关于划分，不同的书籍介绍的可能有所不同，但是彼此间并没有根本上的差异。《Linux内核设计与实现(原书第3版)》一书的作者参与了Linux抢占式内核、进程调度器等项目的编写，在进程切换方面的理解是非常权威的，而本文通过阅读此书相关内容来理解Linux进程切换的不同状态。 Linux调度器实现的是完全公平调度算法(CFS, Completely Fair Scheduler)，采用的是红黑树来组织可运行进程队列，书中这样写道： Now let’s look at how CFS adds processes to the rbtree and caches the leftmost node. This would occur when a process becomes runnable (wakes up) or is first created via fork()… 还写道： Waking is handled via wake_up(), which wakes up all the tasks waiting on the given wait queue. It calls try_to_wake_up(), which sets the task’s state to TASK_RUNNING, calls enqueue_task() to add the task to the red-black tree… 也就是说，进程/线程唤醒后会将其添加到红黑树中，并且会设置为TASK_RUNNING状态，等待操作系统选取运行。 可见Linux睡眠状态(TASK_INTERRUPTIBLE/TASK_UNINTERRUPTIBLE)和执行状态(TASK_RUNNING)是以线程是否睡眠和唤醒来划分的。 synchronized状态初探我们从源码入手，首先看Thread的getState方法： 1234public State getState() &#123; // get current thread state return sun.misc.VM.toThreadState(threadStatus);&#125; 继续追踪/sun/misc/VM.java的sun.misc.VM.toThreadState()： 1234567891011121314151617public static Thread.State toThreadState(int threadStatus) &#123; if ((threadStatus &amp; JVMTI_THREAD_STATE_RUNNABLE) != 0) &#123; return RUNNABLE; &#125; else if ((threadStatus &amp; JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER) != 0) &#123; return BLOCKED; &#125; else if ((threadStatus &amp; JVMTI_THREAD_STATE_WAITING_INDEFINITELY) != 0) &#123; return WAITING; &#125; else if ((threadStatus &amp; JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT) != 0) &#123; return TIMED_WAITING; &#125; else if ((threadStatus &amp; JVMTI_THREAD_STATE_TERMINATED) != 0) &#123; return TERMINATED; &#125; else if ((threadStatus &amp; JVMTI_THREAD_STATE_ALIVE) == 0) &#123; return NEW; &#125; else &#123; return RUNNABLE; &#125;&#125; 其中JVMTI开头的静态字段在VM.java中都已经写定： 123456private final static int JVMTI_THREAD_STATE_ALIVE = 0x0001;private final static int JVMTI_THREAD_STATE_TERMINATED = 0x0002;private final static int JVMTI_THREAD_STATE_RUNNABLE = 0x0004;private final static int JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER = 0x0400;private final static int JVMTI_THREAD_STATE_WAITING_INDEFINITELY = 0x0010;private final static int JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT = 0x0020; 这个值和HotSpot虚拟机内的设定是一致的，不过虚拟机提供了更多的可选状态： 123456789101112131415public interface JVMTIThreadState &#123; public static final int JVMTI_THREAD_STATE_ALIVE = 0x0001; public static final int JVMTI_THREAD_STATE_TERMINATED = 0x0002; public static final int JVMTI_THREAD_STATE_RUNNABLE = 0x0004; public static final int JVMTI_THREAD_STATE_WAITING = 0x0080; public static final int JVMTI_THREAD_STATE_WAITING_INDEFINITELY = 0x0010; public static final int JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT = 0x0020; public static final int JVMTI_THREAD_STATE_SLEEPING = 0x0040; public static final int JVMTI_THREAD_STATE_IN_OBJECT_WAIT = 0x0100; public static final int JVMTI_THREAD_STATE_PARKED = 0x0200; public static final int JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER = 0x0400; public static final int JVMTI_THREAD_STATE_SUSPENDED = 0x100000; public static final int JVMTI_THREAD_STATE_INTERRUPTED = 0x200000; public static final int JVMTI_THREAD_STATE_IN_NATIVE = 0x400000;&#125; 也许一开始会疑惑，虚拟机多出来的状态值怎么体现在toThreadState运算出的状态中呢？其实threadStatus不是单个状态的值，而是多个状态的叠加值，由于最终会使用位运算，虽然只是将状态值简单叠加，但是各位置上的0或1互不干预，比如PARKED，当在toThreadState方法中进行位运算的时候，会得到WAITING的结果，在javaClasses.hpp下查看枚举类型threadStatus，状态值叠加方式如下： 12345678910111213141516171819202122232425262728enum ThreadStatus &#123; NEW = 0, RUNNABLE = JVMTI_THREAD_STATE_ALIVE + // runnable / running JVMTI_THREAD_STATE_RUNNABLE, SLEEPING = JVMTI_THREAD_STATE_ALIVE + // Thread.sleep() JVMTI_THREAD_STATE_WAITING + JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT + JVMTI_THREAD_STATE_SLEEPING, IN_OBJECT_WAIT = JVMTI_THREAD_STATE_ALIVE + // Object.wait() JVMTI_THREAD_STATE_WAITING + JVMTI_THREAD_STATE_WAITING_INDEFINITELY + JVMTI_THREAD_STATE_IN_OBJECT_WAIT, IN_OBJECT_WAIT_TIMED = JVMTI_THREAD_STATE_ALIVE + // Object.wait(long) JVMTI_THREAD_STATE_WAITING + JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT + JVMTI_THREAD_STATE_IN_OBJECT_WAIT, PARKED = JVMTI_THREAD_STATE_ALIVE + // LockSupport.park() JVMTI_THREAD_STATE_WAITING + JVMTI_THREAD_STATE_WAITING_INDEFINITELY + JVMTI_THREAD_STATE_PARKED, PARKED_TIMED = JVMTI_THREAD_STATE_ALIVE + // LockSupport.park(long) JVMTI_THREAD_STATE_WAITING + JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT + JVMTI_THREAD_STATE_PARKED, BLOCKED_ON_MONITOR_ENTER = JVMTI_THREAD_STATE_ALIVE + // (re-)entering a synchronization block JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER, TERMINATED = JVMTI_THREAD_STATE_TERMINATED&#125;; 这也是为什么在程序中调用LockSupport.park()后，通过getState()得到的状态是waiting的原因。 不过以上只是简单的探索，还不清楚虚拟机各状态划分的边界在哪，也不清楚它和操作系统线程的状态如何对标。 更多的问题看一个有趣的例子： 12345678910111213141516171819202122232425262728293031323334353637public class SynchronizedDemo01 &#123; public static void main(String[] args) &#123; byte[] lock = new byte[0]; Runnable task = () -&gt; &#123; &#123; synchronized (lock) &#123; Scanner scanner = new Scanner(System.in); System.out.println("waiting enter sth: "); String s = scanner.next(); System.out.println(Thread.currentThread().getName() + ": " + s); &#125; &#125; &#125;; Thread t1 = new Thread(task, "t1"); Thread t2 = new Thread(task, "t2"); t1.start(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(t1.getState()); t2.start(); System.out.println(t2.getState()); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(t2.getState()); &#125;&#125; 运行这段代码会输出： 1234waiting enter sth:RUNNABLERUNNABLEBLOCKED 然后等待用户输入，我随便打了两次ASDA，完整输出如下： 123456789waiting enter sth:RUNNABLERUNNABLEBLOCKEDASDAt1: ASDAwaiting enter sth:ASDAt2: ASDA 这段代码有趣的地方在于： 在内置锁锁定的块中，会发生了IO阻塞等待输入，但当t1线程启动，经过两秒后调用getState方法，结果显示t1处于RUNNABLE状态； t2启动后，立马调用getState方法，显示t2处于RUNNABLE状态； 在t2启动两秒后，再次调用getState方法，显示t2处于BLOCKED状态； 第1点就印证了上一节给出的文档中的注释，即虚拟机的线程状态并不反映操作系统的线程状态，IO阻塞时，在操作系统中线程会处于阻塞状态，但是上面的例子显示虚拟机线程处于RUNNABLE状态； 产生第2、3点差异的原因会在后续文章分析。 小结同样是“勉强”，日文和中文的意思就完全不一样，而在学习Java多线程技术的过程中，“阻塞”一词，在不同层面也各有各的深意。本文的目的在于厘清一些基本概念，并抛出一些问题，在后续的解析中，将会尝试解决这些问题。 参考JDK文档：java.lang Enum Thread.State Linux内核设计与实现(第三版)：Linux内核设计与实现(原书第3版)]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>synchronized</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Linux内核设计与实现》阅读笔记：(第四章)进程调度]]></title>
    <url>%2F2018%2F09%2F28%2FLinux_JCDD%2F</url>
    <content type="text"><![CDATA[进程调度是操作系统的核心功能，本篇继续追随《Linux内核设计与实现》的脚步，摸清Linux进程调度的原理。 多任务调度程序主要负责决定三件事： 执行哪个进程； 什么时候执行； 执行多长时间； 最大限度利用处理器时间原则：只要有可执行的进程，那么总会有进程正在执行。 多任务系统分类： 非抢占式多任务：除非进程自己停止运行，否则就会一直执行； 抢占式多任务：由电镀程序决定什么时候停止一个进程的运行，以便其它进程得到执行的机会，被抢占之前能狗运行的时间是预先设置好的，这个时间称为“时间片”； 绝大多数系统(包括Linux)是抢占式多任务系统。 Linux进程调度简介Linux采用的调度算法是在不断演进的。2.5版本采用的是一种O(1)的调度程序，2.6.23用完全公平调度算法(CFS)替换了O(1)调度算法，发展历史如下： (注：图片出自陈向群《操作系统原理》公开课) 策略I/O消耗型和处理器消耗型进程进程按执行过程划分可以用一张图表示： (注：图片出自陈向群《操作系统原理》公开课) 对于处理器密集型进程，调度策略往往是尽量降低它们的调度频率，延长运行时间； 调度策略通常要在两个矛盾的目标中间寻找平衡：进程响应迅速(响应时间短)和最大系统利用率(高吞吐量)； Linux更倾向于优先调度I/O密集型进程，但并未忽视处理器密集型进程； 进程优先级Linux采用两种不同的优先级范围： nice值 nice是代表静态优先级的数值，范围从-20到+19，默认值为0。越大的nice值意味更低的优先级，在Linux系统中nice值代表时间片的比例； 实时优先级 默认情况下它的变化范围是从0到99(包括0和99)，越高的实时优先级数值意味着进程优先级越高，实时进程的优先级高于普通进程； 时间片Linux的CFS调度器没有直接分配时间片到进程，它将处理器的使用比划分给了进程，所以处理器时间其实和系统负载密切相关； Linux中使用新的CFS调度器后，抢占时机取决于新的可运行程序消耗了多少处理器使用比，如果消耗的使用比比当前进程小，则新进程立刻投入运行抢占当前进程，否则推迟运行； Linux调度算法直接看看Linux的调度算法吧。 调度器类Linux scheduler是modular的，这样允许不同算法调度不同类型的进程。每一个scheduler class有一个优先级，the base scheduler code定义在kernel/sched.c，这个基础代码按照优先级来迭代每一个scheduler class； CFS是为普通进程注册的scheduler class，定义在kernel/sched_fair.c； 传统Unix系统调度器的改造Linux的CFS对时间片分配方式进行了根本性重新设计，摒弃时间片而是分配给进程一个处理器使用比重，通过这种方式CFS确保了进程调度中能有恒定的公平性但切换速率可变； 公平调度CFS在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是依靠nice值来计算时间片； 任何nice值对应的绝对时间不再是一个绝对值，而是处理器的使用比； Linux调度实现CFS四部分： Time Accounting Process Selection The Scheduler Entry Point Sleeping and Waking Up Time Accounting在大多数Unix系统中，所有进程调度器给每一个进程分配一个时间片，用来计算处理器运行的时间，每经过一次系统的始终周期，时间片的值就相应减少，当为0时CPU被时间片没有为0的进程抢占； The Scheduler Entity Structure CFS不在有时间片的概念(我觉得主要表现在结构体没有时间片变量吧)，使用sched_entity结构体来持续记录进程运行时间(to keep track of process accounting)： 1234567891011121314struct sched_entity &#123; struct load_weight load; /* for load-balancing */ struct rb_node run_node; struct list_head group_node; unsigned int on_rq; u64 exec_start; u64 sum_exec_runtime; u64 vruntime; u64 prev_sum_exec_runtime; ...&#125;; 此结构作为一个成员变量se嵌入进程描述符中。 The Virtual Runtime vruntime保存了进程的虚拟运行时间，这是实际花费的运行时间按处于runnable状态的进程的权重计算出来的。它的作用：“CFS uses vruntime to account for how long a process has run and thus how much longer it ought to run.” 毕竟，如果拥有理想的处理器，就不需要vruntime，因为优先级相同的所有进程的虚拟运行时都是相同的。 vruntime的更新需要update_curr函数，具体可以看kernel/sched_fair.c文件下的update_curr()实现。 Process Selection当CFS需要选择下一个运行进程时，它会挑选一个具有最小vruntime的进程。CFS使用红黑树(红黑树在本站的某篇中已经解读过)来组织可运行进程队列(the list of runnable processes)。 挑选下一个任务 就是在红黑树中查找最左节点，实现这一过程的函数是__pick_next_entity()； 红黑树最左节点缓存在rb_leftmost中，不需要__pick_next_entity函数在红黑树中搜索； 没有最左节点就代表没有节点，那么这个时候表示没有可运行的进程，CFS调度idle任务； 向树中加入进程 这一步的主要工作是将进程插入红黑树，并且缓存最左节点； 时机：在进程变为可运行状态(被唤醒)活着通过fork()调用第一次创建进程时，主要是enqueue_entity函数实现； 缓存最左节点时，采用leftmost标志位来判断插入的节点是否是最左，一旦转向右分支，则置为0，表示它不会是最左节点，如果leftmost一直为1，那么可以更新缓存； 从树中删除进程 删除动作发生在进程阻塞(不可运行态)或终止； 删除具体由__dequeue_entity()完成，它直接借用了红黑树的rb_erase()来完成所有删除工作； 更新rb_leftmost，如果删除了最左节点，还要调用rb_next()按顺序遍历； The Scheduler Entry Point前面提到了“the base scheduler code定义在kernel/sched.c，这个基础代码按照优先级来迭代每一个scheduler class”，进程调度的入口函数schedule()就定义在文件kernel/sched.c，而在schedule()里发生的唯一重要的部分就是调用pick_next_task()(该函数也定义在文件kernel/sched.c中)； 一个调度类对应一个调度算法，设立涉及两个最高优先级：最高优先级调度类以及最高优先级进程； pick_next_task()要做的事是按照优先级从高到低，依次轮询调度类，每个调度类又维护着自己的运行队列，于是又查找运行队列里优先级最高的进程； CFS是普通进程的调度类，而系统中运行的绝大多数进程都是普通进程，所以一开始可以判断所有运行进程的数量是否等于CFS对应的可运行进程数，如果是就直接通过CFS查询最高优先级的线程并选择执行之； 有了上面的基本结论，那么pick_next_task()的代码就不难理解了，这里直接放出： 123456789101112131415161718192021222324252627282930/* * Pick up the highest-prio task: */static inline struct task_struct *pick_next_task(struct rq *rq)&#123; const struct sched_class *class; struct task_struct *p; /* * Optimization: we know that if all tasks are in * the fair class we can call that function directly: */ if (likely(rq-&gt;nr_running == rq-&gt;cfs.nr_running)) &#123; p = fair_sched_class.pick_next_task(rq); if (likely(p)) return p; &#125; class = sched_class_highest; for ( ; ; ) &#123; p = class-&gt;pick_next_task(rq); if (p) return p; /* * Will never be NULL as the idle class always * returns a non-NULL p: */ class = class-&gt;next; &#125;&#125; 轮询各调度类的pick_next_task()封装出总的pick_next_task()，likely(rq-&gt;nr_running == rq-&gt;cfs.nr_running)中，rq结构体存储了CPU的调度信息，每个CPU都分配了一个rq。所以rq-&gt;nr_running可以求出所有该CPU被调度运行的进程，rq-&gt;cfs.nr_running求出cfs算法的运行队列有多少可运行的线程； Sleeping and Waking Up这一小节的内容符合本人对睡眠唤醒的理解，所以不赘述，一图以蔽之： 抢占和上下文切换上下文切换时机：当一个新的进程被选出来准备投入运行，schedule()就会调用context_switch()负责处理上下文切换； context_switch()完成两项基本工作： 调用switch_mm()，切换虚拟内存映射； 调用switch_to()，负责从上一个进程的处理器状态切换到新进程的处理器状态，包括保存和恢复(栈信息、寄存器信息以及其它)； 抢占时机：和schedule()的调用有关，内核需要知道什么时候调用它。need_resched是一个标志位，scheduler_tick()和try_to_wake_up()都会设置这个标志，内核检查该标志位，确认是否被设置来判断是不是要调用schedule()； 每个进程都包含一个need_resched标志，2.6版本以后，它被移到thread_info结构体里； 用户抢占用户抢占发生在内核返回用户空间，need_resched被设置，调度器(scheduler)被调用的时候； 总的来说，用户抢占发生在如下情况： 从内核返回用户空间时； 从中断处理程序返回用户空间时； 在这两种情况下，都会检查need_resched标志； 内核抢占只要重新调度是安全的，内核就可以在任何时候抢占正在执行的任务； 安全与否取决于是否持有锁，锁是非抢占区域的标志； 如何实现锁？在thread_info引入preempt_count计数器，初始为0，每当使用锁的时候数值加1，释放的时候数值减1， 进程持有的所有锁都被释放了，那么preempt_count会重新置为0，释放锁的代码会检查need_resched是否被设置； 内核抢占发生在如下情况： 中断处理程序正在执行，且返回内核空间之前； 内核代码再次变得可抢占式的，(When kernel code becomes preemptible again)； 内核进程(task)显示调用schedule()； 如果内核进程(task)被阻塞(结果就是调用schedule())； 实时调度策略Linux提供了两种实时调度策略：SCHED_FIFO和SCHED_RR，而普通的非实时的调度策略是SCHED_NORMAL； 实时调度策略不受CFS调度器的管理，CFS调度在sched_fair.c中，实时调度在sched_rt.c中。 SCHED_FIFO： 优先级比SCHED_NORMAL高； 一旦被调度就一直执行，直到阻塞或显式释放处理器为止； 除非有更高级的进程才能抢占SCHED_FIFO进程； 多个同级SCHED_FIFO进程可以轮流执行，但只有它们原意让出处理器时才会退出； SCHED_RR： SCHED_RR可以理解为带有时间片的SCHED_FIFO； 当SCHED_RR时间片耗尽的时候，同一优先级的其它实时进程被轮流调度； 对于SCHED_FIFO进程，高优先级总是立即抢占低优先级，但是低优先级进程绝对不能抢占SCHED_RR，即使后者时间片耗尽； 软实时：内核调度进程，尽力使进程在它的限定时间到来前运行，但不保证满足；相反，硬实时保证在一定条件下，可以满足任何调度的要求； 补充很多资料会出现SCHED_OTHER调度策略，实际上它就是SCHED_NORMAL，对于普通进程有这三种： SCHED_NORMAL：CFS对应的策略； SCHED_BATCH：与SCHED_NORMAL策略一样，但针对吞吐量优化； SCHED_IDLE：优先级最低，系统空闲才跑； 小结通过此篇笔记，本人对Linux进程调度有了大致的理解，了解了其内部的运作机制。 参考《Linux内核设计与实现(第三版)》 《Linux Kernel Development, 3rd Edition》 陈向群《操作系统原理》公开课]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>进程调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 7的Coin项]]></title>
    <url>%2F2018%2F09%2F28%2FJava7_Coin%2F</url>
    <content type="text"><![CDATA[Coin包括六个新特性：switch的String、数字常量新形式、改进的异常处理、TWR、钻石语法、参数警告位置的修改。 switch的Stringswitch在java 7后，case语句的常量可以使用String了，至于之前版本为什么不可以，引用参考链接中出现的一句话： James Curran succinctly says: “Switches based on integers can be optimized to very efficent code. Switches based on other data type can only be compiled to a series of if() statements. For that reason C &amp; C++ only allow switches on integer types, since it was pointless with other types.” 所以之前虽然支持byte、char、short、int(包括它们的包装类型)或枚举类型，但实际上都是将它们转化为int进行比较(这个转化润物细无声，JVM内部这些类型都是按照int存储的)。 而Java 7中支持String的实现原理是，伪代码如下： 1234567String a = 传入的字符串;switch(a.hashCode()) &#123; case int值： if (a.equals("case后的字面字符串")) &#123; ... &#125;&#125; 如果a为null，那么在switch代码块中添加default即可。 数字常量新形式 二进制形式可以用0b开头来表示了。 输入一串数字非常长，可以用_下划线作为分隔符。 改进的异常处理 通过异常分类，把类别相近的异常放在一起处理。 例如： 12345try &#123;&#125; catch (FileNotFoundException | ParseException e) &#123; ...&#125; 为异常重抛提供帮助。 例如在异常往上抛出的过程中，如果中间某一层的catch使用了Exception，那么继续上抛只能用笼统的catch捕获。此时可以显式添加final关键字(不是必须)： 1234catch (final Exception e) &#123; ... throw e;&#125; TWRtry-with-resources是我们现在比较常用的特性之一。使用资源时，将其放在try的括号内，这样当程序离开代码块的时候资源会自动关闭。 但是要注意：为了确保资源能正确关闭，应该讲各个资源声明为独立变量。 TWR还能改善错误跟踪的能力(在之前Java版本中抛出的异常信息经常会被覆盖)。 钻石语法《Effective Java》第二章第一条讲到过静态工厂方法的第四大优势… 钻石语法顺势简化了代码。 参数警告位置的修改泛型数组在Java中是被禁止的。而不定数量参数是依靠数组实现的，那么程序员可能不知不觉会构造出带有泛型数组的方法： 123public static &lt;T&gt; ArrayList&lt;T&gt; doSomething(T... args) &#123; ...&#125; 之前Java版本的警告信息会在使用doSomething的地方出现，而在Java 7中挪到了定义的地方。 小结通过本篇，旨在巩固一些Java知识，了解Coin项目的基本内容。 参考Java程序员修炼之道 Why can’t I use switch statement on a String?]]></content>
      <categories>
        <category>Java 7</category>
      </categories>
      <tags>
        <tag>Java 7</tag>
        <tag>Coin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Linux内核设计与实现》阅读笔记：(第十五章)进程地址空间]]></title>
    <url>%2F2018%2F09%2F26%2FLinux_JCDZKJ%2F</url>
    <content type="text"><![CDATA[本篇主要是跟随《Linux内核设计与实现》一书，了解进程地址空间相关的技术，从源码的角度理解Linux里进程和线程的区别。 一些概念 进程地址空间由进程可寻址的虚拟内存组成，所以它是逻辑内存，不是物理内存； “平坦”，指的是地址空间范围是一个独立的连续区间； 进程地址空间中任何有效地址都只能位于唯一的区域：栈、对象代码、全局变量、被映射的文件等； 在之前的笔记《进程管理》一篇的补充章节中，本人已经提到了进程的布局，但《Linux内核设计与实现》的划分更细腻： 可执行文件代码的内存映射，代码段(text section)； 可执行文件的已初始化全局变量的内存映射，数据段(data section)； 包含未初始化全局变量的内存映射，也就是bss段的零页(页面信息全是0值)； 用于进程用户空间栈的零页内存映射； 每一个诸如C库或者动态链接库等共享库的代码段，数据段和bss也会被载入进程的地址空间； 任何内存映射文件； 任何共享内存段； 任何匿名内存映射，比如由malloc()分配的内存； 内存描述符和进程描述符一样，内存描述符包含了和地址空间有关的全部信息，它被表示为一个mm_struct结构体。 mm_users vs mm_count： mm_users表示正在使用该地址的进程数目，是mm_struct的用户数，也就是使用该地址空间的线程数；mm_count表示mm_struct结构体的主引用计数。通过同时具有这两个计数，内核可以区分使用地址空间的进程数和引用计数。 mmap vs mm_rb： 这两个结构体都可以描述地址空间的全部内存区域，mmap是链表，遍历元素更高效；mm_rb是红黑树，搜索元素更高效，下图展示了基本原理： 所有的mm_struct结构体通过自身的mmlist连接在一个双向链表中，受元素是init_mm内存描述符，代表了init进程的地址空间，操作需要加锁防止并发。 分配内存描述符进程描述符task_struct的mm域存放着进程使用的内存描述符。 进程：fork()利用copy_mm()复制父进程内存描述符 线程：调用clone()时，设置CLONE_VM标志，使父进程和子进程共享地址空间； 接下来看看具体代码中是如何实现的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static int copy_mm(unsigned long clone_flags, struct task_struct *tsk)&#123; struct mm_struct *mm, *oldmm; int retval; tsk-&gt;min_flt = tsk-&gt;maj_flt = 0; tsk-&gt;nvcsw = tsk-&gt;nivcsw = 0;#ifdef CONFIG_DETECT_HUNG_TASK tsk-&gt;last_switch_count = tsk-&gt;nvcsw + tsk-&gt;nivcsw;#endif tsk-&gt;mm = NULL; tsk-&gt;active_mm = NULL; /* * Are we cloning a kernel thread? * * We need to steal a active VM for that.. */ //获取父进程的内存描述符 oldmm = current-&gt;mm; if (!oldmm) return 0; /* initialize the new vmacache entries */ vmacache_flush(tsk); // 判断是否要创建的是线程 if (clone_flags &amp; CLONE_VM) &#123; atomic_inc(&amp;oldmm-&gt;mm_users); mm = oldmm; goto good_mm; &#125; retval = -ENOMEM; // 要创建新的进程 mm = dup_mm(tsk); if (!mm) goto fail_nomem;good_mm: tsk-&gt;mm = mm; tsk-&gt;active_mm = mm; return 0;fail_nomem: return retval;&#125; tsk代表待创建进程/线程的进程描述符，一旦clone_flags &amp; CLONE_VM为true，那么代码最终跳转到good_mm:处，可见tsk的mm只是简单指向了父进程内存描述符oldmm的内容。 clone_flags &amp; CLONE_VM为false，则会执行mm = dup_mm(tsk);，下面继续追踪这段代码： 12345678910111213141516171819202122232425262728293031323334static struct mm_struct *dup_mm(struct task_struct *tsk)&#123; struct mm_struct *mm, *oldmm = current-&gt;mm; int err; mm = allocate_mm(); if (!mm) goto fail_nomem; memcpy(mm, oldmm, sizeof(*mm)); if (!mm_init(mm, tsk)) goto fail_nomem; err = dup_mmap(mm, oldmm); if (err) goto free_pt; mm-&gt;hiwater_rss = get_mm_rss(mm); mm-&gt;hiwater_vm = mm-&gt;total_vm; if (mm-&gt;binfmt &amp;&amp; !try_module_get(mm-&gt;binfmt-&gt;module)) goto free_pt; return mm;free_pt: /* don't put binfmt in mmput, we haven't got module yet */ mm-&gt;binfmt = NULL; mmput(mm);fail_nomem: return NULL;&#125; 调用dup_mm()后tsk不再是单纯的引用父进程的内存描述符，而是复制了父进程的内存描述符，如同书中描绘的那样“The mm_struct structure is allocated from the mm_cachep slab cache via the allocate_mm() macro in kernel/fork.c.” mm_struct与内核线程内核线程又称为守护进程，没有进程地址空间，内核线程对应的进程描述符mm域为空。内核线程可以定义为没有用户上下文的进程。这些“小知识”在前几篇已经阐述过。 首先，内核线程不需要有自己的“独家”描述符和页表。但是在具体被调度后，还是需要访问一些数据的，比如页表。所以内核线程将直接使用前一个进程的内存描述符，内核线程一文提到：“为强调用户空间部分不能访问，mm设置为空指针。但由于内核必须知道用户空间当前包含了什么，所以在active_mm中保存了指向mm_struct的一个指针来描述它。” 内核线程不访问用户空间的内存。 虚拟内存区域内存区域由vm_area_struct结构体描述，也称作虚拟内存区域：virtual memoryAreas，VMAs。 每个内存区域都拥有一致的属性，比如访问权限等。 内存区域的树型结构和内存区域的链表结构mmap和mm_rb保存的元素就是各个虚拟内存区域。 mmap指针指向vm_area_struct内存对象构成的链表； mm_rb指向红黑树的根节点，地址空间中每一个vm_area_struct结构体通过自身的vm_rb连接到树中； 页表页表的目的是完成物理内存和虚拟内存的映射； 地址转换需要将虚拟地址分段，使每段虚拟地址都作为一个索引指向页表，而页表指向下一级别的页表活着指向最终的物理页面； 利用多级页表能够节约地址转换需占用的存放空间，Linux对所有体系结构使用三级页表管理； 为了加快搜索内存中的物理地址，多数体系结构实现了一个翻译后缓冲器(TLB)，当访问虚拟地址时，处理器首先检查TLB是否缓存了该地址到物理地址的映射； 书中提到的未来改进，架构页表页通过COW处理，可以消除fork()操作中页表拷贝所带来的消耗； 下图给出了一个三级页表的架构图： 小结阅读《Linux内核设计与实现》第十五章旨在了解Linux实现进程地址空间的代码结构，了解了不少相关技术(比如进程和线程)的实现细节。 参考《Linux内核设计与实现(第三版)》 《Linux Kernel Development, 3rd Edition》 Linux Kernel: Why are we using two variables mm_users and mm_count in mm_struct? 本文简单介绍Linux Kernel怎么管理内存 linux/v4.4/source/kernel/fork.c 内核线程 问题mm_count指的是本进程的引用不算而其它进程或者其它进程的线程的引用算？ mm_count和复制父进程的内存描述符有关？]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>进程地址空间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Linux内核设计与实现》阅读笔记：(第十二章)内存管理]]></title>
    <url>%2F2018%2F09%2F25%2FLinux_NCGL%2F</url>
    <content type="text"><![CDATA[书在一开始阐明，第十二章主要讨论的是在内核中获取内存的方法。 页一些概念 物理页：内存管理的基本单位； 内存管理单元(MMU)：一种硬件，用来管理内存以及把虚拟地址转换为物理地址； 页大小：不同的计算机体系结构支持不同的页大小，32位一般支持4KB的页，64位支持8KB的页； struct page {…}：与物理页相关，而非虚拟页，该结构用于描述物理内存本身，内核用此结构管理所有页，系统中每个物理页都需要分配一个这样的结构体； 区一些概念 区：内核把页划分成不同的区，使用区对具有相似特性的页进行分组； 内存寻址问题：一些硬件只能直接访问特定的内存地址(其它不能直接访问)；物理地址比虚拟地址还要宽泛； ZONE_DMA：该区包含的页能被硬件直接访问； ZONE_DMA32：该区的页只能被32位设备直接访问； ZONE_NORMAL：该区包含能正常映射的页； ZONE_HIGHEM：该区包含“高端内存”，不能映射到内核地址空间； 区的划分意义：区的划分没有物理意义，这是内核管理页的逻辑分组； 获取页内核提供了请求内存的底层机制，提供了对内存进行访问的一些接口，通过这些接口在内核内分配和释放内存。 以页为单位分配内存最核心的函数： 1struct page * alloc_pages(gfp_t gfp_mask, unsigned int order) 分配2order个连续物理页，返回指针指向第一个页的page结构体。 把给定页转换它的逻辑地址： 1void * page_address(struct page *page) 该函数返回给定物理页当前所在的逻辑地址。 书中放出了所有底层页分配方法的列表。 释放页释放页的函数： 123void __free_pages(struct page *page, unsigned int order)void free_pages(unsighed long addr, unsigned int order)void free_page(unsigned long addr) 释放页要谨慎，因为内核态不是用户态，内核完全信任自己，所以传递错误值会导致崩溃。 kmalloc()用来获得以字节为单位的一块内存，如果需要整个页，那么前面讨论的页分配接口可能是更好的选择。 kmalloc()分配的内存区在物理上是连续的。 12struct sth *p;kmalloc(sizeof(struct sth), GFP_KERNEL); GFP_KERNEL标志表示内存分配器将采取行为。 gfp_mask标志标志它分为三类： 行为修饰符：表示内核应该如何分配所需要的内存； 区修饰符：表示从哪分配内存； 类型标志：组合了行为修饰符和区修饰符，将各种可能用到的组合归纳为不同类型，简化修饰符的使用； 前面提到的GFP_KERNEL就是一种类型标志。 K.V.M(kmalloc、vmalloc、malloc)技术要点： kmalloc、vmalloc分配的是内核内存，malloc分配的是用户内存； kmalloc分配的内存在物理上连续，vmalloc是在虚拟地址空间上连续； 大多数情况下，只有硬件设备需要得到物理地址连续的内存，因为它在内存管理单元之外，不懂虚拟地址； 需要DMA访问的时候需要物理上连续； 很多内核代码用K而不用V是基于性能考虑； V比直接内存DMA映射会有大得多TLB(一种硬件缓冲区，缓存虚拟到地址物理的映射关系)的抖动； slab层数据频繁分配和回收会伴随优化的问题。通常做法是采用空闲链表，它相当于一个对象高速缓存，比如需要新数据就从空闲链表抓取，而不需要分配内存再放数据，当不需要该数据时就把它放回空闲链表，而非释放它。 但是空闲链表一般的实现方法在Linux中会存在一些局限，内核编写者通过权衡各种利弊为Linux内核提供了slab内存分配器。 slab负责内存紧缺情况下所有底层的对其、着色、分配、释放以及回收，如果频繁创建很多相同类型的对象，应该考虑用slab高速缓存，而不要自己去实现空闲链表。 在栈上静态分配用户空间能够奢侈的负担起非常大的栈，而且栈空间可以动态增长，见下图进程内存的逻辑结构： 内核栈小而固定，大小依赖体系结构，也与编译时选项有关，历史上每个页都有两个页的内核栈。 为了避免终端处理程序放在内核栈中，内核开发者还实现了中断栈，这样中断处理程序不用再和被中断进程共享一个内核栈。 在内核栈上进行大量的静态分配是很危险的，通过内核栈溢出一文可以看到实验中内存溢出时的打印报告。在栈溢出的时候最好的情况是宕机，最坏是悄无声息破坏数据。 每个CPU分配SMP的全称是“对称多处理”（Symmetrical Multi-Processing）技术，是指在一个计算机上汇集了一组处理器(多CPU)，各CPU之间共享内存子系统以及总线结构。在Linux中，各CPU的数据都存在一个数组中，用当前处理器号作为数组的索引访问数组元素。 补充内核态和用户态 内核态/用户态：两个状态通过执行硬件指令使CPU切换，也就是说这两个状态是针对CPU而言的； 虚拟内存区域：分为用户空间和内核空间； 用户态：CPU只能访问被标记为用户空间的内存，访问内核空间会出发硬件异常； 内核态：CPU可以访问内核空间和用户空间； 进程/task 处于与世隔绝态。一个简单的例子解释：“某进程创建另一个进程”，其实是某进程请求内核创建另一个进程。进程的“创建”只是一种系统级调用。 系统调用的执行步骤可以通过一张图来说明： CPU控制Linux正是通过这种方式“控制”CPU的执行，这里的“控制”指的是执行谁的代码，每当进程进行系统级调用，那么Linux就拿到了CPU的控制权。 Linux还可以通过时钟中断的方式拿到CPU的控制权。下面引用操作系统对CPU的控制权一文的描述： 你的主板里，会有一个时钟，滴滴答答的走着，每隔一段时间，它就会给CPU发信号。CPU收到信号，就会执行预先设定好的操作系统的代码，一旦这些代码被执行了，操作系统就有控制权了。 这就是为什么即便线程处于循环中，仍然能够被操作系统调度。 小结本文通过快速阅读《Linux内核设计与实现》十二章的内容来了解Linux内存管理的基本架构，为后续相关技术的研究做好铺垫。 参考《Linux内核设计与实现(第三版)》 《Linux Kernel Development, 3rd Edition》 《Linux_UNIX系统编程手册(上)》 内核栈溢出 操作系统对CPU的控制权]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Linux内核设计与实现》阅读笔记：(第三章)进程管理]]></title>
    <url>%2F2018%2F09%2F24%2FLinux_JCGL%2F</url>
    <content type="text"><![CDATA[本人第一次翻看《Linux内核设计与实现》的时候，非常享受其中关于Linux进程调度的内容。不同于《深入理解计算机系统》泛而全，此书对于特定领域知识的介绍更加详细，且作者就是Linux抢占式内核、进程调度器等项目的参与者，书中的描述具有权威性。本人将开启一个文章系列作为对此书的阅读笔记。 进程概念书中给出了一些概念： 进程：处于执行期的程序以及相关资源的总称、正在执行的程序代码的实时结果 / 内核视进程为任务； 可执行代码：在Unix称为代码段，text section； 进程描述符：包含一个进程的所有信息； Linux系统的线程实现：对线程和进程不特别区分； 进程提供两种虚拟机制：虚拟处理器和虚拟内存，分别将在第四章和第十二章详细描述； 一些系统级函数：fork、exec、exit、wait4()等； Linux内核通常也把进程叫做任务task，书中“任务”“进程”这两个术语交替使用。 进程描述符内核把进程放在任务队列中，这个队列是一个双向循环链表，链表每一项都是task_struct类型，称为进程描述符。这个描述符包含一个进程的所有信息。 分配进程描述符：Linux通过slab分配器分配task_struct，在这个过程中会创建新的结构struct thread_info，这个结构有助于计算偏移量。 PID用来标识进程，每个进程的PID都存放在各自的进程描述符中，默认最大值32768，但可以修改。 进程上下文：可执行文件 -&gt; 进程地址空间 -&gt; 用户空间执行 -&gt; 系统调用 or 触发异常则内核空间执行，此时的内核处于进程上下文中。 进程/线程状态 每个进程/线程都处于下列五种状态的一种： TASK_RUNNING：或者正在执行，或者在运行队列中等待执行； TASK_INTERRUPTIBLE：进程睡眠，等待条件，可接受信号并被其提前唤醒； TASK_UNINTERRUPTIBLE：进程睡眠，不响应信号； __TASK_TRACED：被其它进程跟踪； __TASK_STOPPED：停止执行，没有投入运行也不能投入运行； 进程家族树 所有进程都是PID为1的init进程的后代； 每个进程都有一个父进程，每个进程也拥有0个到多个子进程，子进程构成链表； 可以从系统的任何进程出发，查找到任意指定的其它进程； 进程创建产生进程的机制：新的地址空间创建进程，读入可执行文件，最后开始执行。 进程和可执行文件的关系是什么？我的理解是，进程是Linux的任务，执行文件是实体。 forkfork的作用是创建进程，子进程和父进程的区别在于PID、PPID以及某些资源和统计量； exec的作用是读取可执行文件载入地址空间执行； COW，即写时复制，父子进程对资源进行只读共享，只有在写入时才对页复制； fork的开销：复制父子进程的页表以及给子进程创建唯一的进程描述符； 12345678fork() \ _\|vfork() ---&gt; clone() ---&gt; do_fork() ---&gt; copy_process() _ /| /__clone() copy_process： 调用dup_task_struct()，为新进程创建一个内核栈、thread_info以及task_struct，父子进程的这些值以及描述符都是相同的； 资源限制检查； 更改某些资源和统计量，父子进程开始彼此区分； 设置进程态：TASK_UNINTERRUPTIBLE； 一些标志位的设定； 为新进程分配有效PID； 根据传递给clone()的标志位，要么复制要么共享资源，公共的就共享，独有的就复制到该处； 做一些进程创建的收尾工作，返回指向新进程的指针； 子进程优先开始的目的是让其先执行exec()，避免写时复制的开销，是一种优化(这个复制开销可能指的是父进程写入)。 vfork()vfork()和fork()有相同的功效，但和fork主要有两点区别： 不复制父进程页表； 父进程会阻塞直到子进程执行exec()或者调用_exit()。 通常来说除非给性能带来重大提升，否则一般避免使用此调用。 线程实现Linux中，线程被视为一个与其它进程共享某些资源(地址空间)的进程； 创建方式和fork()差不多，但是会通过标志位来决定共享资源的种类； 内核进程： 内核进行的后台操作通过内核线程完成，内核线程独立运行在内核空间，它和普通进程间的区别是没有独立的地址空间，不会将上下文切换至用户空间； 后续章节还会讨论这个概念。 进程终结进程终结将释放资源并通知父进程。 终结的方式通常有： 显式调用exit()； 隐式调用exit()； 遇到不能处理也不能忽略的信号或异常； exit()主要靠do_exit()代码： 设置task_struct标志位为PF_EXITING； 删除内核定时器； 若开启了记账功能，调用相关方法输出记账； 调用exit_mm()释放mm_struct； 调用sem__exit()，如果进程进队是等候IPC信号，则出队； 调用exit_files()和exit_fs()来递减相关资源的引用计数，计数为0就释放资源； 设置退出代码，供父进程检索； exit_notify()发信号给父进程，然后寻找养父，养父为线程组其它线程活着init进程，然后把子进程的退出状态设置为EXIT_ZOMBIE； do_exit调用schedule()，因为处于僵尸状态所以这是进程所执行的最后一段代码； 处于僵尸状态的进程还占用内核栈、thread_info以及task_struct，目的是给父类提供信息，父类检索后或者通知内核后，释放最后的资源。 最后的资源主要由进程描述符以及其相关结构组成，父进程调用wait()然后被挂起，直到它的一个子进程退出，然后会返回该子进程的PID，不仅如此，一个指针被提供给该函数，返回时会持有子进程的退出码。最终的释放还会调用release_task()。 当然上面还可能会遇到一种问题，那就是父进程在子进程之前就退出了，这就涉及到上面列举的第8步，寻找养父，不然就是孤儿进程永远处在僵尸状态不能释放。找到养父后就同上，调用wait()检查子进程，清除其中的僵尸进程。 补充进程的布局逻辑划分如下(也称段)： 文本：程序指令； 数据：程序使用的静态变量； 堆：程序可从该区域动态分配额外内存； 栈：随函数调用； 以上可以类比Java线程的组成结构。 fork之后的竞态条件前文提到了“子进程优先开始的目的是让其先执行exec()”，为什么子进程优先执行exec()会避免无谓的复制和开销？ 这要从子进程的执行说起。当fork出子进程后，常常会去执行和父进程共享代码段的另一组不同函数，在Redis源码中就出现过；另一种常见的情况是使用系统调用exec()去加载全新的程序，exec()会销毁现有的文本、数据、堆以及栈，建立新的堆栈页。 父进程在fork()之后继续修改数据页和栈页，那么如果父进程先执行，内核就要为子进程复制那些“将要修改”的页。而先调度子进程，它会立即执行exec()，当下一次调度到父进程的时候，就无需复制内存页了。 不过在Linux2.6.32又改成父进程先执行，因为父进程在CPU处于活跃状态，并且内存管理信息也被置于内存管理单元的转译后背缓冲器(TLB)，所以线运行父进程可以提高性能。 其实这两种策略性能差异很小，对大部分应用程序几无影响。 小结本文是对《Linux内核设计与实现》一书第三章所做的笔记，主要探究了Linux进程的生命周期，并对一些内容进行了补充。 为什么vfork会存在子进程有新地址空间的说法？地址空间不共享吗？毕竟写时复制时“内核此时并不复制整个进程地址空间”？关于地址空间的理解会在后续文章展开。 问题书中写道”If Linux one day gains copy-on-write page table entries, there will no longer be any benefit”，这句话感觉有歧义也不好理解，fork不是已经提供了这一功能么？ 参考《Linux内核设计与实现(第三版)》 《Linux Kernel Development, 3rd Edition》 《Linux_UNIX系统编程手册(上)》]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小猪快跑，算法快刷(第一部分)]]></title>
    <url>%2F2018%2F09%2F23%2FJZOffer01%2F</url>
    <content type="text"><![CDATA[本篇是快刷《剑指Offer》的第一部分，涉及22道基础习题。 在文章的编排上，本人将每两道题目关联于一个球员名，这样做的目的是为了方便查询。第一部分选取的球员全部来自早些年的巴塞罗那俱乐部，他们未必曾经在同一时期的巴萨效力，但是却是本人在当时进行足球游戏的主力，这些球员名在本人的大脑查询的时间复杂度是O(1)。 梅西123梅西 -&gt; 第一个只出现一次的字符 \ -&gt; 连续子数组的最大和 第一个只出现一次的字符这一题的关键在于字符换算为int类型，既有限，又有界。所以可以用一个最大界作为长度声明一个数组。这个数组相当于一个哈希表，将char字符转换为int类型相当于构造的一个index方法，每个槽位不再保存链表的头节点，而是保存index()到相同位置的元素的个数。 考虑鲁棒性应该进行判空指针操作，char默认’\u0000’，等价于(char)0。 连续子数组的最大和这一题的关键在于用两个零时变量分别来记录当前数组和的值以及历史最大和的值，每当前进一个数，就要试着更新这两个零时变量。 同样需要进行判空指针的操作。 罗纳尔迪尼奥123罗纳尔迪尼奥 -&gt; 数组中只出现一次的数字 \ -&gt; 数字在排序数组中出现的次数 数组中只出现一次的数字首先要了解题目给的条件，条件说一个整型数组里，除了两个数字，其它数字都出现了两次。要求时间复杂度是O(n)，空间复杂度是O(1)。 所以不能用梅西(1)题那种思路，因为这里的数字即无限，也无界。但是它奇怪的地方在于，不要求检出的数字都出现两次，所以可以考虑用异或运算。 比如现在有三个数：2，4，2。如果对它们进行异或，那么2^4^2返回的是4，所以如果将数组中所有的数字都异或一遍，最后输出就是两个只出现一次的数字异或的值。 两个数异或之后，相同位都是0，不相同位都是1，实际上不相同位可能有很多，但其实只需要观察一个位置，将这个位置称为不同位，这个位置如果再分别和这两个数异或，会出现不同的结果。 于是继续将第一遍异或的结果与整数数组的数字异或，观察上一步提到的不同位。由于大部分数字会再一次算两遍彼此“中和”，所以最后的得到的就是两个要求的数字。 数字在排序数组中出现的次数题目可以简单描述为：已知一个排序数组，然后给出一个数字，输出该数字在数组中出现的次数。这题为了减小时间复杂度，可以先计算出给出的数字第一次出现在数组的索引，然后计算出最后一次出现在数组的索引，这样，最后只需要相减就可以了。 埃托奥123埃托奥 -&gt; 两个链表的第一个公共节点 \ -&gt; 最长不含重复字符的子字符串 两个链表的第一个公共节点这个题目主要的问题是两个链表长度不一样，这样的话遍历的时候不好同步，解决的方式是让长度长的链表先“走两步”。这样能成功主要是利用了公共节点存在的特性，即公共节点在“Y”形交叉点往下就都是相同的部分了，只要两个链表遍历的起点到尾节点的距离相同，那么一旦进入“Y”形交叉点。两个链表就完全同步了。 最长不含重复字符的子字符串这题的意思是输入一个字符串，求其最长不含重复字符的子字符串的长度。单从描述上来看，此题和连续子数组的最大和类似，而组成输入字符串的字符既有限，又有界，看来可以使用哈希表来解。与第一个只出现一次的字符不同的是，这里哈希表不需要保存字符出现的次数，而是保存在字符串中出现位置的索引(实际编码过程中，因为int数组的元素默认为0，所以对保存的索引稍微进行改动)。 哈维123哈维 -&gt; 二叉树的深度 &amp;&amp; 输入二叉树的根节点，判断该树是不是平衡二叉树 \ -&gt; 把字符串转换成整数 二叉树的深度 &amp;&amp; 输入二叉树的根节点，判断该树是不是平衡二叉树树的深度用递归特别容易解决，要记得考虑根节点为null时，要返回0，这不仅为程序提供鲁棒性，还是递归的一个基础，通常来说，采用递归函数，要考虑是否产生调用栈爆棚以及是否进行了重复计算。 在判断一个二叉树是不是平衡二叉树时，可以先递归计算二叉树的深度，在计算中，设置一个全局标志位flag，起初值为true，然后添加代码判断左右深度差的绝对值是不是大于1，大于1表示不平衡，那就将flag设为false，递归的过程中只要有一次判断为false，那么flag就始终为false了，这也是为什么一开始将标志位设置为true的原因。 把字符串转换成整数可以不断遍历字符串的每一位进行转换。这里要注意正负号的判断，正号可以强写，也可以不写，将判断是否有正负字符的存在和判断数字是正是负两个功能分别处理，方便厘清逻辑。 伊涅斯塔123伊涅斯塔 -&gt; 二叉树的镜像 \ -&gt; 二叉搜索树与双向链表 二叉树镜像用递归就能解决问题，在递归子树之前会调用swap函数，该函数的计算不是一个重复计算。 二叉搜索树与双向链表该题的要求是，不能创建任何新的节点，将二叉搜索树转换成一个排序的双向链表。在二叉搜索树中提到“排序”，首先想到的就是中序遍历，在递归中遵循“递归函数 -&gt; 根 -&gt; 函数”的模式。在函数之外设置两个参数head和tail，分别指向已经遍历出的链表解构的头节点和尾节点。在整个递归中，真正对head进行赋值只有一次，而通过不断向下递归，这个head最终指向的是搜索树中值最小的那个点。 难点在理解右子树和根节点的连接，实际在不停向下递归右子树的时候(convertNode(root.right))，最开始操作的是右子树中值最小的节点，该节点没有左子树，执行如下代码： 123tail.right = root;root.left = tail;tail = root; 因为此时tail就是根节点，所以通过上面的代码根节点就和右子树值最小的节点产生了双向连接。 德科123德科 -&gt; 二叉搜索树的第K个节点 \ -&gt; 从上往下打印二叉树 二叉搜索树的第K个节点递归中找准“全局变量”，对于全体递归中的单次实体，“全局变量”是有记忆的，是被共享的。所以k应该是一个“全局变量”，递归中不断增加的计数值也应该是一个“全局变量”。 从上往下打印二叉树这题的要求是层次遍历，使用队列来实现，要考虑边界问题。 阿比达尔123阿比达尔 -&gt; 二叉树中和为某一值的路径 \ -&gt; 从尾到头打印链表 二叉树中和为某一值的路径这题要求打印所有满足条件的路径，所以需要装列表的容器：List]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Java Concurrency in Practice》学习总结(Part I)]]></title>
    <url>%2F2018%2F09%2F17%2FJCIP%2F</url>
    <content type="text"><![CDATA[《Java Concurrency in Practice》的前言已经写明了如何使用这本书：提供一个简化的并发程序编写规则，使开发人员无须掌握Java内存模型底层细节就能编写正确的并发程序。而该书的第一部分(Part I)就介绍了其中最重要的一些规则。下面来列出这一部分各章节的主要内容： 第二、三章：给出了几乎所有用于避免并发危险、构造线程安全的类以及验证线程安全的规则； 第四章：介绍如何将一些小的线程安全类组合成更大的线程安全类； 第五章：介绍了在平台库中提供的一些基础的并发构建模块，包括线程安全的容器类和同步工具类； 其中关于发布逸出、安全发布、线程安全类添加功能、构建高效且可伸缩的结果内存等内容让人醍醐灌顶，本篇将对这些进行笔记。 第一章 简介简要介绍了并发历史、线程优势、线程风险以及线程应用。 线程风险 安全性问题：存在竞态条件，线程无法预料数据变化所产生的错误； 活跃性问题：死锁、饥饿、活锁； 性能问题：保存恢复线程执行的上下文、CPU时间花费在调度上、同步机制会清空锁定内存和高速缓存并在共享内存总线创建同步通信； 安全性含义是“不能错”，活跃性是“正确事的最终会发生”，性能说的则是“正确的事更好更快的发生”。 第二章 线程安全编写安全代码的本质：管理对状态的访问，而且通常是共享、可变的状态； 共享：变量被多个线程访问； 可变：变量的值在生命周期内可变； 访问同一可变状态的变量没有使用合适的同步而出现了错误，修复的方式： 不在线程间共享该状态变量； 状态变量修改为不可变变量； 访问状态变量时使用同步； 编写并发应用程序时，一种正确的编程方法：首先使代码正确运行，然后再提高代码的速度； 线程安全性：当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的； 无状态对象一定是线程安全的； 多个线程交替执行时序时，会发生竞态条件，最常见的竞态条件是“先检查后执行”操作； “重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”，这与pthread(POSIX线程)互斥体默认加锁行为不同，后者是以“调用”为粒度； 如果持有锁的时间过长，就会带来活跃性和性能的问题，比如执行中会有I/O操作，那么一定不要持有锁； 第三章 对象的共享当前大多数架构中，读取volatile变量的开销只比读取非volatile变量的开销略高一点； 逸出：当某个不应该发布的对象被发布时，这种状况就被称为逸出； 发布对象的最简单方法：将对象的引用保存在一个公有的静态变量中，以便任何类和线程都能看到该对象； 当发布一个对象时，对该对象的非私有域中引用的所有对象同样会被发布； 不要在构造过程中使this引用逸出； 构造过程中使this引用逸出的错误有： 构造函数中启动一个线程； 在构造函数中调用可被改写的实例方法； 这里用代码解释在构造函数中调用可被改写的实例方法： 12345678910111213141516171819public class ThisEscape &#123; private final int i; public ThisEscape(EventSource source) &#123; source.registerListener( new EventListener() &#123; public void onEvent(Event e) &#123; doSomething(e); &#125; &#125; ); i = 7; &#125; // result can be 0 or 10 int doSomething(Event e) &#123; return i; &#125;&#125; 在构造函数中注册一个监听器来监听事件，doSomething()是内部类触发事件调用的外围类的实例方法，所以存在外围类this逸出的错误，当监听器监听到事件并最终调用doSomething(e)的时候，外部类可能还没有完全构造。 解决此错误的方法：使用工厂方法。具体代码如下： 1234567891011121314151617public class SafeListener &#123; private final EventListener listener; private SafeListener() &#123; listener = new EventListener() &#123; public void onEvent(Event e) &#123; doSomething(e); &#125; &#125;; &#125; public static SafeListener newInstance(EventSource source) &#123; SafeListener safe = new SafeListener(); source.registerListener(safe.listener); return safe; &#125;&#125; 这里之所以可以避免在构造函数中出现this逸出，是因为final能确保初始化的过程的安全性。 栈封闭只能通过局部变量才能访问对象，比Ad-hoc线程封闭更易于维护，也更加健壮； 某个对象在创建后状态就不能被更改，那么这个对象就称为不可变对象； 不可变对象一定是线程安全的； 除非需要某个域是可变的，否则将其声明为final是一个良好的编程习惯； 安全发布手边的童云兰版对英文版3.5.3小节部分内容的翻译与原意有出入，这里先放上英文原文： 这里无非是要处理对象修改状态对其它线程的可见性问题： 首先可以通过静态初始化器初始化对象的引用(翻译版翻译为“在静态初始化函数中初始化一个对象引用”)； 在此之后可以通过三种方式将对象的引用保存，属于选择关系，而不是分步串行，即： 要么保存在volatile字段或者原子引用中； 要么保存在可以正确构造对象的final字段中； 要么保存在加了锁的字段中； 《深入理解Java虚拟机》一书已经介绍了静态字段初始化的时机，这里需要强调的是，JVM内部存在同步机制，所以通过静态初始化器初始化对象的引用可以被安全的发布。 第四章 对象的组合本章主要是介绍一些构造类的模式，将线程安全的组件安全的组合成更大的组件或程序。 如果一个对象的域引用了其它对象，那么它的状态也同时包含被引用对象的域，比如一些容器类； 实例限制被限制的对象一定不能逸出到它期望可用的范围之外，可以把对象限制在类实例(私有类成员)、lexical scope(比如本地变量)或线程(比如对象从线程内的一个方法传递给另一个方法，但不支持跨线程分享)； 限制性使构造线程安全的类变得更容易，因为类的状态被限制后，分析它的线程安全性时，就不必检查完整的程序； Java监视器模式遵循Java监视器模式的对象会把对象的所有可变状态都封装起来，并由对象自己的内置锁来保护； 使用私有锁对象而不是对象的内置锁(或任何可以被公共访问的锁)有许多优点； 在现有线程安全类中添加功能要添加一个新的原子操作，最安全的方法是修改原始的类，“but this is not always possible because you may not have access to the source code or may not be free to modify it. ”； 另外的方法是extend the class，“but not all classes expose enough of their state to subclasses to admit this approach. ” 第三种策略是扩展类的功能，但并不扩展类本身，而是将扩展类放在一个“辅助类”中； 这种方法常常会出现在错误的锁上进行同步的问题，例如： 1234567891011public class ListHelper&lt;E&gt; &#123; public List&lt;E&gt; list = ...; public synchronized boolean putIfAbsent(E x) &#123; boolean absent = !list.contains(x); if (absent) &#123; list.add(x); &#125; return absent; &#125;&#125; 该代码不能达到线程安全性的原因就是没有对list对象的monitor锁进行同步，修改的方式是添加synchronized (list)，但这种方法比之前的方法更脆弱，因为将加锁的代码放到了无关的地方； 第四种：组合，这是一种更好的方法； 第五章 基础构建模块本章主要是涵盖了最有用的并发构建块，特别是Java 5.0和Java 6引入的，以及它们构造并发程序时用到的一些模式。 本章首先要注意区分同步容器和并发容器的区别； 容器复合操作包括：迭代、导航(根据顺序寻找下一个元素)以及条件运算(put-if-absent)，通常情况下这些复合操作即便没有客户端加锁保护，也是线程安全的，但是当其它线程能够并发修改容器的时候，就会产生线程安全问题； 通过for迭代的时候，如果并发进行删除操作，可能会抛出数组越界异常，通过客户端加锁解决该问题，会使程序牺牲伸缩性，比如没有进行删除操作，仍然要去获取锁增加开销；同时，这样做也会造成for迭代的时候其它线程无法访问，降低了并发性； 用Iterator迭代的过程如果发生了修改操作会抛出ConcurrentModificationException异常，如果不想采用客户端加锁来解决，则可以采用克隆容器在副本上迭代的方法，采用该方法同样要考虑性能； 隐藏迭代器：一个容器作为另一个容器的元素或者键值，就要注意可能发生的隐藏迭代操作，包括调用hashCode()和equals()等，甚至是toString()； 同步容器通过将容器状态的访问串行化来实现线程安全； 通过并发容器来替代同步容器，可以极大的提高伸缩性并降低风险； 关于ConcurrentHashMap将会单独进行源码分析； ConcurrentHashMap不能加锁独占访问，所以可以采用ConcurrentMap接口； 关于JUC提供的队列将单独进行源码分析； 构建高效且可伸缩的结果缓存就是实现并发下的享元模式。 首先，使用HashMap组合加锁的方式，并发效率非常低，因为每次只有一个线程能够执行compute()，相当于为了同步而串行： 由图可见，纵向每次只有一个线程在执行。 改进的方法是将HashMap替换为ConcurrentHashMap，考虑下图这种情形： 在图中当线程A正在执行compute f(1)的时候，线程B发现缓存不中，就也开始调用compute f(1)，如此这般最终相当于计算了两次。而且还要看具体的应用场景，有些场景只要求缓存对象初始化一次，那么这就产生了安全风险。 继续方法改进，增加FutureTask，这样当上图中B线程查找f(1)的值时，会发现f(1)的Future，从而不会认为缓存不中，但是此时会遇到新的问题，如下图： A线程检测到f(1)没有在缓存，于是开始put Future for f(1)，在成功之前，线程B也检测到f(1)没有在缓存，于是也开始put Future for f(1)。这是“检测再运行”带来的重复计算的问题。 改进的方法是利用ConcurrentMap，该接口提供了原子操作putIfAbsent()，最终代码如下： 12345678910111213141516171819202122232425262728293031public class Memoizer&lt;A, V&gt; implements Computable&lt;A, V&gt; &#123; private final ConcurrentMap&lt;A, Future&lt;V&gt;&gt; cache = new ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;(); private final Computable&lt;A, V&gt; c; public Memoizer(Computable&lt;A, V&gt; c) &#123; this.c = c; &#125; public V compute(final A arg) throws InterruptedException &#123; while (true) &#123; Future&lt;V&gt; f = cache.get(arg); if (f == null) &#123; Callable&lt;V&gt; eval = new Callable&lt;V&gt;() &#123; public V call() throws InterruptedException &#123; return c.compute(arg); &#125; &#125;; FutureTask&lt;V&gt; ft = new FutureTask&lt;V&gt;(eval); f = cache.putIfAbsent(arg, ft); if (f == null) &#123; f = ft; ft.run(); &#125; &#125; try &#123; return f.get(); &#125; catch (CancellationException e) &#123; cache.remove(arg, f); &#125; catch (ExecutionException e) &#123; throw launderThrowable(e.getCause()); &#125; &#125; &#125;&#125; 代码中的异常处理用来应对缓存污染，考虑了计算被取消或者失败的情形。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis享知享学：RDB原理解析]]></title>
    <url>%2F2018%2F09%2F13%2FRedis_RDB%2F</url>
    <content type="text"><![CDATA[本篇将聚焦RDB的基本工作原理。 父子进程是如何执行代码的？server.dirty_before_bgsave的作用是什么？走进这篇文章，慢慢走近这些问题的答案。 RDB是Redis提供的基于快照存储的持久化模式，核心包括保存和载入两个功能，先来看看保存功能的实现。 rdbSave保存是rdbSave()提供的，这个方法有点长，但并不复杂，主要功能如下： 创建临时文件，保存的过程中会先创建一个临时文件； 写入文件前的准备工作，包括初始化IO、设置校验、写入版本号等； 遍历数据库，写入临时文件； 将临时文件覆盖原RDB文件； 做好“善后工作”，比如考虑程序的鲁棒性，对各种可能情况设置好处理方法，并且保存/清除各种需要/不需要的数据，关闭打开的文件等等； 看看第三步中是怎么写入临时文件的： 123456789101112131415161718/* Iterate this DB writing every entry * * 遍历数据库，并写入每个键值对的数据 */while((de = dictNext(di)) != NULL) &#123; sds keystr = dictGetKey(de); robj key, *o = dictGetVal(de); long long expire; // 根据 keystr ，在栈中创建一个 key 对象 initStaticStringObject(key,keystr); // 获取键的过期时间 expire = getExpire(db,&amp;key); // 保存键值对数据 if (rdbSaveKeyValuePair(&amp;rdb,&amp;key,o,expire,now) == -1) goto werr;&#125; di是迭代器，de是字典迭代过程中哈希表内的实体，保存着字典真正存储的键值对。因为字典的键都是Redis的字符串形式，所以需要一个initStaticStringObject转换一下，最后调用rdbSaveKeyValuePair函数： 12345678910111213141516171819202122232425262728int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, long long expiretime, long long now)&#123; /* Save the expire time * * 保存键的过期时间 */ if (expiretime != -1) &#123; /* If this key is already expired skip it * * 不写入已经过期的键 */ if (expiretime &lt; now) return 0; if (rdbSaveType(rdb,REDIS_RDB_OPCODE_EXPIRETIME_MS) == -1) return -1; if (rdbSaveMillisecondTime(rdb,expiretime) == -1) return -1; &#125; /* Save type, key, value * * 保存类型，键，值 */ if (rdbSaveObjectType(rdb,val) == -1) return -1; if (rdbSaveStringObject(rdb,key) == -1) return -1; if (rdbSaveObject(rdb,val) == -1) return -1; return 1;&#125; 可见它保存了过期时间、类型、键以及值，已经在此刻过期的键就不会保存。 在Redis中，可能调用rdbSave的命令包括flushallCommand、debugCommand、rdbSaveBackground、saveCommand、prepareForShutdown。下面就来研究直接保存和后台保存命令的实现。 save &amp;&amp; bgsavesave首先看看save，Redis会调用saveCommand函数，它的全部代码： 12345678910111213141516void saveCommand(redisClient *c) &#123; // BGSAVE 已经在执行中，不能再执行 SAVE // 否则将产生竞争条件 if (server.rdb_child_pid != -1) &#123; addReplyError(c,"Background save already in progress"); return; &#125; // 执行 if (rdbSave(server.rdb_filename) == REDIS_OK) &#123; addReply(c,shared.ok); &#125; else &#123; addReply(c,shared.err); &#125;&#125; 所以save不是任何时刻都可以执行成功，server.rdb_child_pid不等于-1说明存在执行bgsave的子进程，此时saveCommand()会直接返回。 从上面的代码可以看出，saveCommand()基本上就是简单封装了rdbSave函数。 bgsave再来看看bgsave，Redis会调用bgsaveCommand函数： 123456789101112131415161718void bgsaveCommand(redisClient *c) &#123; // 不能重复执行 BGSAVE if (server.rdb_child_pid != -1) &#123; addReplyError(c,"Background save already in progress"); // 不能在 BGREWRITEAOF 正在运行时执行 &#125; else if (server.aof_child_pid != -1) &#123; addReplyError(c,"Can't BGSAVE while AOF log rewriting is in progress"); // 执行 BGSAVE &#125; else if (rdbSaveBackground(server.rdb_filename) == REDIS_OK) &#123; addReplyStatus(c,"Background saving started"); &#125; else &#123; addReply(c,shared.err); &#125;&#125; 除了不能重复执行，也不能在aof子进程存在的时候执行。具体核心代码又封装在rdbSaveBackground()中，代码直接贴出： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int rdbSaveBackground(char *filename) &#123; pid_t childpid; long long start; if (server.rdb_child_pid != -1) return REDIS_ERR; // 记录后台保存前服务器状态 server.dirty_before_bgsave = server.dirty; // 开始时间 start = ustime(); // 创建子进程 if ((childpid = fork()) == 0) &#123; int retval; /* Child */ // 子进程不接收网络数据 if (server.ipfd &gt; 0) close(server.ipfd); if (server.sofd &gt; 0) close(server.sofd); // 保存数据 retval = rdbSave(filename); if (retval == REDIS_OK) &#123; size_t private_dirty = zmalloc_get_private_dirty(); if (private_dirty) &#123; redisLog(REDIS_NOTICE, "RDB: %lu MB of memory used by copy-on-write", private_dirty/(1024*1024)); &#125; &#125; // 退出子进程 exitFromChild((retval == REDIS_OK) ? 0 : 1); &#125; else &#123; /* Parent */ // 记录最后一次 fork 的时间 server.stat_fork_time = ustime()-start; // 创建子进程失败时进行错误报告 if (childpid == -1) &#123; redisLog(REDIS_WARNING,"Can't save in background: fork: %s", strerror(errno)); return REDIS_ERR; &#125; redisLog(REDIS_NOTICE,"Background saving started by pid %d",childpid); // 记录保存开始的时间 server.rdb_save_time_start = time(NULL); // 记录子进程的 id server.rdb_child_pid = childpid; // 在执行时关闭对数据库的 rehash // 避免 copy-on-write updateDictResizePolicy(); return REDIS_OK; &#125; return REDIS_OK; /* unreached */&#125; 调用fork()会创建新的进程，有三种情况： fork()如果创建子进程成功，会返回0给子进程； fork()如果创建子进程成功，会返回子进程的pid号给父进程； fork()执行发生错误，会返回-1(此时创建新的进程失败，也就无所谓父进程子进程，返回给当前进程)； 一旦childpid = fork()创建子进程成功，则从这个地方开始，将有父子两个进程同时向下按各自逻辑执行代码，下面考虑这种情况下的父子进程的情况： —–子进程—– 对子进程来说，由于fork()返回了0给它，它会执行从上向下数第二个if语句的内容，断掉该进程的网络连接进而不接受新进的数据，调用rdbSave()进行存储，当它执行到exitFromChild()，内部通过_exit()就结束进程。 —–父进程—– 由于fork()会返回子进程的pid给父进程，所以父进程不会执行第二个if语句中的内容，它会向下执行else中的内容，进行一些日志记录啦，打印一些可能发生的错误报告啦等等，最后返回REDIS_OK。 Redis通过RDB进行持久化的保存功能基本解析完毕了，现在的问题是，bgsave命令执行后，后台保存是一个间断性实施的过程，这个功能如何实现的？ 服务器的dirtyserver.dirty用来记录更改过却没有被持久化的键的个数。 rdbSaveBackground()在子进程创建之前执行server.dirty_before_bgsave = server.dirty;，是因为一旦子进程创建之后，由于dirty在父进程和子进程中都会被更改，而它更改后的值分别保存在各自进程拷贝的内存页中，所以要在之前记录一个dirty的锚点，方便后续使用。在之前的文章中，本人提到了操作系统的写时复制(COW)，Redis在这方面利用了操作系统的写时复制机制，下一篇文章将进一步阐述原理，这里只需要暂时知道，在dirty更改前，两个进程的dirty指针指向同一内存地址，一旦变更，那么父进程的dirty不再是子进程的dirty了。 试想，在子进程保存数据的时候中，父进程仍然可能在不停更改数据，即使本次子进程保存数据成功，仍然需要计算之后父进程更新了多少数据，通过判断更新的量是否达到设定的阈值，来触发后台周期性保存功能，进行新的数据保存。更新了多少数据可以通过下面的代码完成： 1server.dirty = server.dirty - server.dirty_before_bgsave; 为了后续行文指代的方便，将这段代码称为D代码，D存在于backgroundSaveDoneHandler()当中，并且，D应该在下一次调用rdbSaveBackground()之前执行。 在Redis中serverCron函数每隔一段时间就会执行一次，而backgroundSaveDoneHandler()就包含于其中，来看看包含它的关键的一段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041if (server.rdb_child_pid != -1 || server.aof_child_pid != -1) &#123; int statloc; pid_t pid; if ((pid = wait3(&amp;statloc,WNOHANG,NULL)) != 0) &#123; int exitcode = WEXITSTATUS(statloc); int bysignal = 0; if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc); if (pid == server.rdb_child_pid) &#123; backgroundSaveDoneHandler(exitcode,bysignal); &#125; else if (pid == server.aof_child_pid) &#123; backgroundRewriteDoneHandler(exitcode,bysignal); &#125; else &#123; redisLog(REDIS_WARNING, "Warning, detected child with unmatched pid: %ld", (long)pid); &#125; // 如果 BGSAVE 和 BGREWRITEAOF 都已经完成，那么重新开始 REHASH updateDictResizePolicy(); &#125;&#125; else &#123; /* If there is not a background saving/rewrite in progress check if * we have to save/rewrite now */ // 如果有需要，开始 RDB 文件的保存 for (j = 0; j &lt; server.saveparamslen; j++) &#123; struct saveparam *sp = server.saveparams+j; if (server.dirty &gt;= sp-&gt;changes &amp;&amp; server.unixtime-server.lastsave &gt; sp-&gt;seconds) &#123; redisLog(REDIS_NOTICE,"%d changes in %d seconds. Saving...", sp-&gt;changes, sp-&gt;seconds); rdbSaveBackground(server.rdb_filename); break; &#125; &#125;...&#125; 在最后一个for循环里，当数据更新的数目和距离上一次保存的时间均大于设定的数目以及设定的时间时，程序将执行rdbSaveBackground函数，又一次后台保存数据。 一开始本人疑惑的是，如果子进程需要保存的数据量很小且执行的速度非常快，那么执行完毕需要的时间就会小于serverCron()调用的间隔时间，在暂时不考虑AOF的情况下，if (server.rdb_child_pid != -1 || server.aof_child_pid != -1)括号内总是返回false，程序就会跳转到else语句去执行最后一个for循环，rdbSaveBackground()就有可能在D代码之前执行。 后来才发现，server.rdb_child_pid != -1并不代表子进程真的在执行，rdb_child_pid属性的更改回-1的状态并不是在子进程结束后马上发生的： 在rdbSaveBackground()中，父进程在从函数返回之前会执行server.rdb_child_pid = childpid;，将rdb_child_pid属性属性设置为非-1状态； 在backgroundSaveDoneHandler()中，在D代码执行之后，会通过server.rdb_child_pid = -1;将rdb_child_pid属性属性设置为-1状态(D代码未执行表示子进程未保存成功，那么此时也应该将rdb_child_pid属性设置为-1)； 如此程序保证了在上一次进程对数据保存成功的情况下，D代码一定会在下一次调用rdbSaveBackground()之前执行。 rdbLoadRedis的main()会调用loadDataFromDisk()，而loadDataFromDisk()会调用rdbLoad，调用方式如下： 123456789101112131415161718void loadDataFromDisk(void) &#123; long long start = ustime(); // 如果开启了 AOF 功能，那么优先使用 AOF 文件来还原数据 if (server.aof_state == REDIS_AOF_ON) &#123; if (loadAppendOnlyFile(server.aof_filename) == REDIS_OK) redisLog(REDIS_NOTICE,"DB loaded from append only file: %.3f seconds",(float)(ustime()-start)/1000000); &#125; else &#123; // 在没有开启 AOF 功能时，才使用 RDB 来还原 if (rdbLoad(server.rdb_filename) == REDIS_OK) &#123; redisLog(REDIS_NOTICE,"DB loaded from disk: %.3f seconds", (float)(ustime()-start)/1000000); &#125; else if (errno != ENOENT) &#123; redisLog(REDIS_WARNING,"Fatal error loading the DB. Exiting."); exit(1); &#125; &#125;&#125; 从这段代码可以看出，一旦打开了AOF功能，那么程序优先使用AOF还原数据。 rdbLoad()在加载的过程中，会安插如下代码： 12345678/* Serve the clients from time to time */// 间隔性服务客户端if (!(loops++ % 1000)) &#123; // 刷新载入进程信息 loadingProgress(rioTell(&amp;rdb)); // 处理事件 aeProcessEvents(server.el, AE_FILE_EVENTS|AE_DONT_WAIT);&#125; 每次读取一个键的信息，每读取1000次刷新载入进程信息，处理其它的请求。 小结通过本文的解析，了解了RDB保存和载入的基本原理，对其中一些实现细节有大致的掌握。RDB在后台保存时会利用操作系统写时复制机制，不至于在内存中完整复制一份要保存的数据，从而减少开销，下一篇将重点了解此机制。 参考Redis 设计与实现：国内解析Redis的开源资料； 附录上文rdbSaveBackground()代码中，zmalloc_get_private_dirty实际返回0，该方法可能用于日志功能的扩展： 123size_t zmalloc_get_private_dirty(void) &#123; return 0;&#125;]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>C</tag>
        <tag>Redis</tag>
        <tag>RDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis享知享学：单机数据库实现：watched_keys和id属性]]></title>
    <url>%2F2018%2F09%2F11%2FRedis_Db04%2F</url>
    <content type="text"><![CDATA[关于Redis单机数据库的实现，就要接近尾声，本篇将解析剩下的属性watched_keys和id。 watch命令能在事务开启后执行吗？watch后，事务失败与否，对于一个key需要重新watch么？本篇文章将尝试给出解答。 watched_keys和之前解析的属性一样，watched_keys仍然是一个字典，它的出现是为了实现Redis事务的相关功能。 考虑这样一个例子： 123456789101112131415// 客户端01：redis 127.0.0.1:6379&gt; watch cgrwOKredis 127.0.0.1:6379&gt; multiOKredis 127.0.0.1:6379&gt; set cgrw cg01QUEUED// 客户端02：redis 127.0.0.1:6379&gt; set cgrw cg02OK// 继续客户端01：redis 127.0.0.1:6379&gt; exec(nil) 客户端01在multi之前，watch了cgrw，之后设置了cgrw；如果在客户端01执行exec之前，客户端02又设置了cgrw，此时再在客户端执行exec，只会返回空。也就是说，通过watch命令，可以保证事务的安全性。 watch触发准备数据库中的watched_keys扮演了什么角色呢？ 形式上，它和blocking_keys属性一样，一个键对应一个链表，两者构成一个键值对并添加到字典，链表里都是watch了这个键的客户端。 watch命令会调用watchCommand()，底层实现的是watchForKey函数，该函数内数据库负责的部分： 1234567891011// key 未被监视// 根据 key ，将客户端加入到 DB 的监视 key 字典中/* This key is not already watched in this DB. Let's add it */// O(1)clients = dictFetchValue(c-&gt;db-&gt;watched_keys,key);if (!clients) &#123; clients = listCreate(); dictAdd(c-&gt;db-&gt;watched_keys,key,clients); incrRefCount(key);&#125;listAddNodeTail(clients,c); 和之前解析blocking_keys相关的部分异曲同工：无则创建链表，有则添加进链表。 同时上篇类似，客户端存在一个watched_keys的同名属性，它的表元素记录key和db，在watchForKey()中还会执行： 123456789watchedKey *wk;...wk = zmalloc(sizeof(*wk));wk-&gt;key = key;wk-&gt;db = c-&gt;db;incrRefCount(key);listAddNodeTail(c-&gt;watched_keys,wk); watchedKey可以类比readyList，上一篇已经很详细，就不从头赘述相关代码。 有一点提一下，在watchCommand()内： 12345// 不能在事务中使用if (c-&gt;flags &amp; REDIS_MULTI) &#123; addReplyError(c,"WATCH inside MULTI is not allowed"); return;&#125; 这解释了为什么watch不能在事务中调用。 watch触发触发源于对touchWatchedKey()的调用： 1234567891011121314151617181920212223void touchWatchedKey(redisDb *db, robj *key) &#123; list *clients; listIter li; listNode *ln; // 如果数据库中没有任何 key 被监视，那么直接返回 if (dictSize(db-&gt;watched_keys) == 0) return; // 取出数据库中所有监视给定 key 的客户端 clients = dictFetchValue(db-&gt;watched_keys, key); if (!clients) return; /* Mark all the clients watching this key as REDIS_DIRTY_CAS */ /* Check if we are already watching for this key */ // 打开所有监视这个 key 的客户端的 REDIS_DIRTY_CAS 状态 // O(N) listRewind(clients,&amp;li); while((ln = listNext(&amp;li))) &#123; redisClient *c = listNodeValue(ln); c-&gt;flags |= REDIS_DIRTY_CAS; &#125;&#125; 前半部分没什么可说的，后面是遍历watch了key的客户端链表，将表示客户端的对象的flags属性设置为REDIS_DIRTY_CAS状态。 touchWatchedKey()封装在了signalModifiedKey()中，能进行watch触发的命令都会调用signalModifiedKey()，这样的命令太多，基本上只要是能修改key的命令都包括了。 watch触发后响应客户端输入exec，会调用execCommand()，它会进行如下判断： 1234567891011121314151617181920212223242526272829/* Check if we need to abort the EXEC because: * 以下情况发生时，取消事务 * * 1) Some WATCHed key was touched. * 某些被监视的键已被修改（状态为 REDIS_DIRTY_CAS） * * 2) There was a previous error while queueing commands. * 有命令在入队时发生错误（状态为 REDIS_DIRTY_EXEC） * * A failed EXEC in the first case returns a multi bulk nil object * (technically it is not an error but a special behavior), while * in the second an EXECABORT error is returned. * * 第一种情况返回多个空白 NULL 对象， * 第二种情况返回一个 EXECABORT 错误。 */if (c-&gt;flags &amp; (REDIS_DIRTY_CAS|REDIS_DIRTY_EXEC)) &#123; // 根据状态，决定返回的错误的类型 addReply(c, c-&gt;flags &amp; REDIS_DIRTY_EXEC ? shared.execaborterr : shared.nullmultibulk); // 以下四句可以用 discardTransaction() 来替换 freeClientMultiState(c); initClientMultiState(c); c-&gt;flags &amp;= ~(REDIS_MULTI|REDIS_DIRTY_CAS|REDIS_DIRTY_EXEC); unwatchAllKeys(c); goto handle_monitor;&#125; 在执行exec后，会判断当前客户端的flags的状态，如果状态为REDIS_DIRTY_CAS，则事务安全性破坏，最后会调用unwatchAllKeys()。当然，即使状态不为REDIS_DIRTY_CAS，exec命令最终仍会调用unwatchAllKeys()，用来清空该客户端之前watch的记录。 idid就是数据库编号啊。 参考Redis 设计与实现：国内解析Redis的开源资料；]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>C</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis享知享学：单机数据库实现：blocking_keys和ready_keys属性]]></title>
    <url>%2F2018%2F09%2F10%2FRedis_Db03%2F</url>
    <content type="text"><![CDATA[本篇研究blocking_keys和ready_keys属性。 blocking_keys的作用是什么？Redis源码中为什么拥有两个ready_keys同名属性？解除客户端阻塞时采用了什么策略？这篇文章将对此进行探究。 blocking_keys在对Redis列表的操作上，有三个命令会造成客户端的阻塞，分别是BLPOP、BRPOP以及BRPOPLPUSH，数据库需要对这些功能的实现提供支持。 Redis数据库提供了blocking_keys属性，它仍然是一个字典，键是造成客户端阻塞的键，值是一个链表形式的list，用什么方法来表示客户端呢？看看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * 根据给定数量的 key ，对给定客户端进行阻塞 * * 参数： * keys 多个 key * numkeys key 的数量 * timeout 阻塞的最长时限 * target 在解除阻塞时，将结果保存到这个 key 对象，而不是返回给客户端 * 只用于 BRPOPLPUSH 命令 * * T = O(N) */void blockForKeys(redisClient *c, robj **keys, int numkeys, time_t timeout, robj *target) &#123; dictEntry *de; list *l; int j; // 设置阻塞状态的超时和目标选项 c-&gt;bpop.timeout = timeout; c-&gt;bpop.target = target; if (target != NULL) incrRefCount(target); // 将所有 key 加入到 client.bpop.keys 字典里，O(N) for (j = 0; j &lt; numkeys; j++) &#123; /* If the key already exists in the dict ignore it. */ // 记录阻塞 key 到客户端, O(1) if (dictAdd(c-&gt;bpop.keys,keys[j],NULL) != DICT_OK) continue; incrRefCount(keys[j]); /* And in the other "side", to map keys -&gt; clients */ // 将被阻塞的客户端添加到 db-&gt;blocking_keys 字典的链表中 // O(1) de = dictFind(c-&gt;db-&gt;blocking_keys,keys[j]); if (de == NULL) &#123; // 这个 key 第一次被阻塞，创建一个链表 int retval; /* For every key we take a list of clients blocked for it */ l = listCreate(); retval = dictAdd(c-&gt;db-&gt;blocking_keys,keys[j],l); incrRefCount(keys[j]); redisAssertWithInfo(c,keys[j],retval == DICT_OK); &#125; else &#123; // 已经有其他客户端被这个 key 阻塞 l = dictGetVal(de); &#125; // 加入链表 listAddNodeTail(l,c); &#125; /* Mark the client as a blocked client */ // 将客户端的状态设置为阻塞 c-&gt;flags |= REDIS_BLOCKED; // 为服务器的阻塞客户端数量增一 server.bpop_blocked_clients++;&#125; Redis声明了一个结构体redisClient，用它来代表客户端。blocking_keys的主要作用就是在出现阻塞情形时，添加(key, 被该键阻塞的客户端列表)这样的键值对，被相同key阻塞的客户端，会按链表的形式维护在该key对应的值里，该值即为被该键阻塞的客户端列表。 可以看出，客户端阻塞就是简单设置标志位flags(后续Redis版本会将最后几个方法一起封装成一个方法blockClient)，毕竟Redis是单线程，不可能还会将当前线程挂起。 blockForKeys方法会在两个地方调用，一个是blockingPopGenericCommand()，它是BLPOP/BRPOP 的底层实现；一个是brpoplpushCommand()，是BRPOPLPUSH的实现。 ready_keysLPUSH、RPUSH以及LINSERT命令可以停止客户端的阻塞。停止阻塞的功能需要借助ready_keys属性实现。 首先必须清楚的是，服务器和数据库具有相同名称的属性ready_keys，后续将对它们进行解析。 解除阻塞的三种方式： 被动脱离：有其它客户端为阻塞的键推入新元素； 主动脱离：到达设定的阻塞时间； 强制脱离：强制中断连接，服务器停机； 现在看看这三种的第一种： 前面提到的LPUSH、RPUSH以及LINSERT命令底层都是pushGenericCommand函数实现的。 解除客户端阻塞之准备现在假设为某个key推入了一个值，pushGenericCommand函数首先在数据库查找这个key对应的value对象，并判断是否为空： 12345// 查找key指向的对象，O(1)robj *lobj = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);// 如果列表为空，那么可能正在有客户端等待这个列表int may_have_waiting_clients = (lobj == NULL); 然后还要判断该value对象的类型是不是list： 1234if (lobj &amp;&amp; lobj-&gt;type != REDIS_LIST) &#123; addReply(c,shared.wrongtypeerr); return; &#125; 如果连列表都不是那就没有继续下去的意义。 准备工作做足之后，如果列表为空，很容易想到应该判断该key是否在blocking_keys，实际上，Redis也是这么做的： 1if (may_have_waiting_clients) signalListAsReady(c,c-&gt;argv[1]); 判断key是否在blocking_keys的方法就在这个signalListAsReady函数内： 123456789101112131415161718192021222324252627282930void signalListAsReady(redisClient *c, robj *key) &#123; readyList *rl; /* No clients blocking for this key? No need to queue it. */ // 没有客户端在等待这个 key ，直接返回 // O(1) if (dictFind(c-&gt;db-&gt;blocking_keys,key) == NULL) return; /* Key was already signaled? No need to queue it again. */ // key 已经位于就绪列表，直接返回 // O(1) if (dictFind(c-&gt;db-&gt;ready_keys,key) != NULL) return; /* Ok, we need to queue this key into server.ready_keys. */ // 添加包含 key 及其 db 信息的 readyList 结构到服务器端的就绪列表 // O(1) rl = zmalloc(sizeof(*rl)); rl-&gt;key = key; rl-&gt;db = c-&gt;db; incrRefCount(key); listAddNodeTail(server.ready_keys,rl); /* We also add the key in the db-&gt;ready_keys dictionary in order * to avoid adding it multiple times into a list with a simple O(1) * check. */ // 同时将 key 添加到 db 的 ready_keys 字典中 // 提供 O(1) 复杂度来查询某个 key 是否已经就绪 incrRefCount(key); redisAssert(dictAdd(c-&gt;db-&gt;ready_keys,key,NULL) == DICT_OK);&#125; 如果不在blocking_keys字典里，就直接返回；如果db.ready_keys不为空，也直接返回，这个属性是什么后面再介绍；如果程序都不满足之前两个“如果”的条件，则继续向下执行，此时会创建一个readyList，它会作为表元素的value，然后以链表的方式将表元素连接到server.ready_keys列表的尾部，readyList结构长这样： 1234typedef struct readyList &#123; redisDb *db; robj *key;&#125; readyList; 该结构体内db指向数据库，key指向数据库键空间的key。 在signalListAsReady方法的最后，redisAssert(dictAdd(c-&gt;db-&gt;ready_keys,key,NULL) == DICT_OK);执行的同时，会尝试将key添加到db的ready_keys字典中。该字典添加的键值对为(key, NULL)，显然不是为了存储，而是为了实现列表快速查询功能，当需要知道一个键代表的list是否已经存在时，可以借助dictAdd函数，而其内部会调用dictAddRaw方法，该方法内部又执行如下语句： 1234// 查找可容纳新元素的索引位置// 如果元素已存在， index 为 -1if ((index = _dictKeyIndex(d, key)) == -1) return NULL; db-&gt;ready_keys保证了不会有重复的key所指向的list添加在自身内部。而且前面也提到在signalListAsReady方法一开始会进行判断：如果db.ready_keys不为空，直接返回，所以db-&gt;ready_keys起到了一个快速查询防重的作用。 而server.ready_keys是一个链表结构，也可以把它看成一个“多任务队列”，在Java的并发库设计中，也常常使用这种方式。 pushGenericCommand()的主要作用： 如果may_have_waiting_clients为空，执行signalListAsReady方法，创建readyList实例并作为表元素的value，将表元素连接在server.ready_keys最后； 先将列表的元素推入key所指向的列表； 解除客户端阻塞之完成解除客户端阻塞发生在下一步调用handleClientsBlockedOnLists函数时。解除阻塞的流程大致可以描述为： 将server.ready_keys指向的地址赋给方法内的局部变量指针l，而server.ready_keys设置为一个新创建的列表； 遍历l指向的list，每循环一次，弹出链表实现的list的列表头，并取出value的值readyList实例rl； 通过rl，删除db-&gt;ready_keys中的key，即dictDelete(rl-&gt;db-&gt;ready_keys,rl-&gt;key);； 通过rl，获得key代表的list实例，即robj *o = lookupKeyWrite(rl-&gt;db,rl-&gt;key);； 在rl-&gt;db-&gt;blocking_keys查找键为rl-&gt;key的dictEntry实例de，通过它获取值，即为包含被阻塞客户端的链表clients； 循环遍历链表clients，lients弹出一个表头客户端，在key代表的列表不为空的情况下，弹出一个元素(代码中用value变量指代)，如果value不为空，取消表头客户端阻塞状态，把value作为造成该客户端阻塞的key值； 如果value为空，则说明仍然后客户端被阻塞，break，跳出循环； 由此也可看出，在解除客户端阻塞的时候，实行的是先阻塞先服务的策略(FBFS)，因为每次都是推出链表的表头。 参考Redis 设计与实现：国内解析Redis的开源资料；]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>C</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis享知享学：单机数据库实现：expires属性]]></title>
    <url>%2F2018%2F09%2F09%2FRedis_Db02%2F</url>
    <content type="text"><![CDATA[本篇继续解析单机数据库的实现，理解第二个属性expires。 Redis的过期删除采用了什么策略？过期键会被保存在更新后的RDB文件吗？主从节点对过期键的处理方式有什么不同？本篇将走进源码，寻找答案。 expires该属性用于保存键的过期时间，Redis提供多种命令设置键的过期时间，但是最终都会将设置的数值通过相应函数转化为UNIX时间戳来保存，类型是long long。 这里涉及两方面内容，一个是过期判定，一个是过期删除。 过期判定主要通过expireIfNeeded方法来判定，代码如下： 123456789101112131415161718192021222324int expireIfNeeded(redisDb *db, robj *key) &#123; // 取出 key 的过期时间 long long when = getExpire(db,key); // key 没有过期时间，直接返回 if (when &lt; 0) return 0; /* No expire for this key */ /* Don't expire anything while loading. It will be done later. */ // 不要在服务器载入数据时执行过期 if (server.loading) return 0; ... /* Return when this key has not expired */ // 未过期 if (mstime() &lt;= when) return 0; /* Delete the key */ server.stat_expiredkeys++; ... // 从数据库中删除 key return dbDelete(db,key);&#125; 暂时隐去了涉及多节点的代码。 过期删除过期删除的策略和之前分析字典实现时的rehash策略是类似的，都可以算是用存储开销来换取计算开销：实时的释放内存会增加CPU的计算负担。 所以Redis采用了称为惰性删除和定期删除的策略。 惰性删除策略简单思路就是：键虽然过期了，但是不会立马删除它，而是在访问键的时候再处理。 也就是每次访问的时候调用expireIfNeeded方法，如果过期了就进行删除操作dbDelete()并返回： 123456789101112131415161718/* Delete a key, value, and associated expiration entry if any, from the DB *//* * 从数据库中删除 key ，key 对应的值，以及对应的过期时间（如果有的话） */int dbDelete(redisDb *db, robj *key) &#123; /* Deleting an entry from the expires dict will not free the sds of * the key, because it is shared with the main dictionary. */ // 先删除过期时间 if (dictSize(db-&gt;expires) &gt; 0) dictDelete(db-&gt;expires,key-&gt;ptr); // 删除 key 和 value if (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123; if (server.cluster_enabled) SlotToKeyDel(key); return 1; &#125; else &#123; return 0; &#125;&#125; 定期删除策略简单思路就是：每隔一段时间执行一次删除。 该功能通过activeExpireCycle方法实现，在serverCron()内被调用： 123456/* Expire a few keys per cycle, only if this is a master. * On slaves we wait for DEL operations synthesized by the master * in order to guarantee a strict consistency. */// 如果服务器是主节点的话，进行过期键删除// 如果服务器是附属节点的话，那么等待主节点发来的 DEL 命令if (server.masterhost == NULL) activeExpireCycle(); 过期键对RDB、AOF和复制的影响RDB： 创建RDB文件时，程序会对键进行检查，过期的键不会被写入到更新后的RDB文件中。 AOF： 触发惰性删除或定期删除事件，程序会向AOF文件追加DEL命令。 复制： 假设现在进行可能发生惰性删除(定期删除类似)的操作，那么会调用expireIfNeeded()，在前文列出该方法源码的时候，本人暂时隐去了涉及多节点的代码，这里显现： 123456789101112131415161718192021// 第一个省略符号...下的代码：/* If we are running in the context of a slave, return ASAP: * the slave key expiration is controlled by the master that will * send us synthesized DEL operations for expired keys. * * Still we try to return the right information to the caller, * that is, 0 if we think the key should be still valid, 1 if * we think the key is expired at this time. */// 如果服务器作为附属节点运行，那么直接返回// 因为附属节点的过期是由主节点通过发送 DEL 命令来删除的// 不必自主删除if (server.masterhost != NULL) &#123; // 返回一个理论上正确的值，但不执行实际的删除操作 return mstime() &gt; when;&#125;// 第二个省略符号...下的代码：// 传播过期命令propagateExpire(db,key); server.masterhost != NULL为true，说明是从节点，返回mstime() &gt; when的值，不会再进行后续删除的操作； 如果能执行到propagateExpire(db,key);，说明是主节点且键是过期键，会通知其它从节点也要删除这个键，并在后面的代码中主动调用方法删除键； 这些代码说明了在复制条件下，删除过期键的原则： 从节点没有主动删除过期键的权利，应对客户端的请求，它只有“观察”的权利，返回的值可以告知客户端该键是否过期； 主节点在确认键是过期节点，并将在数据库中删除该键之前，会传播过期命令，通知从节点也删掉该键； 参考Redis 设计与实现：国内解析Redis的开源资料；]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>C</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis享知享学：单机数据库实现：dict属性]]></title>
    <url>%2F2018%2F09%2F08%2FRedis_Db01%2F</url>
    <content type="text"><![CDATA[本篇主要目的是理解Redis单机数据库中键空间dict的实现机理。 Redis的持久化技术建立在操作系统的COW机制上，Redis如何权衡rehash的时机？rehash时间会产生堵塞服务器的问题，Redis是如何应对这个问题的？渐进式rehash的原理是什么？诸如此类问题将通过本篇文章得到解答。 结构一览首先看看Redis单机数据库的结构： 1234567891011121314typedef struct redisDb &#123; // key space，包括键值对象 dict *dict; /* The keyspace for this DB */ // 保存 key 的过期时间 dict *expires; /* Timeout of keys with a timeout set */ // 正因为某个/某些 key 而被阻塞的客户端 dict *blocking_keys; /* Keys with clients waiting for data (BLPOP) */ // 某个/某些接收到 PUSH 命令的阻塞 key dict *ready_keys; /* Blocked keys that received a PUSH */ // 正在监视某个/某些 key 的所有客户端 dict *watched_keys; /* WATCHED keys for MULTI/EXEC CAS */ // 数据库的号码 int id;&#125; redisDb; 下面将解析redisDb内各属性。 dict这个属性中文翻译成“键空间”，是Redis内部的数据结构字典实现的，字典的结构如下： 123456789101112131415161718typedef struct dict &#123; // 特定于类型的处理函数 dictType *type; // 类型处理函数的私有数据 void *privdata; // 哈希表（2个） dictht ht[2]; // 记录 rehash 进度的标志，值为-1 表示 rehash 未进行 int rehashidx; // 当前正在运作的安全迭代器数量 int iterators; &#125; dict; 了解Java HashMap的对这个结构不会陌生，只不过这里拥有两个哈希表： ht[0]-&gt;table的空间分配将在第一次往字典添加键值对时进行； ht[1]-&gt;table的空间分配将在rehash开始时进行； 新的键值添加进字典前会经过三个步骤： 字典0号哈希表的table属性为空，ht[0]-&gt;table分配空间(本人当前使用版本初始大小为4)； 如果发生碰撞，处理碰撞； 插入新元素若满足rehash条件，则进行rehash； 这里分析一下rehash过程，其它步骤可以参考本站HashMap的源码解析，原理相同。 rehash时机哈希表的性能依赖一个比率 ratio：used / size，used和size是dictht中的属性： 123456789101112131415typedef struct dictht &#123; // 哈希表节点指针数组（俗称桶，bucket） dictEntry **table; // 指针数组的大小 unsigned long size; // 指针数组的长度掩码，用于计算索引值 unsigned long sizemask; // 哈希表现有的节点数量 unsigned long used; &#125; dictht; rehash分扩展(expand)和收缩(shrink)。本篇文章主要介绍扩展(收缩的原理和扩展基本相同)： 什么时候扩展？这个问题需要提两个变量： static int dict_can_resize = 1; static unsigned int dict_force_resize_ratio = 5; 它们都是触发扩展的条件变量，为什么有两个触发条件？这就需要对它们使用的环境进行分析。 dict_can_resize 设置dict_can_resize的方法有两个： dictEnableResize方法用来置1； dictDisableResize方法用来置0； 这两个方法只在一处调用： 123456void updateDictResizePolicy(void) &#123; if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1) dictEnableResize(); else dictDisableResize();&#125; 还没有RDB持久化服务的时候，server.rdb_child_pid == -1；还没有AOF持久化服务的时候，server.aof_child_pid == -1。 即调用方法后，若没有子进程的持久化服务存在，dictEnableResize()就调用，将dict_can_resize置1，反之置0。 在扩容的方案中，dict_can_resize作为条件变量时被引用在_dictExpandIfNeeded中： 123456789101112131415161718192021222324252627282930static int _dictExpandIfNeeded(dict *d)&#123; // 已经在渐进式 rehash 当中，直接返回 if (dictIsRehashing(d)) return DICT_OK; // 如果哈希表为空，那么将它扩展为初始大小 // O(N) if (d-&gt;ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE); /* If we reached the 1:1 ratio, and we are allowed to resize the hash * table (global setting) or we should avoid it but the ratio between * elements/buckets is over the "safe" threshold, we resize doubling * the number of buckets. */ // 如果哈希表的已用节点数 &gt;= 哈希表的大小， // 并且以下条件任一个为真： // 1) dict_can_resize 为真 // 2) 已用节点数除以哈希表大小之比大于 // dict_force_resize_ratio // 那么调用 dictExpand 对哈希表进行扩展 // 扩展的体积至少为已使用节点数的两倍 // O(N) if (d-&gt;ht[0].used &gt;= d-&gt;ht[0].size &amp;&amp; (dict_can_resize || d-&gt;ht[0].used/d-&gt;ht[0].size &gt; dict_force_resize_ratio)) &#123; return dictExpand(d, d-&gt;ht[0].used*2); &#125; return DICT_OK;&#125; dict_force_resize_ratio 这个时候，我们看到了另一个条件变量dict_force_resize_ratio。这也是整个源代码该变量唯一被引用的地方。 暂时先搁置_dictExpandIfNeeded的内部实现，看看它在整个源代码中的调用链： dictAdd() / dictReplaceRaw()可能调用 / sentinelObjectiveLeaderIncr()可能调用 -&gt; dictAddRaw() -&gt; _dictKeyIndex() -&gt; _dictExpandIfNeeded() 暂时考虑添加键值对的情况：dictAdd()，它是最普遍的操作。最终它会调用_dictExpandIfNeeded方法，添加键值对后，d-&gt;ht[0].used &gt;= d-&gt;ht[0].size如果成立，则继续判断 &amp;&amp; 后的条件语句，也就是： 12(dict_can_resize || d-&gt;ht[0].used/d-&gt;ht[0].size &gt; dict_force_resize_ratio) dict_can_resize为1，直接执行rehash扩展方法dictExpand()；如果dict_can_resize为0，但是只要used / size大于5，程序仿佛抱怨“对不起，实在太大了，必须马上rehash”，不论dict_can_resize是什么值，都执行rehash扩展方法。 现在一切都清楚了，dict_can_resize是一个用来降低rehash优先级的标志位。而如果比率太大，大于5，那么rehash的优先级就摆在了前面。 为什么要这样处理？used / size &gt;= 1比起used / size &gt; dict_force_resize_ratio的“门槛”低很多，如果不设置一个dict_can_resize标志位，那么当子进程进行持久化服务的时候，可能会面临频繁的rehash，造成过大的资源开销，Redis的持久化服务运用了操作系统的写时复制(COW)技术，关于父子进程，国外网友回答到：“All processes are sharing the same set of pages and each one gets its own private copy when it wants to modify a page.” rehash基本原理先确定扩容大小。前文的代码中，一旦确定要扩容，返回的是dictExpand(d, d-&gt;ht[0].used*2)的值。在该函数内部实际上调用了_dictNextPower方法，并赋值给realsize，这就是扩容后的哈希表的大小。在Java的HashMap容器的源码中有一个和_dictNextPower类似的方法，该方法返回不小于传入参数的最小2的次方数。 接下来简单叙述rehash流程 按照前文确定的扩容大小给ht[1]分配空间； ht[0]-&gt;table的节点迁移到ht[1]-&gt;table； 执行迁移后的“善后”工作； “善后”用代码描述： 1234567891011121314151617if (d-&gt;ht[0].used == 0) &#123; // 释放 ht[0] 的哈希表数组 zfree(d-&gt;ht[0].table); // 将 ht[0] 指向 ht[1] d-&gt;ht[0] = d-&gt;ht[1]; // 清空 ht[1] 的指针 _dictReset(&amp;d-&gt;ht[1]); // 关闭 rehash 标识 d-&gt;rehashidx = -1; // 通知调用者， rehash 完毕 return 0;&#125; 这个过程用代码描述还是比较清晰的。 渐进式rehashht[0]-&gt;table的节点迁移到ht[1]-&gt;table不是一次性、集中性的完成，主要是因为如果数据量太大，服务器会阻塞等待，所以它是一种渐进式的方式来进行。怎么渐进式进行？就是把rehash的整个过程分散到多个步骤中去。 我个人觉得代码中比较有新意的地方：作者明白复制一个哈希表的内容到另一个扩容的哈希表不是目的，目的是减少增删改查数据的开销，以及不造成服务器长时间的阻塞。那么每次可以只将一个表的内容转移一部分到扩容的表，此时两个表可以同时使用。当然，后续客户端命令产生的新的数据，直接保存在扩容表上。 rehash的核心操作都封装在dictRehash方法里，但它的调用主要又是依靠_dictRehashStep和dictRehashMilliseconds方法。 前面提到的多个步骤，对于_dictRehashStep()来说，指的是：dictAddRaw、dictGenericDelete、dictFind、dictGetRandomKey四个方法的调用步骤，只要dictIsRehashing方法返回true(该方法主要判断rehash是否正在进行)，就会执行_dictRehashStep()。每次迁移ht[0]-&gt;table索引从0递增第一个不为空的链表的所有节点到ht[1]-&gt;table。 dictRehashMilliseconds则需要传入一个参数时常的阻塞时间，在这个规定时间内迁移尽可能多的数据。 参考Redis 设计与实现：国内解析Redis的开源资料； fork()后copy on write的一些特性：介绍了操作系统内COW实现原理； How does copy-on-write in fork() handle multiple fork?：国外问答网站关于fork处理中COW技术的精简回答； ［OS］ fork() 和 vfork() ［copy on write］：痞客邦的网友回答； Redis持久化RDB和AOF相比较 解密Redis持久化：该内容来源于Redis作者博文； 安装附录用HomeBrew安装：brew isntall redis 启动命令：redis-server； 启动客户端：redis-cli； 如果有中文乱码，输入如下命令： 1redis-cli --raw]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>C</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[J.U.C并发框架之CopyOnWrite]]></title>
    <url>%2F2018%2F09%2F07%2FJUC_COW%2F</url>
    <content type="text"><![CDATA[本篇研究CopyOnWrite的实现原理，并为后续研究其它“写时复制”的问题进行预热。 更改键对应的值，也会在内部复制数组吗？存在数据一致性的问题吗？写时不复制不可以吗？这篇文章会解答诸如此类的问题。 按照惯例，先放出示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class CopyOnWriteDemo &#123; public static void main(String[] args) &#123; Map cmap =new CopyOnWriteMap(); cmap.put(1, "a"); new Thread(() -&gt; &#123; cmap.put(1, "new a"); System.out.println(cmap.get(1)); &#125;).start(); System.out.println(cmap.get(1)); &#125;&#125;class CopyOnWriteMap&lt;K, V&gt; extends HashMap&lt;K, V&gt; implements Cloneable &#123; private volatile Map&lt;K, V&gt; internalMap; private final ReentrantLock lock = new ReentrantLock(); public CopyOnWriteMap() &#123; internalMap = new HashMap&lt;K, V&gt;(); &#125; public V put(K key, V value) &#123; lock.lock(); try &#123; Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap); Thread.sleep(3000); V val = newMap.put(key, value); internalMap = newMap; return val; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; return null; &#125; public V get(Object key) &#123; return internalMap.get(key); &#125; public void putAll(Map&lt;? extends K, ? extends V&gt; newData) &#123; lock.lock(); try &#123; Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap); newMap.putAll(newData); internalMap = newMap; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 输出结果是： 12anew a 大约三秒后输出a，接着又过三秒输出new a。这个方法没有采用java的juc包提供的工具，是自己实现的一个CopyOnWriteMap容器。 主体思想主题思想就是四个字：写时复制。 比如在上述程序中，读是直接返回内部维护的一个map，并未做更多的处理： 123public V get(Object key) &#123; return internalMap.get(key);&#125; 而在添加元素的时候，首先加锁，然后复制旧的map数据到新的map，对新的map添加键值对，操作完成后，将指向旧的map对象的指针指向新的map对象，最后释放锁。用代码描述就是： 1234567891011121314151617public V put(K key, V value) &#123; lock.lock(); try &#123; Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap); Thread.sleep(3000); V val = newMap.put(key, value); internalMap = newMap; return val; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; return null;&#125; 为了模拟延迟操作，添加了睡眠事件。 J.U.C的实现框架提供了CopyOnWriteArrayList、CopyOnWriteArraySet，下面以CopyOnWriteArrayList为例进行探讨。 更改键对应的值，也会在内部复制数组吗？ CopyOnWriteArrayList用set更新： 123456789101112131415161718192021public E set(int index, E element) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); E oldValue = get(elements, index); if (oldValue != element) &#123; int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len); newElements[index] = element; setArray(newElements); &#125; else &#123; // Not quite a no-op; ensures volatile write semantics setArray(elements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125; 所以，如果更新的value和原本旧的value相同，则不会复制新的数组，反之则会复制。 存在数据一致性的问题吗？ 在示例中添加睡眠事件就是为了说明这个问题(虽然是自研容器，但是原理一样)。一言以蔽之：COW保证最终一致性，但是不保证实时一致。 写时不复制不可以吗？ 容器在迭代的时候，不允许修改元素，否则会抛出异常，以ArrayList为例，它的迭代器内部有如下代码： 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 而set add等方法中也都会添加判断rangeCheck(index);(这也可以进步一说明set内部复制数组的问题)。 所以写时进行复制是必要的。 优缺点及场景前面已经分析了CopyOnWrite不能保证数据实时一致，同时，它在写的时候要开辟额外的存储空间。这就预示着，它比较适合： 读多写少 实时性要求不高 扩容添加不频繁 小结通过本篇分析，了解了CopyOnWrite的实现原理，并解决了一些小问题。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>源码</tag>
        <tag>CopyOnWrite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[J.U.C并发框架之AQS(六)：CountDownLatch]]></title>
    <url>%2F2018%2F09%2F06%2FJUC_AQS06%2F</url>
    <content type="text"><![CDATA[本篇延续之前的AQS系列，解析CountDownLatch，目的在于摸清CountDownLatch的工作机理。 线程内调用await()是如何响应中断的？多个线程各自调用await()并挂起，当同步器的state更新为0后会全部唤醒执行吗？通过本篇文章，诸如此类的问题将得到解决。 CountDownLatch示例照例先放上演示代码： 12345678910111213141516171819202122232425262728public class CountDownLatchDemo implements Runnable &#123; static final CountDownLatch latch = new CountDownLatch(6); static final CountDownLatchDemo demo = new CountDownLatchDemo(); public static void main(String[] args) throws InterruptedException &#123; ExecutorService exec = Executors.newFixedThreadPool(6); for (int i = 0; i &lt; 6; i++) &#123; exec.submit(demo); &#125; Thread.sleep(3000); latch.await(); System.out.println(Thread.currentThread().getName()); exec.shutdown(); &#125; @Override public void run() &#123; try &#123; Thread.sleep( 3000); System.out.println(Thread.currentThread().getName()); latch.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行的结果如下： 1234567pool-1-thread-1pool-1-thread-3pool-1-thread-2pool-1-thread-4pool-1-thread-5pool-1-thread-6main CountDownLatch源码解析CountDownLatch和ReentrantLock类似，内部都维护了一个继承自AbstractQueuedSynchronizer的同步器。 通常，在new一个CountDownLatch对象的时候，会传入一个int值(往往是线程数)，此时会执行构造器方法： 1234public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException("count &lt; 0"); this.sync = new Sync(count);&#125; 而Sync的构造器如下： 123Sync(int count) &#123; setState(count);&#125; 可见，传入的int值，最终会设置为同步器内的state值。 countDown()countDown()源码： 123public void countDown() &#123; sync.releaseShared(1);&#125; 继续追踪sync.releaseShared(1)： 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 以上就是countDown()的主要实现，涉及三个方法：releaseShared()、tryReleaseShared()、doReleaseShared()，第一个封装了后两个，组成了CountDownLatch释放共享锁的机制，其中tryReleaseShared代码在CountDownLatch内重写，而doReleaseShared方法来自AQS。 tryReleaseShared的作用是判断是否可以释放共享锁，它返回一个布尔值： 1234567891011protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; 如果同步器的state等于0，自然无所谓释放锁，返回false，否则将state的值减去1(nextc = c-1)，这符合countDown()的目的。然后采用CAS的方式将state更新为新值，判断更新后的state是否为0，如果为0说明可以释放共享锁，返回true，否则返回false。 如果通过tryReleaseShared判断后得到可以释放锁的结果，那么除了将state更新以外，还需要继续进行释放锁的一些实质操作，采用的是doReleaseShared方法： 1234567891011121314151617181920212223242526272829private void doReleaseShared() &#123; /* * Ensure that a release propagates, even if there are other * in-progress acquires/releases. This proceeds in the usual * way of trying to unparkSuccessor of head if it needs * signal. But if it does not, status is set to PROPAGATE to * ensure that upon release, propagation continues. * Additionally, we must loop in case a new node is added * while we are doing this. Also, unlike other uses of * unparkSuccessor, we need to know if CAS to reset status * fails, if so rechecking. */ for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125;&#125; 还记得之前写的J.U.C并发框架之AQS(一)内容吗？“Fake Node”是在enq()中通过执行compareAndSetHead(new Node())语句产生的，此时head不再指向null。也就是说，至少需要一个尝试获取锁未遂并进入等待队列的线程出现过，head才不为空。 结合开头的演示例子，如果将主线程睡眠时间换成更大的值，这样就确保了countDown()之前没有出现过尝试获取锁失败的线程，那么以上for循环将直接break(除非head在这段时间被其它线程修改，这样的话那么继续loop)。 第一个if语句的条件(h != null &amp;&amp; h != tail)中，h != tail要求判断等待队列不为empty，Fake Node是不算等待队列的成员的，如果条件满足，内部内嵌if - else if句式： 内嵌if语句：如果ws == Node.SIGNAL，唤醒后继节点，期间通过CAS更新ws值，如果失败跳出当次循环，重新loop； else if语句：只有在ws == 0的时候，将其值更新为Node.PROPAGATE，更新失败跳出当次循环，重新loop。啰嗦一句，&amp;&amp;是短路运算符，ws不为0直接跳过执行； 从以上分析可见，CountDownLatch类创建的latch实例可以看作是一把锁，一个线程通过countDown()可以修改latch持有的同步器的state，好似共享了一把锁一样。 想必await()会有一个入队的“仪式”，这样才能和前面解析的内容配套，接下来就解析await()。 await()它的代码如下： 123public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125; 继续追踪： 1234567public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125; 以上就是await()的主要实现，同样涉及三个方法：acquireSharedInterruptibly()、tryAcquireShared()、doAcquireSharedInterruptibly()，第一个封装了后两个，组成了CountDownLatch获取共享锁的机制，其中tryAcquireShared代码在CountDownLatch内重写，而doAcquireSharedInterruptibly方法来自AQS。 tryAcquireShared()长这样，它的作用是判断是否可以获取共享锁： 123protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1;&#125; 传入的参数并没有在方法体中发挥功效，这样声明方法，可能是因为重写AQS方法时需要继承方法签名。 如果同步器的state为0，则返回1，表示可以获取锁；否则返回-1，表示不能获取锁。 一旦没能获取共享锁，那么执行doAcquireSharedInterruptibly，它的作用可认为是等待时机以获取共享锁： 12345678910111213141516171819202122232425private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; addWaiter()根据线程创建了共享模式下的实例node，并放入队尾。第一个if语句中，如果p的前驱不是head，就跳到并行的后一个if，这部分和acquireQueued方法类似，不细究了，值得注意的是if条件满足会直接抛中断异常。 如果node的前驱 == head，和acquireQueued类似，首先还是会尝试获取共享锁，获取失败的情形和前面分析的类似，现假设此时获取成功，那么将执行setHeadAndPropagate方法。 setHeadAndPropagate源码如下： 1234567891011121314151617181920212223242526private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; // Record old head for check below setHead(node); /* * Try to signal next queued node if: * Propagation was indicated by caller, * or was recorded (as h.waitStatus either before * or after setHead) by a previous operation * (note: this uses sign-check of waitStatus because * PROPAGATE status may transition to SIGNAL.) * and * The next node is waiting in shared mode, * or we don't know, because it appears null * * The conservatism in both of these checks may cause * unnecessary wake-ups, but only when there are multiple * racing acquires/releases, so most need signals now or soon * anyway. */ if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); &#125;&#125; setHead方法在之前的文章已经分析过了，这里主要关注代码中的if语句。 s是node的后继节点，isShared方法如下： 123final boolean isShared() &#123; return nextWaiter == SHARED;&#125; 这里会产生一些好奇： 第一个好奇：nextWaiter眼熟 注释是这么说的： And because conditions can only be exclusive, we save a field by using special value to indicate shared mode. 所以nextWaiter在独断模式和共享模式的意义是不一样的，在这里用来表示node处于共享模式。 第二个好奇：s == null作为条件语句 doReleaseShared()主要功能在前面已经解析过，但其中的unparkSuccessor由于是之前文章解析过的方法，前面并没有具体说明。实际上，其内部存在处理后继节点为null的代码： 123456if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t;&#125; 这里的s是头节点的后继，而代表头节点的指针head在之前就已然指向了node，所以方法内外的s都是node的后继，而在上述代码中，s如果为null，或者s的ws值大于0，将从队列的尾端开始向前查找ws小于等于0的node，然后进行后续处理。 小结总的来说，由于CountDownLatch不需要显示调用方法释放锁(比如独断锁的lock.lock())，唤醒后继节点的操作直接在doAcquireSharedInterruptibly内完成。所以即便有多个线程通过await()挂起，一旦latch内维护的同步器的state更新为0，那么多个挂起的线程都将被唤醒。 以上就是CountDownLatch的实现解析。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>源码</tag>
        <tag>CountDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[J.U.C并发框架之AQS(五)：Condition]]></title>
    <url>%2F2018%2F09%2F05%2FJUC_AQS05%2F</url>
    <content type="text"><![CDATA[通常ReentrantLock和Condition配套使用，后者提供了await()以及signal()等方法，本篇将重点解析await()和signal()的实现原理，以期了解它们的工作流程。 signal()会随意唤醒条件队列中的线程吗？调用signal()会立马唤醒条件队列的线程吗？中断条件队列中的等待线程会抛异常吗？很多问题将通过本篇获解。 Condition基本用法照例先放一段演示代码： 1234567891011121314151617181920212223242526272829303132333435363738394041public class ReenConditionDemo &#123; public static final ReentrantLock lock = new ReentrantLock(); public static Condition condition = lock.newCondition(); public static void main(String[] args) &#123; Thread t = new Thread(() -&gt; &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread().getName() + " begin"); condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; lock.unlock(); System.out.println(Thread.currentThread().getName() + " over"); &#125;, "Task"); t.start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; lock.lock(); System.out.println("Main begin"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; condition.signal(); lock.unlock(); System.out.println("Main over"); &#125;&#125; 运行输出如下： 1234Task beginMain beginMain overTask over Task线程先拿到锁，执行到condition.await()开始等待，并释放锁，主线程拿到锁开始执行，执行到condition.signal()将Task线程唤醒，主线程unlock()后，Task线程开始执行。 Condition似乎可以看作模拟Syncronized锁住的对象，它调用await()和signal()对应wait()和notify()。 下图列出了Condition接口全部方法： Condition实现解析追踪Condition实现的相关代码： 123456789// 追踪的lock.newCondition()实现：public Condition newCondition() &#123; return sync.newCondition();&#125;// 追踪的sync.newCondition()实现：final ConditionObject newCondition() &#123; return new ConditionObject();&#125; ConditionObject是AQS的一个内部类，实现了Condition和序列化接口。 await()解析按照之前演示的顺序，先解析await()，它的代码并不冗长： 123456789101112131415161718public final void await() throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); int savedState = fullyRelease(node); int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125; ConditionObject维护了一个自己的等待队列： 123456789101112131415private Node addConditionWaiter() &#123; Node t = lastWaiter; // If lastWaiter is cancelled, clean out. if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; unlinkCancelledWaiters(); t = lastWaiter; &#125; Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node;&#125; 初始的时候内部的指针都为null，比如lastWaiter，而第一个if语句是处理ws为CANCELLED等情况，这里就不去说明了。 创建代表当前线程的节点，将ws设置为CONDITION，然后就是入队返回了，这里的队列也没有创建专门的Queue，就是用的普通链表形式。 接下来是fullyRelease方法： 123456789101112131415final int fullyRelease(Node node) &#123; boolean failed = true; try &#123; int savedState = getState(); if (release(savedState)) &#123; failed = false; return savedState; &#125; else &#123; throw new IllegalMonitorStateException(); &#125; &#125; finally &#123; if (failed) node.waitStatus = Node.CANCELLED; &#125;&#125; 这个方法的作用是释放锁，并保存同步器的状态值。release(savedState)正常情况应该返回true，也就是tryRelease(savedState)应该返回true，不仅如此，在tryRelease内还会调用setExclusiveOwnerThread(null)，并setState(0)(具体参看ReentrantLock源码中的tryRelease()部分)，这样就让出了同步器构造的锁。tryRelease后执行release第一个if内的语句，会唤醒后继节点，具体来说就是本站AQS第一篇解析的内容了。 接下来的代码，将单独抽出来： 12345while (!isOnSyncQueue(node)) &#123; LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break;&#125; 继续追踪isOnSyncQueue方法的源码，该方法作用如其名，就是判断是否在同步队列中： 123456789101112131415final boolean isOnSyncQueue(Node node) &#123; if (node.waitStatus == Node.CONDITION || node.prev == null) return false; if (node.next != null) // If has successor, it must be on queue return true; /* * node.prev can be non-null, but not yet on queue because * the CAS to place it on queue can fail. So we have to * traverse from tail to make sure it actually made it. It * will always be near the tail in calls to this method, and * unless the CAS failed (which is unlikely), it will be * there, so we hardly ever traverse much. */ return findNodeFromTail(node);&#125; 逐句解释： 如果ws是Node.CONDITION或者该节点前驱指针指向为null则说明不在同步队列，之前的解析文章中已经解释过，head == tail表示队列为空； 如果一个节点有后继节点，那么就说明它在同步队列； 如果不属于以上情况，那么从队列的尾部开始遍历，查找是否有和传入的node相等的节点； while语句内部，本人关注这段代码： 12if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; 进而追踪checkInterruptWhileWaiting： 12345private int checkInterruptWhileWaiting(Node node) &#123; return Thread.interrupted() ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0;&#125; 这个方法的名字告诉本人，这是一个在等待期间检测中断的一个方法。这里强调一下，unpark()是不会更改中断标志位的，所以如果是signal()(内部调用的是unpark()，后续会分析)，那么该方法只会返回0，假设此时中断标志位不为0，来展开后续分析。 来看看transferAfterCancelledWait方法： 123456789101112131415final boolean transferAfterCancelledWait(Node node) &#123; if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) &#123; enq(node); return true; &#125; /* * If we lost out to a signal(), then we can't proceed * until it finishes its enq(). Cancelling during an * incomplete transfer is both rare and transient, so just * spin. */ while (!isOnSyncQueue(node)) Thread.yield(); return false;&#125; (node, Node.CONDITION, 0)对应(Node node, int expect, int update)，如果在signal()之前，那么当前节点的ws当然是Node.CONDITION，这样就继续入队，并返回true，入队后怎么重新获得锁，参考本站AQS第一篇的内容。 如果在signal()之后发生中断动作，那么ws将不再是Node.CONDITION，但是也有可能代表当前线程的节点并没有完成入队，所以用一个while语句spin。 在signal()之前中断不是正常的程序，理应推出等待抛出异常，所以用THROW_IE表示，值为-1；而在signal()之后中断，就是重复多次中断，就用REINTERRUPT表示，值为1。 后续还有以下代码： 123456if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT;if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters();if (interruptMode != 0) reportInterruptAfterWait(interruptMode); 简要说明如下： 第一个if：之前的解析文章中已知,acquireQueued方法，如果遭遇中断事件也会返回true，那么在不是THROW_IE的情况下，也可以将interruptMode设置为REINTERRUPT； 第二个if：unlinkCancelledWaiters方法是用来清除在条件队列中却不处于条件状态的节点； 第三个if：主要用来抛中断异常，如果interruptMode == REINTERRUPT还会自我调用interrupt()； signal()解析在之前的解析中，存在如下代码： 123while (!isOnSyncQueue(node)) Thread.yield();return false; 我的原话是：“如果在signal()之后发生中断动作，那么ws将不再是Node.CONDITION，但是也有可能代表当前线程的节点并没有完成入队，所以用一个while语句spin。” 那么等待的入队动作，发生在什么地方呢？答案可能就在signal()源码内。 signal()： 1234567public final void signal() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first);&#125; 继续追踪： 12345678private void doSignal(Node first) &#123; do &#123; if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null; &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null);&#125; firstWaiter被设置为first.nextWaiter，后续还执行first.nextWaiter = null，这样条件队列的头节点就被“剥离”。transferForSignal(first)返回true会停止循环。 继续追踪transferForSignal方法： 12345678910111213141516171819final boolean transferForSignal(Node node) &#123; /* * If cannot change waitStatus, the node has been cancelled. */ if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; /* * Splice onto queue and try to set waitStatus of predecessor to * indicate that thread is (probably) waiting. If cancelled or * attempt to set waitStatus fails, wake up to resync (in which * case the waitStatus can be transiently and harmlessly wrong). */ Node p = enq(node); int ws = p.waitStatus; if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true;&#125; 如果node(第一次进入while条件语句指代头节点first)状态不是Node.CONDITION，那么if语句返回false，则继续while循环找寻下一个等待队列中的节点；反之则node的ws更新为0，继续向下执行transferForSignal中的代码。 enq()已经在之前的文章已经解析过，它是这么一个方法，内部有一个局部变量t，这个t原本指向的是尾节点，当node作为参数传入后，将node接在尾节点后，此时t相当于node的前驱节点并双向链接于node。 前驱节点ws &gt; 0，又或者这个前驱节点设置ws为Node.SIGNAL失败，则会执行： 1LockSupport.unpark(node.thread); 从上述代码，至少揭示了两件事： signal()会按照条件队列的入队顺序进行操作； signal()通常不会立马唤醒条件队列中的线程； 以本篇文章开头的例子来说，只有两个线程，一个是主线程，一个是开的Task线程，代表Task线程的node的前驱节点就是head，head的ws并没有大于0，而且也可以成功设置为Node.SIGNAL。 将主线程的lock.unlock()注释掉，在源码上打断点进行说明： 在执行if语句之前： 执行if语句之后： Node@693代表的就是Task线程的节点，而Node@694是head指针指向的节点，也是p代表的节点。它是693的前驱，693是它的后继。 if语句内的LockSupport.unpark(node.thread);并没有执行(之前打过断点，直接跳过，上图并未打断点)。而p的ws设置为了-1，当主线程释放锁，Task线程才会唤醒执行。 所以： signal()之后，通常是将挂起的线程直接放到同步队列中； 即便挂起的线程被唤醒，一般也是通过acquireQueued方法，在同步等待队列的机制下完成后续操作； signalAll()和signal()的实现大体上相同，最大的不同在于doSignal和doSignalAll，这里把后者代码也贴出来： 123456789private void doSignalAll(Node first) &#123; lastWaiter = firstWaiter = null; do &#123; Node next = first.nextWaiter; first.nextWaiter = null; transferForSignal(first); first = next; &#125; while (first != null);&#125; 两个相比区别主要在于while的条件语句，signalAll()会依次将条件队列中的Node实例放到同步等待队列中。 小结Condition作为ReentrantLock的配套工具，它的实现不是孤立的，和ReentrantLock内部维护的同步器联系紧密，特别是它巧妙的利用了同步器的等待队列。 一些问题的本人理解1while (!isOnSyncQueue(node)) &#123;&#125; 在await中唤醒而未入同步等待队列的情况，除了中断，还可能包括unpark()，所以while()中的条件有它存在的必要性。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>源码</tag>
        <tag>Condition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenv的安装和使用]]></title>
    <url>%2F2018%2F08%2F25%2FJenv_Tutorial%2F</url>
    <content type="text"><![CDATA[很久之前写过一篇《pyenv的安装和应用》，没想到现在也要去安装一个Java的版本管理器，不过在本人看来这是一件好事，因为这侧面说明Java一直都在与时俱进，本篇主要记录jenv的安装和使用。 安装jenv本人按照习惯采用homebrew安装，命令如下： 1$ brew install pyenv 安装好可以查看版本： 1$ jenv --version 接下来进行必要的Bash配置： 12$ echo 'export PATH="$HOME/.jenv/bin:$PATH"' &gt;&gt; ~/.bash_profile$ echo 'eval "$(jenv init -)"' &gt;&gt; ~/.bash_profile Zsh采用： 12$ echo 'export PATH="$HOME/.jenv/bin:$PATH"' &gt;&gt; ~/.zshrc$ echo 'eval "$(jenv init -)"' &gt;&gt; ~/.zshrc jenv安装Java查看自己电脑已经安装的版本，： 12$ cd /Library/Java/JavaVirtualMachines$ ls 现根据存在的版本在jenv安装(说是安装其实只是连接)不同JDK版本，比如现在本人将安装1.7，命令如下： 1jenv add /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home 此时输出： 1ln: /Users/yin/.jenv/versions/oracle64-1.7.0.80-ea: No such file or directory 将之前的命令前添加sudo也无济于事，解决的办法是将终端重启或者新开一个窗口。 再次输入命令，窗口打印出： 123oracle64-1.7.0.80-ea added1.7.0.80-ea added1.7 added 这里出现了三个版本名字，不知道有何意义，不过似乎可以尝试删除其中多余的名字。 现在可以查看当前jenv下存在的版本了，使用命令： 1$ jenv versions 同样的方法将1.6和1.8版本的JDK“安装”到jenv。 jenv使用这里可以进行两种设置 设置全局版本 使用全局版本的方法是在shell中运行命令： 1$ jenv global 1.7 全局版本最好不要设置为System，在给jar包传递命令行参数时产生了无效路径的bug。 设置局部版本 在这里本人新建了一个文件夹jenvtest，进入该文件夹，然后运行： 1$ jenv local 1.8 此时运行java -version命令发现在该文件夹环境下版本是1.8.0_171版本，当在其它文件夹下运行时是1.7.0_80-ea(即本人电脑上默认的系统版本)。 取消 &amp; 删除设定jenv和pyenv一样，可以取消local设定： 1$ pyenv local --unset 删除jenv与本地版本的关联可以采用下面的方式实现： 1$ jenv remove [版本号] 参考]]></content>
      <categories>
        <category>安装</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles安装 & 修改网络请求]]></title>
    <url>%2F2018%2F08%2F01%2FCharles_Install_for_Mac%2F</url>
    <content type="text"><![CDATA[安装教程内容多转自网上片段，能贴原文地址的，就不重复粘贴内容，本机采用的Charles是4.2.5版本。后续如若遇到新的设置安装问题，也会在此篇进行更新。 安装注意事项基本安装安装主要参考的是Mac Fidder抓包替代方案Charles-proxy抓包工具下载+安装+破解charles.jar下载这篇内容，需要强调的是本篇只进行测试和学习，商业使用请安装正版。 该篇文章中说打开之前最好运行如下命令： 1$ sudo spctl --master-disable 如果想还原之前设置可输入： 1$ sudo spctl --master-enable 乱码解决本人参考的是此篇解决Charles乱码问题，并且解决了问题。最后的参考栏下有一篇相对更详细的文章Mac上使用Charles抓包。 使用Charles修改网络请求Charles是一个代理Web服务器，在这里通过一个修改网络请求的实例来了解它。 在菜单栏的Tools下选择Rewrite，按照下面三张图所示填写。 Rewrite Settings： Edit Location： Rewrite Rule： 设置好后，访问：https://cgiirw.github.io/2018/06/20/Java8_FuncPro02/ 返回的是 https://cgiirw.github.io/2017/12/01/SpringBoot/ 页面内容。 同样的方法还可以修改User-Agent等。 参考Mac Fidder抓包替代方案Charles-proxy抓包工具下载+安装+破解charles.jar下载 Mac应用打开时，提示已损毁/来自身份不明开发者而无法打开的解决办法 解决Charles乱码问题 Mac上使用Charles抓包]]></content>
      <categories>
        <category>安装</category>
      </categories>
      <tags>
        <tag>Charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道几何题解]]></title>
    <url>%2F2018%2F07%2F11%2FElem_Geometry%2F</url>
    <content type="text"><![CDATA[浏览云风的BLOG，居然发现了一道初等几何题，拿起笔记本写了个答案。 这道题是这样的： 我的答案： 看到60度，直觉就是去构造正三角形了。]]></content>
      <categories>
        <category>初等数学</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Java函数式编程(七)：CompletableFuture实战]]></title>
    <url>%2F2018%2F07%2F02%2FJava8_FuncPro07%2F</url>
    <content type="text"><![CDATA[这篇文章记录《Java 8实战》第十一章的实例，将各个例子厘清，这里主要涉及到thenApply、thenAccept、thenCompose等函数的用法，通过这些例子了解CompletableFuture基本的使用方法。 异步获取产品价格第一个实例展示了一个基本的Future模式。 传统的获得价格的方式： 123public double getPrice(String product) &#123; return calculatePrice(product);&#125; 单纯返回计算结果。 异步方式： 12345678public Future&lt;Double&gt; getPriceAsync(String product) &#123; CompletableFuture&lt;Double&gt; futurePrice = new CompletableFuture&lt;&gt;(); new Thread( () -&gt; &#123; double price = calculatePrice(product); futurePrice.complete(price); &#125;).start(); return futurePrice;&#125; 该方式返回一个Future对象，当需要查询价格的时候再调用方法，这里新开了一个线程计算商品价格。 两种计算价格的方式最大区别在于在主线程中调用getPriceAsync()会早早返回。 用工厂方法创建CompletableFuture对象之前的写法太繁琐了有木有，而且还没有处理可能产生的异常。CompletableFuture提供了很多工厂方法，比如supplyAsync()，他接受一个生产者为参数，返回CompletableFuture对象： 123public Future&lt;Double&gt; getPriceAsync02(String product) &#123; return CompletableFuture.supplyAsync(()-&gt; calculatePrice(product));&#125; 这种方法和提供了错误管理机制的getPriceAsync方法(这里并没有提供错误处理)是完全等价的。 最佳价格查询器01：单纯采用stream()多个Shop对象(这里是4家)，每一个都要获取价格，第一种方式： 1234567// 该方法生成多个写死了店铺名生成的传入产品的价格，以一个列表的方式返回public List&lt;String&gt; findPrices(String product) &#123; return shops.Stream() .map(shop -&gt; String.format("%s price is %.2f", shop.getName(), shop.getPrice(product))) .collect(Collectors.toList());&#125; 输出： 12[BestPrice price is 123.26, LetsSaveBig price is 169.47, MyFavoriteShop price is 214.13, BuyItAll price is 184.74]stream done in 4060 msecs 串行流就是一个个挨着执行，没什么特别的。 最佳价格查询器02：采用parallelStream()将stream()更改为parallelStream()： 输出： 12[BestPrice price is 123.26, LetsSaveBig price is 169.47, MyFavoriteShop price is 214.13, BuyItAll price is 184.74]parallelStream done in 1043 msecs 并行流的结果确实很优秀！ 最佳价格查询器03：采用CompletableFuture首先要说明的是，这里的例子仍然采用串行流，实践起来分两步，第一步如下： 123456List&lt;CompletableFuture&lt;String&gt;&gt; priceFutures = shops.stream() .map(shop -&gt; CompletableFuture.supplyAsync( () -&gt; shop.getName() + "price is" + shop.getPrice(product))) .collect(Collectors.toList()); 在第一步采用了map函数后就用收集器收集是因为流操作之间的延迟性，这一步之后先创建多个Future对象，因为这些对象已经创建，所以即便发生getPrice的阻塞，也不会影响那些线程的执行，因为它们已经在之前start了。 第二步： 123return priceFutures.stream() .map(CompletableFuture::join) .collect(Collectors.toList()); join功能和get类似，只是不需要抛异常。 运行一下结果如下： 12[BestPriceprice is123.25651664705744, LetsSaveBigprice is169.4653393606115, MyFavoriteShopprice is214.12914480588853, BuyItAllprice is184.74384995303313]CompletableFuture done in 2028 msecs 最后的效果是02 &gt; 03 &gt; 01。 将上面的例子的条件更改成处理5个Shop对象，02的输出如下： 12[BestPrice price is 123.26, LetsSaveBig price is 169.47, MyFavoriteShop price is 214.13, BuyItAll price is 184.74, chenchen price is 219.55]parallelStream done in 2058 msecs 03的输出如下： 12[BestPriceprice is123.25651664705744, LetsSaveBigprice is169.4653393606115, MyFavoriteShopprice is214.12914480588853, BuyItAllprice is184.74384995303313, chenchenprice is219.5526451599223]CompletableFuture done in 2024 msecs 这个时候结果变成03 &gt; 02 &gt; 01。 从店铺数大于4开始，并行流和CompletableFuture开始不分伯仲，这是因为它们背后都是采用通用线程池来完成任务。 设置线程数实例中的线程池选取了newFixedThreadPool，它的corePoolSize和maximumPoolSize是相同的，这里本人比较关心守护线程的效果，先将其设置为true： 1234567891011private final Executor executor = Executors.newFixedThreadPool(Math.min(shops.size(), 100), new ThreadFactory() &#123; @Override public Thread newThread(Runnable r) &#123; Thread t = new Thread(r); t.setDaemon(true); return t; &#125; &#125; ); 主线程执行结束后程序就退出了，如果不将其设为守护线程，那么程序将会一直阻塞。之前在解析线程池的时候分析过shutdown()效果，newFixedThreadPool采用的是LinkedBlockingQueue()，当前任务执行完后线程池的线程不会自行结束，会阻塞在那等待新的任务。 添加折扣服务这里模拟远程的折扣服务，它出现在获得价格的操作之后，这里简单的说一说基础逻辑： 修改Shop类下的getPrice方法，将Shop名、价格、折扣码通过“:”组合成字符串，作为该方法的返回； 构造Quote类，该类提供parse静态方法对上一步返回的字符串进行解析，将解析的各部分保存在Quote类字段中； 创建Discount类，该类首先构造一个内部枚举类Code，保存已经设定好的折扣代码；再次提供私有方法apply()，该方法计算出折扣后的价格并返回，延迟模拟也放在该方法中；最后提供appDiscount方法，该方法将打折后的价格拼接成对用户友好的字符串并返回； 串行流执行添加折扣后的服务和之前的逻辑相似，先采用串行流，添加findPricesDis_stream方法： 1234567public List&lt;String&gt; findPricesDis_stream(String product) &#123; return shops.stream() .map(shop -&gt; shop.getPrice(product)) .map(Quote::parse) .map(Discount::applyDiscount) .collect(Collectors.toList());&#125; 在BestPriceFinderMain类中将相关方法切换为findPricesDis_stream并执行，最后输出结果： 12[BestPrice price is 110.934, LetsSaveBig price is 135.576, MyFavoriteShop price is 192.717, BuyItAll price is 184.74, chenchen price is 208.5725]Stream done in 10066 msecs 这个结果很好解释，整个执行属于顺序执行，期间一共阻塞过10秒。 使用CompletableFuture执行添加折扣后的服务这里就不演示并行流了，因为它和CompletableFuture都是通过线程池来实现，但是前者随着商店数增加扩展性不够好，而后者可以指定要执行的线程数。 直接代码放送： 1234567891011121314public List&lt;String&gt; findPricesDis_Compl(String product) &#123; List&lt;CompletableFuture&lt;String&gt;&gt; priceFutures = shops.stream() .map(shop -&gt; CompletableFuture.supplyAsync( () -&gt; shop.getPrice(product), executor)) .map( x -&gt; x.thenApply(Quote::parse)) .map(x -&gt; x.thenCompose(quote -&gt; CompletableFuture.supplyAsync( () -&gt; Discount.applyDiscount(quote), executor))) .collect(Collectors.toList()); return priceFutures.stream() .map(CompletableFuture::join) .collect(Collectors.toList());&#125; 输出： 12[BestPrice price is 110.934, LetsSaveBig price is 135.576, MyFavoriteShop price is 192.717, BuyItAll price is 184.74, chenchen price is 208.5725]CompletableFuture done in 2056 msecs 这个方法最主要的部分在于thenApply()以及thenCompose()。为了理解这两个函数，我们再将上面的例子分开书写，一个个研究： 12Stream&lt;CompletableFuture&lt;String&gt;&gt; cf01 = shops.stream().map(shop -&gt; CompletableFuture.supplyAsync( () -&gt; shop.getPrice(product), executor)); cf01是一个Stream]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Java 8</tag>
        <tag>CompletableFuture</tag>
        <tag>Future</tag>
        <tag>thenApply</tag>
        <tag>thenAccept</tag>
        <tag>thenCompose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Database习题 && MySQL基础]]></title>
    <url>%2F2018%2F07%2F01%2FMySQL-Getting-Start%2F</url>
    <content type="text"><![CDATA[LeetCode有一些数据库的题目，部分免费的题做一下；MySQL有一些最基础的知识，捡重要的mark一下。 LeetCode Database习题下列习题都通过了Navicat Premium环境的测试。 Swap Salary描述： 基本意思就是交换男女性别那栏，原本是‘男’就设为‘女’，原本是‘女’就设为‘男’，要求不使用临时表； 思路： 这里可以使用IF(expr1, expr2, expr3)，类似三目运算，expr1为条件。 解答如下： 1UPDATE `salary` set `sex` = if(`sex` = 'm', 'f', 'm'); Exchange Seats描述： 基本意思就是每两行中的奇数行和偶数行互换id，如果整个表中行数是奇数，那么最后一行不变； 解答如下： 12345678910111213141516CREATE TABLE count01 ( counts1 int(11));INSERT INTO count01 ( counts1 )SELECT COUNT(*) FROM seat;SELECT CASE WHEN id % 2 = 1 AND id != counts1 THEN id + 1 WHEN id % 2 = 1 AND id = counts1 THEN id ELSE id - 1 END id, studentFROM seat, count01ORDER BY id; CASE END是sql用来做条件语句的，这段代码先构造了一个表，然后把seat条目数存在表中，然后在后面的查询语句中，引用两个表seat和count01的栏位名来调用具体的值，进行逻辑处理，最后ORDER BY一下； 但是题目要求的是用查询语句，所以稍微改一下原本的代码： 12345678SELECT CASE WHEN id % 2 = 1 AND id != (SELECT COUNT(*) FROM seat) THEN id + 1 WHEN id % 2 = 1 AND id = (SELECT COUNT(*) FROM seat) THEN id ELSE id - 1 END id, studentFROM seat, count01ORDER BY id; Not Boring Movies描述： 基本意思就是在表中，查询奇数id且描述非“无聊”的电影，然后按照评分由高到低排列； 思路： 可以使用where语句，代码如下： 1SELECT * FROM cinema WHERE id % 2 = 1 AND description &lt;&gt; 'boring' ORDER BY rating DESC; Classes More Than 5 Students描述： 大致意思就是给你一个课程表，列出有五个及五个以上学生上课的课程； 思路： GROUP BY配合一些聚合函数使用，使用通用方法： 123SELECT "欄位1", SUM("欄位2")FROM "表格名"GROUP BY "欄位1"; 同时where不能和聚合函数一起使用，所以采用having，having进一步约束组数据，通用方法： 1234SELECT "欄位1", SUM("欄位2")FROM "表格名"GROUP BY "欄位1"HAVING (函數條件); 所以代码如下： 12SELECT `courses`.`class` FROM courses GROUP BY `courses`.`class`HAVING COUNT(*) &gt;= 5; 但是题目中有个提示： The students should not be counted duplicate in each course. 所以having的条件应该做一番更改： 12SELECT `courses`.`class` FROM courses GROUP BY `courses`.`class`HAVING COUNT(DISTINCT student) &gt;= 5; Big Countries描述： 大致意思是编写sql输出大国名称、人口以及面积，其中大国指的是面积超过300万活着人口超过2500万的国家； 思路： 使用where，代码如下： 12SELECT name, population, area FROM World WHERE population &gt; 25000000OR area &gt; 3000000; Rising Temperature描述： 大致意思就是找出比昨天温度高的日期的id； 思路： 使用表格别名，采用TO_DAYS函数编写条件语句，具体代码如下： 1234SELECT wtr01.IdFROM Weather AS wtr01, Weather AS wtr02WHERE TO_DAYS(wtr01.RecordDate) - TO_DAYS(wtr02.RecordDate) = 1AND wtr01.Temperature &gt; wtr02.Temperature; Delete Duplicate Emails描述： 大致意思是说编写SQL删除表中的相同条目的重复条目，仅保留相同条目中最小id的那一个条目； 思路： 如果给一个表创建两个别名，比如Person per01和Person per02，调用Id和Email进行比较，每次都是等号左边的先遍历完，通过这个性质可以删除重复的数据，代码如下： 123DELETE per01FROM Person per01, Person per02WHERE per01.Email = per02.Email AND per01.Id &gt; per02.Id; Customers Who Never Order描述： 大致意思是有两个表，分表表示订单和客户，订单中有标识消费过的客户的Id，找出订单中没有标识的客户（也就是没有买任何东西的客户）； 思路： 查询出Id不存在于订单中的客户，这里可以使in语法，in配合where使用，可以遍历多个值，代码如下： 1234SELECT c.`Name` AS CustomersFROM Customers cWHERE c.Id NOT IN(SELECT o.CustomerId FROM Orders o) Duplicate Emails描述： 大致意思是查找Person01表中所有重复的emails； 思路： 前面某题Delete Duplicate Emails类似，代码如下： 123SELECT DISTINCT per01.EmailFROM Person01 per01, Person01 per02WHERE per01.Email = per02.Email AND per01.Id &gt; per02.Id; 注：重复的数据在查询的结果中只出现一次； Employees Earning More Than Their Managers描述： 大致意思就是Employee表中包含了所有员工，每个员工对应一个经理Id，表拥有一个经理栏位，通过这个表查询出所有比经理赚得多的员工； 思路： 用别名的方式进行判断，代码如下： 123SELECT em01.`Name` AS EmployeeFROM Employee em01, Employee em02WHERE em01.ManagerId = em02.Id AND em01.Salary &gt; em02.Salary; Second Highest Salary描述： 意思就是查询Employee第二高薪； 思路： 使用LIMIT OFFSET，OFFSET采用习惯的从0起始，LIMIT表示条数，代码如下： 123SELECT Salary as SecondHighestSalaryFROM Employee01ORDER BY Salary DESC LIMIT 1 OFFSET 1; Combine Two Tables描述： 大意就是按要求合并两张表； 思路： 要求里有一句“regardless if there is an address for each of those people”，感觉可以用一个left join合并表，代码如下： 12SELECT FirstName, LastName, City, StateFROM Person02 LEFT JOIN Address ON Person02.PersonId = Address.AddressId; MySQL基础配置 brew install mysql的坑https://www.jianshu.com/p/bfb2569a017f 有具体步骤的注释； 涉及MySQL服务services https://zhuanlan.zhihu.com/p/30216245； 彻底删除过去版本的MySQL https://gist.github.com/vitorbritto/0555879fe4414d18569d 注意底下的留言； MySQL报错 http://blog.51cto.com/732233048/1636409 虽然对我没用； 查看版本：mysql –version； 启动MySQL：mysql.server start 登录，命令行：mysql -u root -p，然后输入密码； 基本库操作创建数据库CREATE DATABASE 数据库名; CREATE DATABASE IF NOT EXISTS 数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 不存在则创建，存在就不创建； 创建设定编码集为utf8； 倒入数据库，比如： source /Users/yin/Downloads/cgdb.sql; 删除数据库drop databse 数据库名; 选择数据库use 数据库名; 查询当前选择的数据库，使用select database();或者在命令模式使用status命令； 基本表操作创建表通用语法： CREATE TABLE table_name (column_name column_type); 如果不想字段为NULL可以设置字段的属性为NOT NULL，在操作数据库时如果输入该字段的数据为NULL，就会报错； AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1； PRIMARY KEY关键字用于定义列为主键。可以使用多列来定义主键，列间以逗号分隔； ENGINE设置存储引擎，CHARSET设置编码； 可以通过命令提示符创建表； 符号``是用来区分MySQL关键字与普通字符而引入的符号，一般表名和字段名都是用这个符号； 删除表通用语法： DROP TABLE table_name; drop truncate delete区别： drop整表删除，truncate会保留表结构，delete一般用在有条件删除部分表数据的情况； 基本表数据操作插入数据123INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); 如果数据是字符型，必须使用单引号或者双引号； 查询数据1234SELECT column_name,column_nameFROM table_name[WHERE Clause][LIMIT N][ OFFSET M] select * ：返回所有记录； limitN ：返回N条记录； offset M ：跳过M条记录，默认 M=0，单独使用似乎不起作用； limit N,M ：相当于offset N limit M，从第N条记录开始，返回M条记录； WHERE语句通用语法： SELECT field1, field2,…fieldN FROM table_name1, table_name2…[WHERE condition1 [AND [OR]] condition2… WHERE中比较运算符需要注意：&lt;&gt;，它表示不等于； UPDATE查询UPDATE table_name SET field1=new-value1, field2=new-value2[WHERE Clause] DELETE语句DELETE FROM table_name [WHERE Clause] LIKE子句在WHERE子句中使用LIKE，如果没有％单独使用LIKE，则效果和＝相同。 通用语法： SELECT field1, field2,…fieldNFROM table_nameWHERE field1 LIKE condition1 [AND [OR]] filed2 = ‘somevalue’ 123456'%a' //以a结尾的数据'a%' //以a开头的数据'%a%' //含有a的数据'_a_' //三位且中间字母是a的'_a' //两位且结尾字母是a的'a_' //两位且开头字母是a的 UNION操作符通用语法： 1234567SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]; UNION操作符用于连接两个以上的SELECT语句，将结果组合到一个集合中，多个SELECT语句会删除重复的数据； UNION只会选取不同的值(类似set)，如果要保留重复的值，使用UNION ALL； ORDER BY语句12SELECT field1, field2,...fieldN table_name1, table_name2...ORDER BY field1, [field2...] [ASC [DESC]] 你可以使用ASC或DESC关键字来设置查询结果是按升序或降序排列。默认情况下，它是按升序排列； 字符集采用utf8需转码： ORDER BY CONVERT([xxxxx] using gbk); GROUP BY语句通用语法： 1234SELECT column_name, function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name; WITH ROLLUP：统计之后再做统计； 事务在 MySQL中只有使用了Innodb数据库引擎的数据库或表才支持事务； 事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行； 事务用来管理insert, update, delete语句； A原子性C一致性I隔离性D持久性； BEGIN或START TRANSACTION；显式地开启一个事务； COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的； ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT； RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； ROLLBACK TO identifier；把事务回滚到标记点； SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE； 临时表临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。 通用写法： CREATE TEMPORARY… 可以使用DROP TABLE手动删除MySQL临时表； SQL注入要注意的几点： 通过字符串拼接容易产生SQL注入，Java里可以用PreparedStatement处理，原理就是转义单引号，但是％没有转义(可以通过严格限制用户输入来解决)； mybatis不会对${}参数进行预处理，会对#{name}进行预处理； 一些概念SET FOREIGN_KEY_CHECKS = 0; 取消外键约束； \G 按列打印； 参考LeetCode MySQL教程 SQL语法教学 runoob.com SQL教程]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Java函数式编程(六)：重构设计模式]]></title>
    <url>%2F2018%2F06%2F29%2FJava8_FuncPro06%2F</url>
    <content type="text"><![CDATA[本篇将讨论用Java 8函数式编程的方式重构设计模式。 重构策略模式什么是策略模式可以查看本站以往的文章策略模式，接下来将重构那篇文章中的代码。 在那篇文章中，策略是针对选橘子(Orange)的喜好(UniqueHobby)而制定的，选Kind1调用方法将打印“红色水果”，选Kind2将打印”黄色水果”。Orange的实现如下： 12345678910111213141516abstract class Fruit &#123; UniqueHobby uniqueH; public abstract void cleanliness(); public void performMethod() &#123; uniqueH.uniqueHobby(); &#125;&#125;class Orange extends Fruit &#123; public Orange (UniqueHobby uh) &#123; uniqueH = uh; &#125; public void cleanliness() &#123; System.out.println("水果已被服务人员清洗干净"); &#125;&#125; 构造器传递一个UniqueHobby的实例，通过调用Orange父类的performMethod方法，执行UniqueHobby实例的方法。 那么如何使用Lambda表达式重构呢？ 直接比较main方法内调用的情况： 12345678Fruit o1 = new Orange(new Kind1());Fruit o2 = new Orange(new Kind2());o1.cleanliness();o1.performMethod();o2.performMethod();Fruit o3 = new Orange(() -&gt; System.out.println("绿色水果"));o3.performMethod(); o1和o2是没重构之前的策略模式产生的策略，而在重构的代码中直接传入了Lambda表达式，原理就在于，这里将UniqueHobby当作一个函数式接口，通过实现uniqueHobby方法实现策略。 《Java 8实战》强烈推荐使用Lambda表达式来解决这类问题。 重构观察者模式什么是观察者模式可以查看本站以往的文章观察者模式，接下来将重构那篇文章中的代码。 在书中，Lambda运用在主题注册观察者的行为上，结合本人自己的例子，也就是将订阅者的接口当作函数式接口： 123interface C &#123; public void update(String when, String where, String what);&#125; 接下来直接在main方法添加代码： 12345P specP = new ImlP();C specC = new ImlC(specP);specP.registerC((x, y, z) -&gt; System.out.println("时间：" + x + "\n地点：" + y + "\n事件：" + z));((ImlP) specP).reSetData("早上十点", "火星", "人类探测器着陆"); 未重构之前的代码将注册、修改、打印输出分别放在构造方法和两个重写的方法中，而在这里通过一行代码完成了这些逻辑。 重构职责链模式什么是职责链模式可以查看本站以往的文章职责链模式，接下来将重构那篇文章中的代码。 未重构之前，构造了一个SendToMember抽象类，它不仅抽象了厌食、偏食以及通食这三类人群，还提供了职责传递的方法sendToMember()，接下来的重构过程中，将摒弃该类。 首先采用一个一元运算接口UnaryOperator创建childHandle： 1UnaryOperator&lt;Thing01&gt; childHandle = x -&gt; x; 这就好比一个管道，管道这边传入产品，从那头输出产品，只不过这里的代码更关注产品怎么“流通”，而不是专注于管道怎么搭建。这里的“x”就是指代买来全家享用的产品。由于小孩”厌食”，食品没有在小孩这关留下“痕迹”。 然后是母亲这关： 1234567UnaryOperator&lt;Thing01&gt; mumHandle = x -&gt; &#123; if (x != null &amp;&amp; x.getF().getColor().equals("red")) &#123; System.out.println("被Mum吃掉"); return null; &#125; return x;&#125;; 母亲是挑食者，所以在方法体中添加上if语句，这里没有经过任何柯里化处理，但相较未重构前，逻辑非常清晰，一旦食品被母亲吃掉，将返回null，整个流程就是食物“悲惨一生”的过程。 最后是父亲： 1234567UnaryOperator&lt;Thing01&gt; fatherHandle = x -&gt; &#123; if (x != null) &#123; System.out.println("被father吃掉"); return null; &#125; return x;&#125;; 只要之前食品没有被吃掉，那么就“吃掉”然后返回null，父亲是最后的“光盘”捍卫者。 最后用andThen将各部分串联成流水线： 123Function&lt;Thing01, Thing01&gt; pipline = childHandle.andThen(mumHandle).andThen(fatherHandle);Thing01 last = pipline.apply(new Thing01(new Apple00())); 这里要小心每个环节的输入与输出，andTen()是Function提供的一个默认方法，Function还提供了另一个默认方法compose()，这两者执行顺序相反。 模板方法 &amp; 工厂模式模板方法和环绕执行的思路是相似的，而工厂模式的重构借助了方法引用。比如： 12Supplier&lt;Product&gt; loanSupplier = Loan::new;Loan loan = loanSupplier.get(); 这里借用了书上的例子，只是为了做一个基本的样例，理解起来相比前面介绍的重构方法更加简单。 小结本文旨在举例说明用Lambda表达式重构传统设计模式的一般方法。总体而言，Lambda表达式写出来的代码更清晰更易读也更简洁。 参考如何正确地使用设计模式？]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Java 8</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Java函数式编程(五)：函数式思维与尾递归]]></title>
    <url>%2F2018%2F06%2F28%2FJava8_FuncPro05%2F</url>
    <content type="text"><![CDATA[这篇文章介绍函数式编程概念和尾递归。 什么是函数式编程首先要厘清一些概念。 命令式 &amp; 声明式：编程一般遵循两种范式，一种是“命令式”，一种是“声明式”。前者专注于“如何做”，它的指令和计算机底层词汇非常接近，比如赋值、条件分支以及循环；后者则强调“做什么”，制定规则给出目标，如何实现交给系统决定。面向对象编程和函数式编程分别具体实践了这两种范式； 纯粹的、无副作用的：一个方法不修改宿主类的状态，也不修改其它对象的状态，使用return返回所有的计算结果； 引用透明的：函数只要传递同样的参数值，总是返回同样的结果； 纯粹的函数式编程和函数式编程：前者不存在任何副作用，后者存在副作用，但不被该函数的调用者感知，或调用者不在意这些副作用(因为对调用者完全没有影响)； 被称为“函数式”的函数：只能修改本地变量，引用的对象都应该是不可修改的对象，不应抛出任何异常； 局部函数式：对某一部分输入值，结果是未定义的(输入有范围)； 没有可感知的副作用：不改变对调用者可见的变量、不进行I/O、不抛出异常； 记忆化/缓存：属于引用透明的重要属性，目的是避免重复计算； 通过上面这些概念，我们很容易对函数式编程有一个初步的认识。 这里放上维基百科的定义： 函数式编程（英语：functional programming）或称函数程序设计，又称泛函编程，是一种编程典范，它将计算机运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。 比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。 尾递归纯粹的函数式编程语言不包含while和for这样的迭代器，因为诱导修改对象；而使用递归可以消除每步都需要更新的迭代变量，在函数式编程中，递归的使用相当普遍。 但是通过学习虚拟机后容易知道，方法的调用无非就是在虚拟机栈上创建新的栈帧，请看下面这种情形： 123456789101112131415public class StackDemo &#123; public static void main(String[] args) &#123; int n = 5; int num = add01(n); System.out.println(num); &#125; static int add01(int x) &#123; System.out.println("add01: " + x); return x == 1 ? 1 : 2 * add01(x - 1); &#125;&#125; 上述代码输出结果为： 123456add01: 5add01: 4add01: 3add01: 2add01: 116 在add01方法中，return语句的三目运算如果执行到了2 * add01(x - 1)，就会再次调用add01(x - 1)，此时原本的方法并没有执行结束，局部变量表仍开辟着内存，如此递归调用将导致不菲的开销，很容易造成StackOverflowError异常，从输出结果也可以看出，每次递归调用方法都执行了打印语句。 一种解决上述问题的方式是：方法采用尾递归，然后进行尾递归优化。 在原代码基础上添加add02方法： 1234567891011121314151617181920212223242526272829public class StackDemo &#123; public static void main(String[] args) &#123; int n = 5; int num = add01(n); System.out.println(num); int num02 = add02(n); System.out.println(num02); &#125; static int add01(int x) &#123; System.out.println("add01: " + x); return x == 1 ? 1 : 2 * add01(x - 1); &#125; private static int add0(int acc, int x) &#123; System.out.println("add02: " + x); return x == 1 ? acc : add0(acc * 2, x - 1); &#125; static int add02(int x) &#123; return add0(1, x); &#125;&#125; 以上代码输出： 123456789101112add01: 5add01: 4add01: 3add01: 2add01: 116add02: 5add02: 4add02: 3add02: 2add02: 116 add02采用了尾递归的写法，同样得到了正确的结果。 如果本例进行了尾递归优化，本例的执行将变成如下的伪代码(参考Tail Call Optimization and Java的分析)： 12345678call add02(5) call add0(1, 5) update variables with (2, 4) update variables with (4, 3) update variables with (8, 2) update variables with (16, 1) return 16return 16 可见该优化是通过迭代的方式，将局部变量表中的数据替换掉，以此减少栈的开销。 遗憾的是Java不支持尾递归优化，但是《Java 8实战》一书还是提倡用Stream取代迭代，用递归替换迭代，作者认为大多数时候编程效率要比细微的执行时间差异更重要。 参考Tail Call Optimization and Java Scala是如何实现尾递归优化的？]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Java 8</tag>
        <tag>尾递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Java函数式编程(四)：使用Lambda重构代码]]></title>
    <url>%2F2018%2F06%2F26%2FJava8_FuncPro04%2F</url>
    <content type="text"><![CDATA[Lambda真是极好的！使用Lambda先从重构旧代码开始。《Java 8实战》对其进行了讲解，本章将按照此书的脉络进行组织，对相关章节进行复习总结。 改善代码的可读性利用Lambda表达式可以写出更简洁、更灵活的代码。 匿名类 PK Lambda在很多场景中，匿名类都能被Lambda取代，但在这之前，需要了解两者之间的三点不同。 this &amp; super在匿名类中，this代表的是类本身，而在Lambda中，代表的是宿主类。 字段隐藏我们都知道，Java的动态分派体现在方法的调用上，字段不存在“重写”只能靠隐藏。如果在一个方法中出现下列代码： 12345int a = 10;Runnable r1 = () -&gt; &#123; int a = 2; int b = 3;&#125;; 编译器就会报错：Variable ‘a’ is already defined in the scope，而在匿名类中不会出现这样的问题，所以Lambda不能做字段隐藏。 方法重载方法重载时，Lambda会遇到引用不明的问题，看下面的代码，它构造了一个函数式接口，并添加两个重载方法： 123456789101112public static void doSomeThing(Runnable r) &#123; System.out.println("Runnable");&#125;public static void doSomeThing(Task t) &#123; System.out.println("Task");&#125;@FunctionalInterfacepublic static interface Task &#123; public void todo();&#125; 在main方法中调用doSomeThing(() -&gt; System.out.println());编译器会提示说对doSomeThing的引用不明确，解决办法是采用显示类型转换：doSomeThing((Task) () -&gt; System.out.println());。 转换为方法引用方法引用可以增加代码的可读性，能直观的表达代码的意图，格式为[类名]::[方法名]。 尽量考虑静态辅助方法，比如comparing、maxBy，这些方法设计之初就考虑了会结合方法引用一起使用。 增加代码的灵活性行为参数化可以帮助程序员淡定的面对需求变化，这里介绍两种通用模式：有条件执行和环绕执行。 有条件延迟执行Lambda表达式是惰性求值的，这有利于行为参数化，所谓行为参数化，我的理解就是作为行参传入时只做行为描述，并不执行具体方法，仔细看下面的例子： 12345678910111213141516171819202122232425262728293031323334353637383940public class LambdaTestDemo04 &#123; public static void main(String[] args) &#123; int num01 = getNumber01(x -&gt; &#123; System.out.println("Lambda"); return x + x; &#125;, 3); System.out.println("getNumber01: " + num01); int num02 = getNumber02(getNumber03(1), 3); System.out.println("getNumber02: " + num02); &#125; public static int getNumber01(Func&lt;Integer&gt; func, int x) &#123; if (x &lt; 3) return func.get(x); return -1; &#125; public static int getNumber02(int t, int x) &#123; if (x &lt; 3) return t + x; return -2; &#125; public static int getNumber03(int x) &#123; System.out.println("getNumber03"); return x + x; &#125; @FunctionalInterface public static interface Func&lt;Integer&gt; &#123; int get(int x); &#125;&#125; getNumber01和getNumber02是两个静态方法，它们是参数传入的方法。getNumber01中传入的是Lambda表达式，表达式描述的方法包含一个输出语句System.out.println(&quot;Lambda&quot;);，目的是检测它是否在作为参数传入时就执行；getNumber02中传入的是一个普通的静态方法，该方法返回一个int值，同时其方法体内也包含一个输出语句System.out.println(&quot;getNumber03&quot;);。 由于初始条件的限制，getNumber01和getNumber02在运行的过程中皆不执行if内的return语句，结果如下： 12345getNumber01: -1getNumber03getNumber02: -2Process finished with exit code 0 Lambda表达式没有执行方法内的打印语句，而普通静态类执行了内部的打印语句，此结果验证了Lambda是有条件的延迟执行。 《Java 8实战》一书中举了一个日志查询的例子，用实例分析了Lambda表达式延迟执行的各种好处，比如更易读封装行更好、满足条件才真正执行方法等。用重载构造log方法提供了一个改造旧代码的范例。 环绕执行环绕执行的具体实现，和前文用重载构造log的实现异曲同工。在书中列举了一个多业务代码“共享”一套准备和清理的例子，这里采用了try-with-resource。 首先当然是函数式接口的创建： 1234@FunctionalInterfacepublic static interface BufferedReaderProcessor &#123; String process(BufferedReader b) throws IOException;&#125; 然后生成一个静态的执行方法： 12345public static String processFile(BufferedReaderProcessor b) throws IOException &#123; try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) &#123; return b.process(br); &#125;&#125; 接下来就可以通过Lambda表达式实现各种业务逻辑，比如下面的代码中处理了两行： 1String oneLine = processFile(x -&gt; x.readLine() + x.readLine()); 以上就是一个环绕执行的简单实现。 小结本文首先比较了匿名类和Lambda，然后介绍了两种通用的重构模式，有条件延迟执行模式和环绕模式。]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Java 8</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收看世界杯并快记常用Vim命令]]></title>
    <url>%2F2018%2F06%2F22%2FLearning_Vim%2F</url>
    <content type="text"><![CDATA[Intellij Idea上集成有IdeaVim插件，想来，一套Vim操作就可以适应多个编辑环境，确也诱人；那边厢，世界杯如火如荼，激战正酣，本人花费不少时间收看，实在精彩；怎么结合世界杯快速入门Vim命令呢？思索过后有了下文中的小小尝试。 写在之前足球于我实在是再熟悉不过，本人不仅常年收看足球转播，也亲上球场踢球，踢罢还玩实况足球游戏，正因如此，大脑里查询很多知名球员的信息，时间复杂度基本满足O(1)。如果借助这些球员来帮助记忆，效率可能会提高不少。这里必须强调的是，进行本次记忆尝试需要对采用的球员做到充分熟悉，至少看到名字能想到脸，看到脸能立马想到名字或者相关事迹，再就是构建模型的时候，采用第一时间联想到的事务关系。 话不多说，下面就构建对应模型。 建模世界杯技术含量一般被认为达不到欧冠的水准，参与的球队也是参差不齐。本人选取了三支球队来进行实验，它们分别是德国队、西班牙队和巴西队，选取这三支的原因很简单，它们每个队的绝大部分球员我都熟稔于心，下面先构建“德国队模型”。 德国队模型这里选取了十一名球员，守门员有两人，没有按照一支球队的正常结构来遴选，这也是因为本人选取球员首先要满足的条件就是对这个球员是要做到充分熟悉。 戈麦斯 x：剪切当前光标的字符 老实说戈麦斯已经淡出本人视野很长时间了(x)，但是并不代表他会被人遗忘，世界杯带上他可能是因为现在德国确实缺少这样的中锋，另一方面他所具有的大赛经验也能在关键时候帮助到球队，x的有未知的意涵，代表了他就是球队里那个熟悉的陌生人； 罗伊斯 dd：剪切当前光标所在行 dd这个命令似乎配上乌姆蒂蒂更合适？不存在的，罗伊斯长着一副娃娃脸，在德国队的前锋中算是小个的了，给人小弟弟般的形象也是情理之中，罗伊斯的进攻还是很犀利的，横扫后卫线有没有？dd整条后卫线的事情时有发生； 穆勒 P/p：光标前一排粘贴/光标后一排粘贴(大的总在“前”) 穆勒在坊间被称作“二娃”，这个外号似乎比p孩来得更幼稚，p这个命令就你了，粘贴(p)在后卫身边，常常销魂般的被后卫挤倒，点球！！！！你不是一个人在战斗； 京多安 a：光标后插入字符(i是光标前插入，大写参考后文的米兰达) 京多安是那种，只要后卫线一不留神漏出空档，他就能插入(a)的球员，这个赛季在俱乐部又多次高光时刻，德国队前场需要这样的小快灵球员； 厄齐尔 O/o：当前行前插入一行/当前行后插入一行 有人盯着你的球技，有人盯着你的眼睛...和京多安祖籍都来自土耳其，两人组成OA组合，厄齐尔通过传球将对方后场撕开一排排空档(o)，名副其实的德国队前场发动机； 赫迪拉 0：移动到行首 外号脸哥的赫迪拉，自然需要0这样的命令来搭配，有脸有首(0)，行业翘楚； 克罗斯 $：移动到行尾 克罗斯应该是德国国家队里奖金拿到手软的那个人吧，刚刚随皇马拿到了欧冠冠军，这几年不知道拿了多少冠军，给你个$可不要太骄傲。小组赛第二场最后时刻绝杀，真正的大心脏，走在最后压轴($)的球员； 博阿滕 ^：移动到行内第一个非空白字符 博阿滕的发型真的像极了^这个符号，行内第一个非空白字符(^)，脸哥背后的屏障； 胡梅尔斯 g_：移动到行内最后一个非空白字符 一副大哥哥(g_)的样子，行内最后一个非空白字符(g_)，协防着克罗斯； 诺伊尔 /pattern(配合n)：搜索pattern 诺伊尔的大脚就是一个搜索器(/pattern)，每次都能找到前场不停挥手的二娃； 特尔施特根 yy：复制当前行 特尔施特根是我见过好胜心最强的守门员了，刚到的时候在巴萨打替补(但是是欧冠主力门将)，就暗暗表达想踢全勤主力，世界杯之前对诺伊尔伤愈复出就踢主力门将颇有想法，私底下没少yy自己是德国第一门将吧，有上进心的球员都是好榜样！希望他以后复制(yy)德国门将一贯优良的表现； 十一个命令就这样解析完了，似乎也不是很难，而且这个构建的过程也没有花费太长时间， 西班牙队模型 迭戈科斯塔 N command：重复某个命令N次 迭戈科斯塔外号盛世美颜，一直觉得这个外号非常霸气。给盛世美颜搭配这个命令没有什么大的逻辑，就是认准了美颜足够霸气，命令足够强大，不需要讲额外的大道理； 伊斯科 gg：到第一行 在皇马人人都要守法，长传找前排(gg)C罗啊，这个命令够直接； 伊涅斯塔 *：匹配光标当前所在单词，移动光标到下一个 Tiki-taka讲究传控，将球短传给下一个相同风格的球员； 席尔瓦 #：匹配光标当前所在单词，移动光标到上一个 席尔瓦也是注重短传渗透的球员，接到球会给上一个相同风格的球员一个大拇指； 蒂亚戈 %：光标移动到匹配括号 能力非常强，我非常喜欢的球员，但比起前辈还稍显稚嫩，匹配括号(%)吧； 科克 .：重复上一个修改 和美颜都隶属马德里竞技队，工兵型球员，严格执行教练上一条修改命令(.)，一个`.`诠释了这个球员的踢球特点； 布斯克茨 G：到最后一行 巴萨球员和皇马球员就像是正负的两极，伊斯科爱前场找C罗，布斯克茨爱回传门将(G)； 拉莫斯 w：到下一个单词的开头 拉莫斯的头球确实是好，以至于到下一个单词(w)也是他开头； 皮克 e：到下一个单词的结尾 皮主席说，拉莫斯啊，你开头那我结尾(e)，我们组成we组合，我们(we)都是一一个球队，我们要相亲相爱； 阿尔巴 cw(dw)：从光标位置开始(包含光标所在位置)，修改单词 见过阿尔巴长途奔袭截断(cw)对方前锋的球么？铲(c)完(w)会露出鼹鼠般的微笑； 德赫亚 :N：跳转到第N行 不止诺伊尔会踢大脚啊，德赫亚也会啊，你说你要踢到哪一排(:N)去，他保准差不离； 西班牙的球员也已经解析完毕，下面赶快去领略花哨的桑巴足球吧。 巴西队模型这一小节会涉及两个花哨的技巧，我将它们分别赋予内马尔和库蒂尼奥，他们也是巴西队最重要的两名球员， 内马尔 &lt;C-v&gt; &lt;C-d&gt;/k I/A [ESC]：块操作块操作其实也是一套“组合拳”，下面示例了一个简单的例子，实现了在圈选的块区域后面添加test01。具体命令是这样的：首先&lt;C-v&gt;，然后hjkl选取区域，接着传给后排插入的米兰达(A/I)，让他完成最后的动作； 威廉 fx：当前行中，移动到字符x(可选)下次出现的位置 威廉不仅是一匹快马，还有一脚远射的能力，下一次射门能迅速将球轰向相同(fx)的地方(威廉的远射有一种魔力，那就是每次都是相同角度相同发力相同打到门柱...) 道格拉斯科斯塔 tx：在当前行中，移动到字符x(可选)前一个字符 和威廉一样，跑动非常积极，出现在威廉炮轰前一个位置(tx)； 库蒂尼奥 &lt;action&gt;a&lt;object&gt; 、 &lt;action&gt;i&lt;object&gt;：区域选择(vaw、vi[、vw、vb) 区域选择可以很方便的对某些范围内的字符串进行操作，比如下面示例中，使用了`v2i[`获取最外层中括号内的内容； 保利尼奥 b：移动到上一个单词的开头 中超的骄傲，巴萨球员再一次和皇马球员打了个对立面，拉莫斯是下一个单词的开头，保利尼奥是上一个单词的开头(b)，让我们记住：b字开头，保利尼奥； 费尔南迪尼奥 J： 把后续行连接起来 一个后场的组织者，连接器(J)，很好的把后场串联起来； 米兰达 A/I：从行尾开始插入字符/从行首开始插入字符 我认识的米兰达永远是马竞那个时期的米兰达，长相不输马云，马云是ET，你是AI人，米兰达作为后卫在对方禁区插上头球在本方禁区插入补位(A/I)还是很给力的； 蒂亚戈席尔瓦 xp：当前字符右移 xp本是组合命令，在这里不应单独列出，但是xp很好的诠释了一个后卫的职责，那就是从前绕到前锋后面进行断抢； 费利佩 =：一种自动缩进 费利佩是我见过最坚强的球员，他在球场多次断腿，但每次一次的等待(＝)后，都能见证他重回球场，他的收缩防守也是一个特点，我很佩服这样的球员； 马塞洛 &lt;&gt;：左右缩进 还用介绍么？全场缩进防守又飞奔助攻啦(&lt;&gt;)，太恐怖啦； 达尼洛 r：替换当前字符 心爱的阿尔维斯受伤了，达尼洛替换掉(r)了阿尔维斯； 到这里巴西队的模型也已经建构完成。 小结整个记忆的过程其实是非常轻松的，因为Vim常用命令并不是很多，只采用了三支有代表性的足球队，当然，Vim的强大还在于它命令的组合方式，比如%s/[被替换的部分]/[替换的部分]/g、yaw、daw等等，但这些组合也是基于前文给出的基本命令，需要在实战中慢慢掌握摸索；还有要说明的是，本篇小文重点在于识记，没有介绍宏录制(比如操作：@q[指定一个键] [具体操作] esc q)以及分屏(split)等功能，这些功能不便于利用文中介绍的方法记忆，而是需要不断的练习；一些最最基础的命令比如hjkl、:wq、:q!，也没有罗列，因为本就很熟悉，大脑查询它们已经可以做到时间复杂度O(1)了。 参考录屏采用asciinema，相关命令如下： 12$ brew install asciinema$ asciinema rec Vim Cheat Sheet 简明VIM练级攻略 为什么你应该在Linux中使用Vi / Vim文本编辑器的10个理由 教你使用asciinema录制命令行操作]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Java函数式编程(三)：收集器入门]]></title>
    <url>%2F2018%2F06%2F21%2FJava8_FuncPro03%2F</url>
    <content type="text"><![CDATA[本篇将入门Java函数式编程中的收集器。 收集器相关操作之前提到过及早求值方法和惰性求值法，而它们的区别通常就和收集器的存在有关，简单的说，收集器可以从流生成复杂值。 在开始收集器各操作之前，先构造一个用于测试的实例，在该实例中，最重要的就是创建了一个HashMap对象，该对象放入了5组键值对，后续很多用收集器操作的数据都来自于此： 123456Map&lt;String, String&gt; nameAndArt = new HashMap&lt;&gt;();nameAndArt.put("cg01", "010101");nameAndArt.put("cg001", "001001001");nameAndArt.put("cg002", "002002002");nameAndArt.put("cg003", "003003003");nameAndArt.put(null, "nullnullnull"); 转换成其它集合首先HashMap对象不能直接流化，nameAndArt.stream()报错。要想使nameAndArt中的成员对应单个流元素，可以采用entrySet()： 1System.out.println(nameAndArt.entrySet().stream().collect(Collectors.toSet())); 运行结果： 123[cg003=003003003, null=nullnullnull, cg002=002002002, cg01=010101, cg001=001001001]Process finished with exit code 0 在具体的实操中，要注意区分Stream.of和stream()的区别，看下面的代码： 12345678nameAndArt02.putAll(nameAndArt);List l = new ArrayList();l.add(nameAndArt);l.add(nameAndArt02);System.out.println(l.stream().collect(Collectors.toList()));System.out.println(Stream.of(nameAndArt, nameAndArt02).collect(Collectors.toList())); 这段代码打印出的结果是： 12[&#123;null=nullnullnull, cg01=010101, cg002=002002002, cg003=003003003, cg001=001001001&#125;, &#123;null=nullnullnull, cg01=010101, cg002=002002002, cg003=003003003, cg001=001001001&#125;][&#123;null=nullnullnull, cg01=010101, cg002=002002002, cg003=003003003, cg001=001001001&#125;, &#123;null=nullnullnull, cg01=010101, cg002=002002002, cg003=003003003, cg001=001001001&#125;] 结果上它们完全相同，但是第二个打印语句中可以调用HashMap的方法： 1System.out.println(Stream.of(nameAndArt, nameAndArt02).map(x -&gt;x.entrySet()).collect(Collectors.toList())); 第一句不能完成x.entrySet()的调用，但是第一句可以通过filter方法进行条件过滤，所以每个HashMap对象仍对应一个流元素。 转换成List的方法就是将toSet改成toList，如果要指定转换的具体类型，可以使用下面这种方式： 12345List list = nameAndArt.entrySet() .stream() .collect(Collectors.toCollection(ArrayList::new));System.out.println(list); 需要转换成什么类型就将toCollection中的参数进行指定即可。 Lambda表达式可以赋给Function接口，然后再作为参数进行传递。比如： 1Function&lt;HashMap.Entry&lt;String, String&gt;, Integer&gt; re = x -&gt; x.getValue().toString().length(); 接下来就以这个函数为比较逻辑，求出一个minBy： 12345Optional&lt;Map.Entry&lt;String, String&gt;&gt; min = nameAndArt.entrySet() .stream() .collect(Collectors.minBy(Comparator.comparing(re)));System.out.println(min); 最后输出为： 123Optional[cg01=010101]Process finished with exit code 0 数据分类这里的分类，包含分块和分组。所谓分块，就是将流分解成两个集合。通过收集器返回的是一个Map，键为true和false，直接看代码就明白了： 12345System.out.println(nameAndArt.entrySet().stream() .collect(Collectors.partitioningBy(x -&gt; x.getKey() == null)));System.out.println((nameAndArt.entrySet().stream() .collect(Collectors.partitioningBy(x -&gt; x.getKey() == null)) instanceof Map)); 输出： 12&#123;false=[cg01=010101, cg002=002002002, cg003=003003003, cg001=001001001], true=[null=nullnullnull]&#125;true 所谓分组，比前面提到的分块更自由和灵活，生成的Map对象的键不局限于true和false，下面用代码说明： 12System.out.println(nameAndArt.entrySet().stream() .collect(Collectors.groupingBy(x -&gt; x.getValue()))); 输出： 1&#123;010101=[cg01=010101], 001001001=[cg001=001001001], nullnullnull=[null=nullnullnull], 002002002=[cg002=002002002], 003003003=[cg003=003003003]&#125; 仍然是返回一个Map对象，但这里被要求以x.getValue()为键进行分组。 Collectors的功能很强大，还提供joining方法，处理字符串流，也举一个简单的例子说明： 12System.out.println(Stream.of("asdad", "safaf", "adasd") .collect(Collectors.joining("*", "%", "%"))); 输出： 1%asdad*safaf*adasd% &quot;*&quot;, &quot;%&quot;, &quot;%&quot;分别代表分隔符，前缀和后缀。 组合收集器之前分组的例子中，以值为键并以键值对为值创建Map对象打印输出，能否在原有代码基础上，将输出的格式改变为以值为键以键作为组成列表的元素的形式呢？ 采用组合收集器的方式，代码： 12System.out.println(nameAndArt.entrySet().stream() .collect(Collectors.groupingBy(x -&gt; x.getValue(), Collectors.mapping(x -&gt; x.getKey(), Collectors.toList())))); groupingBy函数内嵌入mapping函数，mapping内嵌入toList函数，这种组合的方式相较于传统的循环语句，逻辑更加清晰。 输出为： 1&#123;010101=[cg01], 001001001=[cg001], nullnullnull=[null], 002002002=[cg002], 003003003=[cg003]&#125; 小结本篇主要专注于收集器，罗列了它的一些主要的操作，也了解了点这方面的编程细节。 参考《Java 8函数式编程》]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Java 8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Java函数式编程(二)：Java 8接口新特性]]></title>
    <url>%2F2018%2F06%2F20%2FJava8_FuncPro02%2F</url>
    <content type="text"><![CDATA[本文主要介绍Java 8引入的默认方法以及接口静态方法等新特性，涉及了Lambda表达式作为参数参与方法重载、引入了默认方法的接口多重继承以及Optional数据类型等内容。 默认方法简单的说，默认方法的出现是为了保持Java语言不同版本的兼容性。比如Collection接口增加了stream方法，每个实现了Collection接口的子类都要添加对方法stream的实现，如果只是JDK内部还好，但非JDK的类也可能实现了之前版本的Collection，这样在没有重写的情况下必然造成不兼容。 例如Iterable接口就添加了新的默认方法：forEach，和for的区别是可以传入Lambda表达式作为循环体： 12Iterable&lt;Integer&gt; iterator = list ; // 1, 2, 3, 4, 5iterator.forEach(x -&gt; System.out.println(x * x)); 它的内部实现是这样的： 12345default void forEach(Consumer&lt;? super T&gt; action) &#123; for (T t : this) &#123; action.accept(t); &#125;&#125; 切记它的返回值是void。 在Java 8中如果涉及复杂的继承和实现关系，调用的到底是哪一个类或者接口的方法呢？ 《Java 8函数式编程》中采用了如下的例子进行说明： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class TestExtendsDefaultMethodDemo &#123; public static void main(String[] args) &#123; // 子类ParentImpl实现了接口Parent，但是没有重写接口的默认方法 Parent parentimpl = new ParentImpl(); parentimpl.welcome(); System.out.println(parentimpl.getMessage()); // 另一个接口Child继承了接口Parent并重写了其默认方法，构造子类ChildImpl实现接口Child Child childimpl = new ChildImpl(); childimpl.welcome(); System.out.println(childimpl.getMessage()); // 用一个新类OverridingParent继承ParentImpl，并重写默认方法 Parent overridingParent = new OverridingParent(); overridingParent.welcome(); System.out.println(overridingParent.getMessage()); // 创建新的类OverridingChild继承OverridingParent并实现Child Child child = new OverridingChild(); child.welcome(); System.out.println(child.getMessage()); &#125; static interface Parent &#123; public void message(String body); public default void welcome() &#123; message("Parent"); &#125; public String getMessage(); &#125; static class ParentImpl implements Parent &#123; String body; @Override public void message(String body) &#123; this.body = body; &#125; @Override public String getMessage() &#123; return body; &#125; &#125; static interface Child extends Parent &#123; @Override default void welcome() &#123; message("Child"); &#125; &#125; static class ChildImpl implements Child &#123; String body; @Override public void message(String body) &#123; this.body = body; &#125; @Override public String getMessage() &#123; return body; &#125; &#125; static class OverridingParent extends ParentImpl &#123; @Override public void welcome() &#123; message("OverridingParent"); &#125; &#125; static class OverridingChild extends OverridingParent implements Child &#123;&#125;&#125; 该代码输出为： 123456ParentChildOverridingParentOverridingParentProcess finished with exit code 0 到底调用谁的方法，可以从虚拟机运行时的层面进行判断，如果是动态分派，执行编译出来invokevirtual指令之前，先将当前调用方法的实例的引用this压入所处栈帧的操作数栈，接着是参数列表的参数(最后这些数据都会按顺序拷贝一份到确认了调用的方法的局部变量表中)。invokevirtual指令会找到this所对应的类，不妨设为C，在C中找到描述符和简单名都相符的方法，找不到就按照继承关系从下往上查找，先子类再父类。 默认方法的出现，衍生出了接口多重继承的问题，因为现在可以出现两个接口的方法签名一样但是实现不一样的情况了， 当javac不能明确继承的是哪个接口的方法的时候就会报错，解决的方法有两种： 直接重写该默认方法； 使用增强的super来指定调用的是哪个接口的默认方法； 下面给出示例： 12345678910111213141516171819interface A &#123; default void test01() &#123; System.out.println("A"); &#125;&#125;interface B &#123; default void test01() &#123; System.out.println("B"); &#125;&#125;class C implements A, B &#123; @Override public void test01() &#123;// System.out.println("C"); A.super.test01(); &#125;&#125; 接口静态方法 &amp; Optional接口静态方法的出现更像是对Java编程的一种规范，本人之前在写普通类的时候常常贯穿各种静态方法，现在提倡将静态方法统一放在一个接口当中作为工具方法。 Optional的出现是为了应对空指针问题，空指针有的时候就像幽灵，本人以前写过一个小项目，一个空指针问题一直埋在代码中很长时间未被发现，因为null在某些时候并不会造成程序的崩坏。关于Optional本站后续还将进行探讨。 参考《Java 8函数式编程》]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Java 8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Java函数式编程(一)：初探]]></title>
    <url>%2F2018%2F06%2F18%2FJava8_FuncPro01%2F</url>
    <content type="text"><![CDATA[Java 8开始引入了Lambda表达式，第一次使用的时候，我是感动的，真的太好用了。接下来将做些笔记，以期了解Java函数式编程。 快速入手流(Stream)是什么？这里有一篇文章(《Java 8中的Streams API详解》)给出了解释。这里先不纠结抽象的概念，而是看看具体的代码操作，本人认为，对一个Java程序员来说，Lambda表达式中的()和{}是需要区分的内容。 Lambda中() &amp; {}首先看一个Filter的例子： 123456789public class FilterDemo &#123; public static void main(String[] args) &#123; List&lt;String&gt; beginningWithNumbers = Stream.of("a", "1asd", "5asds") .filter(string -&gt; Character.isDigit(string.charAt(0))) .collect(Collectors.toList()); System.out.println(beginningWithNumbers); &#125;&#125; Lambda是采用的 T -&gt; Function -&gt; R 的形式，string -&gt; Character.isDigit(string.charAt(0))也可以添加()写成string -&gt; (Character.isDigit(string.charAt(0)))。 如果更换成{}，则需要显式的写return语句，就像正常书写方法一样，打印下面的语句： 12345678910System.out.println(Stream.of("a", "1asd", "5asds") .filter(string -&gt; &#123; System.out.println("sdsdsss"); return Character.isDigit(string.charAt(0)); &#125;));System.out.println(Stream.of("a", "1asd", "5asds") .filter(string -&gt; Character.isDigit(string.charAt(0)) )); 输出为： 1234java.util.stream.ReferencePipeline$2@12edcd21java.util.stream.ReferencePipeline$2@52cc8049Process finished with exit code 0 这段输出中，一开始没有打印出”sdsdsss”，说明这不是一个执行过程，而更像是声明方法刻画Stream。 要执行”sdsdsss”，需要采用及早求值方法(与之相反的概念叫惰性求值方法，是上一句提到的“声明”和”刻画”的方法)： 12345System.out.println(Stream.of("a", "1asd", "5asds") .filter(string -&gt; &#123; System.out.println("sdsdsss"); return Character.isDigit(string.charAt(0)); &#125;).collect(Collectors.toList())); 输出结果： 1234sdsdssssdsdssssdsdsss[1asd, 5asds] 下图模拟了执行过程： 与树的遍历做比较：形式上，不那么严谨的说，很类似广度优先遍历，而一般的for循环更似深度优先遍历。 重构代码本小节将采用前文所述方式重构一个多层for循环代码。 将要给出的实例中，for循环所处的场景和循环逻辑是这样的：现在某学校有5个班，id分别为1、2、3、4、5，每个班有三名学生，将所属班级id为奇数且名称不叫小明的学生的姓名，全部打印出来。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class OldForDemo &#123; public static void main(String[] args) &#123; // 每个数组包括各个班级的学生名 String[] s1 = &#123;"小明", "A01", "A02"&#125;; String[] s2 = &#123;"小张", "B01", "B02"&#125;; String[] s3 = &#123;"小明", "C01", "C02"&#125;; String[] s4 = &#123;"小陈", "D01", "D02"&#125;; String[] s5 = &#123;"小农", "E01", "E02"&#125;; // 班级c01对象 Clazz c01 = new Clazz(1, s1); // 班级c02对象 Clazz c02 = new Clazz(2, s2); // 班级c03对象 Clazz c03 = new Clazz(3, s3); // 班级c04对象 Clazz c04 = new Clazz(4, s4); // 班级c05对象 Clazz c05 = new Clazz(5, s5); // 用一个数组将所有班级对象打包在一起 Clazz[] clazzes = &#123;c01, c02, c03, c04, c05&#125;; List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 将要被改造的旧循环逻辑 for (Clazz c : clazzes) &#123; if (c.getId() % 2 == 1) &#123; for (String s : c.getS()) &#123; if (!s.equals("小明"))&#123; list.add(s); &#125; &#125; &#125; &#125; // 遍历并打印最终构造的列表 for (String s : list) &#123; System.out.print(s + " "); &#125; &#125; // 班级类 public static class Clazz &#123; private int id; private String[] s; public Clazz(int id, String[] strings) &#123; this.id = id; this.s = strings; &#125; public int getId() &#123; return id; &#125; public String[] getS() &#123; return s; &#125; &#125;&#125; 代码各主要部分都进行了注释，逻辑也比较简单。 如何改造这段代码？我的方法是，视一次执行流程操作的对象对应一个Stream元素，首先看第一句for (Clazz c : clazzes)，一次执行流程是的操作对象是c，那么该语句转化为： 1Arrays.stream(clazzes) 第二句是if (c.getId() % 2 == 1)，这里显然可以采用一个filter方法： 1.filter(x -&gt; x.getId() % 2 == 1) 第三句是for (String s : c.getS())，一次执行流程的操作对象是s，而s代表每个班级中的一个学生名，所以之前以班级对象对应一个Stream元素来构造Stream的方式，应该改为以班级中单个学生名对应一个Stream元素来构造Stream的方式。这里采用flatMap方法： 1.flatMap(clazz -&gt; Arrays.stream(clazz.getS())) 接着还要进行一次filter()，排除叫”小明”的名字，最后进行收集，这一部分完整代码如下： 12345List&lt;String&gt; l = Arrays.stream(clazzes) .filter(x -&gt; x.getId() % 2 == 1) .flatMap(clazz -&gt; Arrays.stream(clazz.getS())) .filter(x -&gt; !x.equals("小明")) .collect(Collectors.toList()); 输出为： 1[A01, A02, C01, C02, 小农, E01, E02] 通过本次重构，代码逻辑清新了很多。 小结本篇小文没有讲解map、reduce等高级函数如何使用，具体用法需自行查阅，但比较了lambda表达式中()与{}的区别，最后通过一个重构实例对函数式编程进行了实践。 参考《Java 8函数式编程》 廖雪峰的官方网站：这里有对reduce函数的介绍，比较清晰；]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>Java 8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次ThreadLocal源码解析之旅]]></title>
    <url>%2F2018%2F05%2F30%2FThreadLocal%2F</url>
    <content type="text"><![CDATA[写这篇解析再一次花费了本人整整一天时间，希望通过本篇文章，能将ThreadLocal的原理说清楚，讲明白。全文主要完成了以下四个部分的工作： 摸清了ThreadLocal是如何做到在不同线程set()、get()的值不被其它线程访问的； 介绍了弱引用在ThreadLocalMap中的应用； 探寻了ThreadLocalMap如何实现hash map功能； 列举了一个使用ThreadLocal而出现的内存泄漏问题并加以分析； 首先，让我们看看ThreadLocal能产生什么样的效果： 1234567891011121314public class ThreadLocalDemo &#123; public static void main(String[] args) &#123; final ThreadLocal&lt;Integer&gt; local = new ThreadLocal&lt;&gt;(); local.set(100); Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + " local: " + local.get()); &#125; &#125;); t.start(); System.out.println("Main local: " + local.get()); &#125;&#125; 打印结果如下： 12Thread-0 local: nullMain local: 100 local在主线程set的值，可以在主线程调用get方法得到，但在线程t内调用get方法，结果结果为null。 本文接下来以local调用的set方法为入口，探究产生这一结果的原因。 set()基础在ThreadLocal源码中set()是这样实现的： 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 首先获得当前执行local.set()语句所在的线程对象，也就是t，然后通过local的getMap()获得t内部持有的ThreadLocalMap对象，进入Thread类的源码查看，其中就包含名为threadLocals的字段： 1ThreadLocal.ThreadLocalMap threadLocals = null; 而查看getMap()的源码，返回的就是threadLocals： 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; map != null如果map != null，则执行map.set(this, value)，这里的this就是local。 ThreadLocalMap的具体实现后面再展开，在这里姑且先简单的理解为按键值对存储数据的数据结构，那么我们很容易发现，local还是那个local，并没有在每个线程产生local副本，只不过调用set方法的时候，将它与传入的值以键值对的形式，存储于每个线程内部持有的ThreadLocalMap对象里。 map == null如果map == null，则执行createMap(t, value)，源码如下： 123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 创建ThreadLocalMap对象赋给threadLocals。 至此，ThreadLocal的基本原理就已经很清晰了：各线程对共享的ThreadLocal实例进行操作，实际上是以该实例为键对内部持有的ThreadLocalMap对象进行操作。 除了set()，ThreadLocal还提供了get()、remove()等操作，实现比较简单，就不敷述了。 ThreadLocalMap结构要想真正理解ThreadLocal，还需要知道ThreadLocalMap究竟是什么。 注释中是这样介绍的：ThreadLocalMap is a customized hash map suitable only for maintaining thread local values. ThreadLocalMap属于自定义的map，是一个带有hash功能的静态内部类，和java.util包下提供的Map类并没有关系。内部有一个静态的Entry类，下面具体分析Entry。 Entry实现原理首先，这个类代码如下： 123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; 这里引用代码中给出的注释：The entries in this hash map extend WeakReference, using its main ref field as the key (which is always a ThreadLocal object). Note that null keys (i.e. entry.get() == null) mean that the key is no longer referenced。 第一句话实际上告诉了我们，entry继承自WeakReference，用main方法引用的字段作为entry中的key。 第二句的意思是，当entry.get() == null的时候，意味着键将不再被引用。 后续将解析这两句注释。 弱引用基础知识在开始这一小结之前，需要先掌握两点： 什么是弱引用。《深入理解Java虚拟机》中这样写道：“被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉，只被弱引用关联的对象。” 什么是参数的引用传递，这属于Java SE基础知识就不赘述了。 接下来，先阅读源代码，当构造器传入参数后，代表键的k会传入super()中，也就是它会首先执行父类的构造器： 123public WeakReference(T referent) &#123; super(referent);&#125; WeakReference的构造器继续先调用父类的构造器： 12345678Reference(T referent) &#123; this(referent, null);&#125;Reference(T referent, ReferenceQueue&lt;? super T&gt; queue) &#123; this.referent = referent; this.queue = (queue == null) ? ReferenceQueue.NULL : queue;&#125; 除此之外，我们在Reference类里面看不到任何native方法，但能看到一些实例方法，比如get()，后续我们还将谈到这个方法。 这个时候会疑惑弱引用的功能是怎么实现的，在注释中，有这样的字眼：“special treatment by the garbage collector.” 可见WeakReference的功能实现交给了垃圾回收器处理，那么这里就不展开了，感兴趣的可以参考文末的链接。在这里我们只需要了解WeakReference的使用方法。 弱引用和强引用的使用方法并不相同，下面是一个弱引用的示例： 12345678910111213141516171819202122public class WeakReferenceDemo &#123; public static void main(String[] args) &#123; WeakReference&lt;Fruit&gt; fruitWeakReference = new WeakReference&lt;&gt;(new Fruit()); // Fruit f = fruitWeakReference.get(); if (fruitWeakReference.get() != null) &#123; System.out.println("Before GC, this is the result"); &#125; System.gc(); if (fruitWeakReference.get() != null) &#123; System.out.println("After GC, fruitWeakReference.get() is not null"); &#125; else &#123; System.out.println("After GC, fruitWeakReference.get() is null"); &#125; &#125;&#125;class Fruit &#123;&#125; 输出结果如下： 12Before GC, this is the resultAfter GC, fruitWeakReference.get() is null 通过fruitWeakReference.get()，可以得到弱引用指向的对象，当执行System.gc()后，该对象被回收。 用一张图表示强弱引用彼此间的关系： 要明确的是，类似“Object obj ＝ new Object()”这般产生的引用属于强引用，所以fruitWeakReference是强引用，此时它指向的是一个WeakReference对象，在new这个对象时，我们还传入了一个new出来的Fruit对象，整行代码的目的，就是要创造一个弱引用，指向这个Fruit对象。而这个弱引用，就在fruitWeakReference指向的对象里。 用个不严谨的比喻，弱引用就像一只薛定谔的猫，我们想知道它的状态，却不能通过普通的Java代码调用出它本身来观测它，如果将前文列出的WeakReferenceDemo内的双斜杠注释去掉，用一个变量f指向fruitWeakReference.get()，不过就是将一个强引用指向了原本由弱引用指向的对象而已，此时再运行程序，得到如下结果： 1234Before GC, this is the resultAfter GC, fruitWeakReference.get() is not nullProcess finished with exit code 0 由于对象被强引用，所以不会被垃圾回收。 弱引用Entry的键有了前面的基础，很容易就能理解Entry的构造原理。为了方便说明，不妨假设我们能创建一个Entry对象，代码如下： 1Entry entry = new Entry(local, 100); 此时强弱引用彼此间的关系图如下： 到这里，就能理解前面那两句注释了，entry继承自WeakReference，内部维护一个弱引用，指向main方法中local指向的对象；entry.get()返回的是弱引用指向的对象，如果entry.get() == null，自然表示的就是键将不再被引用了。 所以，和普通Map的Entry类不同，ThreadLocalMap的Entry实例被创建是时，键是弱引用，至此ThreadLocal内部ThreadLocalMap的基本结构也就清楚了。 set()进阶再次贴出ThreadLocal中set()的源码： 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; 注意第5行的语句，local调用set()时，一旦当前线程对象持有的ThreadLocalMap类型变量threadLocals不为null，则会执行map.set(this, value)这一行语句，上一节分析了ThreadLocalMap的结构，这一节将聚焦ThreadLocalMap的操作方法set()。 下面给出set()的源码： 12345678910111213141516171819202122232425262728private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; // 计算出hash表的位置i int i = key.threadLocalHashCode &amp; (len-1); // 处理set方法关键逻辑 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; // 在hash表中保存新生成的Entry对象 tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; 代码中i是hash表(亦称hash桶)的索引，也就是存放新设置的entry的位置，当然在存放之前还要进行一番比较操作。threadLocalHashCode是如下方式得到的： 123456789private static AtomicInteger nextHashCode = new AtomicInteger();private static final int HASH_INCREMENT = 0x61c88647;private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125;private final int threadLocalHashCode = nextHashCode(); 采用0x61c88647是为了实现更好的散列，每当有新的ThreadLocal对象调用threadLocalHashCode的时候，后者自增一个0x61c88647大小的值。至于为什么0x61c88647可以实现更好的散列，这涉及到Fibonacci Hashing算法(这个数的二进制形式取反加1就是一个Fibonacci Hashing常数)，具体细节可跳转到文末参考链接。 当然，在计算i之前还要进行一个位运算，非常简单，比如在没扩展之前len是16(2的4次方)，那么len - 1的二进制形式就是1111，按位与也就是取后四位。 为了防止碰撞冲突，这里采用的是线性探测法，并没有采用拉链法。探测的索引规则如下： 123private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0);&#125; for循环的执行逻辑是这样的： 首先获取hash表索引位置为i的Entry元素tab[i]； 判断tab[i]为是否为null，如果tab[i]为null，说明这个位置之前还没有存在过Entry实例，跳出循环，在hash表中该位置保存新生成的Entry对象； 如果tab[i]不为null，要么存在指向相同对象的键，如果是这种情况，则修改value为需要设定的值；要么弱引用指向为null，如果是这种情况，执行replaceStaleEntry方法； 用nextIndex方法修改i值，跳到第二步继续判断； 在跳出循环并在hash表相应位置保存新生成的Entry对象后，size也会加1，在满足!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold的条件下，还要重新进行rehash()处理。 replaceStaleEntry以及cleanSomeSlots的主要作用都是用来删除弱引用为null的entry，后者查找的时间是log2(n)，限于篇幅就不展开了，而threshold和HashMap中定义的预置作用相似，主要是扩容用的，这里为len * 2 / 3。 内存清理还是沿用最初的例子，如果将local置为null，那么new出来的ThreadLocal对象就只被线程中的ThreadLocalMap实例弱引用，此时只要调用System.gc()，对象将在下一次垃圾收集时被回收。如果要主动断掉弱引用呢？Java提供了如下方法： 1clear() 它是Reference抽象类提供的方法。 接下来用一个例子讨论ThreadLocal可能出现的内存泄漏问题。 内存泄漏实例实例源码如下： 123456789101112131415161718192021222324252627282930313233public class ThreadLocalTest throws InterruptedException&#123; public static void main(String[] args) &#123; MyThreadLocal&lt;Create50MB&gt; local = new MyThreadLocal&lt;&gt;(); ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(5, 5, 1, TimeUnit.MINUTES, new LinkedBlockingQueue&lt;Runnable&gt;()); for (int i = 0; i &lt; 5; i++) &#123; final int[] a = new int[1]; final ThreadLocal[] finallocal = new MyThreadLocal[1]; finallocal[0] = local; a[0] = i; poolExecutor.execute(new Runnable() &#123; @Override public void run() &#123; finallocal[0].set(new Create50MB()); System.out.println("add i = " + a[0]); &#125; &#125;); &#125; Thread.sleep(50000); local = null; &#125; static class Create50MB &#123; private byte[] bytes = new byte[1024 * 1024 * 50]; &#125; static class MyThreadLocal&lt;T&gt; extends ThreadLocal &#123; private byte[] bytes = new byte[1024 * 1024 * 500]; &#125;&#125; 先说一说该小程序的设计思路： 该程序旨在构造出一种内存泄漏的情况：当线程池执行完当前任务处于等待状态的时候，将local置null，回收main方法一开始new出来的MyThreadLocal对象，线程池内单个线程的ThreadLocalMap实例虽然弱引用于这个MyThreadLocal对象，但内部持有的value却仍然被强引用着不能回收。 在该程序中，我们自定义了一个MyThreadLocal，目的是使new出来的MyThreadLocal对象的大小能达到500MB；Create50MB是创建出来的容量包，每个线程最后持有的value就是一个50MB大小的Create50MB对象；线程池也是自定义传参，做到更好的掌控，一次能同时工作5个线程；for循环中用到了两个临时变量，是为了规避匿名内部类引用外部变量必须要声明为final的语言限制。 启动程序，运行状态见下图： 使用的堆的大小是750MB，这符合预期，new出来的MyThreadLocal对象500MB，有五个线程，每个线程50MB，加起来一共750MB。 50秒后，将local置null，这个时候不再有强引用指向new的MyThreadLocal对象，此时执行垃圾回收，结果如下： 使用的堆大小变为250MB，单就这个结果还不能证明每个线程内对MyThreadLocal对象存在弱引用，但是一定不存在强引用。 之前本人曾研究过线程池的源码，线程池内的线程在执行完一个任务后，并没有销毁，在本例中，它们处于waiting状态，所以，本程序始终维持在250MB大小，得不到释放，一旦将程序中的条件改得足够大，就能出现明显的性能问题。解决的方法通常是在线程内调用ThreadLocal的remove方法，实际上，ThreadLocal提供的公有API并不多，但是这个方法足够解决问题。 小结不得不说，通过对ThreadLocal的解析，本人收获很多。整篇文章写起来也是一气呵成(所以可能也包藏着错误)，估摸着如果以后有对共享变量进行私有设置的需求时，也可以参考这种方法来写；之前对四种引用只是了解，这次算是弄明白怎么运用；用线性探测解决hash表的碰撞冲突，有别于HashMap，也是ThreadLocal的特点；最后列举的内存泄漏，算是对前面写的内容进行了一次实战。 cool. 参考WeakReference JVM原理与实现——Reference What is the meaning of 0x61C88647 constant in ThreadLocal.java Fibonacci Hashing 打印GC：-XX:+PrintGCDetails，更多可见：查看GC日志时使用的虚拟机参数]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由几个小例引发的对interrupt()、LockSupport.park()深入解析]]></title>
    <url>%2F2018%2F05%2F27%2FInterrupt_Ques%2F</url>
    <content type="text"><![CDATA[在之前解析interrupt()源码的小文最后，曾经列出过一些例子，主要是关于标志位更改对LockSupport.park()的影响，这里我觉得有必要单独花一个篇幅来研究，因为AQS就涉及到了这方面的问题。通过本文，可以对Thread.interrupted()有一个牢固的掌握，对interrupt()有更进一步的理解，对LockSupport.park()、LockSupport.unpark()挂起唤醒机制有一个清晰的认识。本篇应该算是《线程生命周期 &amp; 中断机制》的姊妹篇。 4个例子首先是第1例： 123456789101112131415161718192021222324public class MultInterruptParkDemo &#123; public static volatile boolean flag = true; public static void main(String[] args) &#123; ThreadDemo04 t4 = new ThreadDemo04(); t4.start(); t4.interrupt(); flag = false; &#125; public static class ThreadDemo04 extends Thread &#123; @Override public void run() &#123; while (flag) &#123; &#125; LockSupport.park(); System.out.println("本打印出现在第一个park()之后"); LockSupport.park(); System.out.println("本打印出现在第二个park()之后"); &#125; &#125;&#125; 本例的输出为： 1234本打印出现在第一个park()之后本打印出现在第二个park()之后Process finished with exit code 0 也就是说，一次中断操作后无论线程调用多少次LockSupport.park()，程序都不会挂起，而是正常运行结束。 接下来把程序改成如下所示的第2例： 1234567891011121314151617181920212223242526public class MultInterruptParkDemo &#123; public static volatile boolean flag = true; public static void main(String[] args) &#123; ThreadDemo04 t4 = new ThreadDemo04(); t4.start(); LockSupport.unpark(t4); LockSupport.unpark(t4); LockSupport.unpark(t4); flag = false; &#125; public static class ThreadDemo04 extends Thread &#123; @Override public void run() &#123; while (flag) &#123; &#125; LockSupport.park(); System.out.println("本打印出现在第一个park()之后"); LockSupport.park(); System.out.println("本打印出现在第二个park()之后"); &#125; &#125;&#125; 本例的输出为： 1本打印出现在第一个park()之后 程序在输出了第一条打印语句后挂起，说明无论调用多少次LockSupport.unpark(t4)，只会提供给线程一个许可。 继续更改代码，将更改的代码设为第3例： 1234567891011121314151617181920212223242526public class MultInterruptParkDemo &#123; public static volatile boolean flag = true; public static void main(String[] args) &#123; ThreadDemo04 t4 = new ThreadDemo04(); t4.start(); t4.interrupt(); flag = false; &#125; public static class ThreadDemo04 extends Thread &#123; @Override public void run() &#123; while (flag) &#123; &#125; LockSupport.park(); System.out.println("本打印出现在第一个park()之后"); System.out.println(Thread.interrupted()); System.out.println(Thread.interrupted()); LockSupport.park(); System.out.println("本打印出现在第二个park()之后"); &#125; &#125;&#125; 本例的输出为： 123本打印出现在第一个park()之后truefalse 程序打印了上述结果后挂起，而第1例中interrupt()在没有两个System.out.println(Thread.interrupted())语句(采用两个的原因是方便看出标志位已经清零)之前，程序是会正常结束的。可能你认为这是理所当然的，因为标志位清零后第二句LockSupport.park()自动将线程挂起，那么我们在看下面这第4例，用一个sleep()取代第一个LockSupport.park()： 123456789101112131415161718192021222324252627282930public class MultInterruptParkDemo &#123; public static volatile boolean flag = true; public static void main(String[] args) &#123; ThreadDemo04 t4 = new ThreadDemo04(); t4.start(); t4.interrupt(); flag = false; &#125; public static class ThreadDemo04 extends Thread &#123; @Override public void run() &#123; while (flag) &#123; &#125; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("本打印出现在第一个sleep()之后"); System.out.println(Thread.interrupted()); System.out.println(Thread.interrupted()); LockSupport.park(); System.out.println("本打印出现在第二个park()之后"); &#125; &#125;&#125; 输出如下： 1234567java.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at com.demo.MultInterruptParkDemo$ThreadDemo04.run(MultInterruptParkDemo.java:34)本打印出现在第一个sleep()之后falsefalse本打印出现在第二个park()之后 程序运行结束，没有挂起。 上面的结果表示，虽然标志位更改了，但是之前响应中断的是sleep()而不是park()，那么第二个park()不会让程序阻塞。 从源码找答案追踪Thread.interrupted()源码interrupted()的API描述： 123public static boolean interrupted() &#123; return currentThread().isInterrupted(true);&#125; 继续追踪isInterrupted()： 1private native boolean isInterrupted(boolean ClearInterrupted); 这是一个native方法，在本人之前的《线程生命周期 &amp; 中断机制》中，追踪过interrupt0()，而追踪isInterrupted()的方法与之如出一辙，这里就省略过程，直接放上核心代码，需要说明的是，os在这里仍然选用Linux版本： 123456789101112131415bool os::is_interrupted(Thread* thread, bool clear_interrupted) &#123; assert(Thread::current() == thread || Threads_lock-&gt;owned_by_self(), "possibility of dangling Thread pointer"); OSThread* osthread = thread-&gt;osthread(); bool interrupted = osthread-&gt;interrupted(); if (interrupted &amp;&amp; clear_interrupted) &#123; osthread-&gt;set_interrupted(false); // consider thread-&gt;_SleepEvent-&gt;reset() ... optional optimization &#125; return interrupted;&#125; 到这里基本上就已经明晰interrupted()的原理了，但为了更直白，还是把OSThread的interrupted、set_interrupted方法也列出来： 12345678910111213class OSThread: public CHeapObj&lt;mtThread&gt; &#123; ... private: volatile jint _interrupted; // Thread.isInterrupted state public: volatile bool interrupted() const &#123; return _interrupted != 0; &#125; void set_interrupted(bool z) &#123; _interrupted = z ? 1 : 0; &#125; ...&#125; jint是一个JNI对Java数据类型的映射，这里对应Java里的int，现在可以分析出Java中Thread.interrupt()的原理了： 首先调用的是currentThread().isInterrupted(true)并将其返回； isInterrupted是一个native方法，底层调用的是系统的is_interrupted方法； 该方法获得Java线程对应的系统线程osthread，调用其方法interrupted获得中断标志_interrupted的值，并将该值赋给bool的局部变量interrupted； 由于clear_interrupted传入的参数为true，如果interrupted为true，那么执行osthread的set_interrupted方法，将标志位更改位false； 最后返回的是第3步的interrupted，但实际上此时标志位的值已经在第4步得到更改； 这就是为什么调用了Thread.interrupt()后，默认会更改中断标志位的值，到此其原理已经解析完毕。 追踪park()、unpark()底层源码接下来，将通过分析park()和unpark()源码，来解释之前四个例子的输出结果。 unpark()底层源码所要解析的unpark()的底层源码在hotspot-327ea6f9647c/src/os/linux/vm/os_linux.cpp下： 123456789101112131415161718192021222324252627282930void Parker::unpark() &#123; int s, status ; status = pthread_mutex_lock(_mutex); assert (status == 0, "invariant") ; s = _counter; _counter = 1; if (s &lt; 1) &#123; // thread might be parked if (_cur_index != -1) &#123; // thread is definitely parked if (WorkAroundNPTLTimedWaitHang) &#123; status = pthread_cond_signal (&amp;_cond[_cur_index]); assert (status == 0, "invariant"); status = pthread_mutex_unlock(_mutex); assert (status == 0, "invariant"); &#125; else &#123; status = pthread_mutex_unlock(_mutex); assert (status == 0, "invariant"); status = pthread_cond_signal (&amp;_cond[_cur_index]); assert (status == 0, "invariant"); &#125; &#125; else &#123; pthread_mutex_unlock(_mutex); assert (status == 0, "invariant") ; &#125; &#125; else &#123; pthread_mutex_unlock(_mutex); assert (status == 0, "invariant") ; &#125;&#125; 《多线程编程指南》介绍了pthread_mutex_lock方法，该方法可以锁定mutex所指向的互斥锁，所以在调用pthread_mutex_unlock(_mutex)解锁之前，其它线程要访问被锁定的内容将阻塞。 在被锁定的同步语句内，首先将_counter的值赋给s，然后更改_counter为1，这就是普遍说的给予一个“许可”的底层操作，然后判断s(也就是之前的_counter值)是否大于等于1，如果大于等于1，说明目标线程并没有挂起；如果小于1，说明目标线程有可能挂起，则调用pthread_cond_signal方法将其唤醒。 从以上分析也可以看出，_counter的更改不是累加的过程，而是每次都写死为1，这就解释了第2例的输出结果，即无论之前调用多少次LockSupport.unpark()，只会更改_counter为1，提供一个逻辑“许可”。 park()底层源码park()的底层源码行数比较多，这里针对本文所要解决的问题，按从前到后的顺序列出关键代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void Parker::park(bool isAbsolute, jlong time) &#123; // Optional fast-path check: // Return immediately if a permit is available. // We depend on Atomic::xchg() having full barrier semantics // since we are doing a lock-free update to _counter. if (Atomic::xchg(0, &amp;_counter) &gt; 0) return; Thread* thread = Thread::current(); // Optional optimization -- avoid state transitions if there's an interrupt pending. // Check interrupt before trying to wait if (Thread::is_interrupted(thread, false)) &#123; return; &#125; // Don't wait if cannot get lock since interference arises from // unblocking. Also. check interrupt before trying wait if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) &#123; return; &#125; int status ; if (_counter &gt; 0) &#123; // no wait needed _counter = 0; status = pthread_mutex_unlock(_mutex); assert (status == 0, "invariant") ; // Paranoia to ensure our locked and lock-free paths interact // correctly with each other and Java-level accesses. OrderAccess::fence(); return; &#125; ... if (time == 0) &#123; _cur_index = REL_INDEX; // arbitrary choice when not timed status = pthread_cond_wait (&amp;_cond[_cur_index], _mutex) ; &#125; else &#123; _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX; status = os::Linux::safe_cond_timedwait (&amp;_cond[_cur_index], _mutex, &amp;absTime) ; if (status != 0 &amp;&amp; WorkAroundNPTLTimedWaitHang) &#123; pthread_cond_destroy (&amp;_cond[_cur_index]) ; pthread_cond_init (&amp;_cond[_cur_index], isAbsolute ? NULL : os::Linux::condAttr()); &#125; &#125; _counter = 0 ; status = pthread_mutex_unlock(_mutex) ; assert_status(status == 0, status, "invariant") ; // Paranoia to ensure our locked and lock-free paths interact // correctly with each other and Java-level accesses. OrderAccess::fence(); ...&#125; 只要理解了这段代码，第1、3、4例的输出结果也就能解释。 一开始的Atomic::xchg方法通过原子操作将_counter设置为0，而返回的是未设置之前的值，如果这个值大于0，证明获得了unpark()的许可，则park方法直接return不会挂起，至此第4个例子的输出就能解释了，虽然Thread.sleep()响应了t4.interrupt()，但是并没有更改_counter，而interrupt()在《线程生命周期 &amp; 中断机制》就解析过，底层调用的正是parker的unpark方法，所以_counter是大于0的。 继续对底层的park()进行解析，通过Thread* thread = Thread::current()获得当前线程，紧接着是一个if语句，Thread::is_interrupted(thread, false)中传入false的作用是不执行osthread-&gt;set_interrupted(false)，返回的仍然是中断标志位的值，所以调用park()不会对标志位清零。而此时中断标志位的值如果是true，则park方法直接return不会挂起，至此第1个例子的输出也能解释了：一次中断操作后无论线程调用多少次LockSupport.park()，程序都不会挂起的原因，就在于中断标志位没有清零。 在第3例中，之所以第二个LockSupport.park()能挂起，是因为System.out.println(Thread.interrupted())清零了标志位，Thread.interrupted()在前文早已完全解析。程序在执行到下面这段代码时： 123if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) &#123; return;&#125; 两个条件分句返回都是false，所以park()仍然没有return，那么后续会调用相关方法将线程挂起。所以第3个例的输出结果便得到了解释。 小结本文通过四个例子引发思考，通过解析源码解决困惑。在AQS源码中，acquireQueued方法的for循环内，parkAndCheckInterrupt()之所以要return Thread.interrupted()，正是因为如果不清零标志位，那么后续将永远不会再挂起，如同第1例中出现的那样。 中断标志位未清零，_counter == 1，只要满足这两者其中一个条件，park()就不会将线程挂起。 参考pthread_cond_wait为什么需要传递mutex参数：算是本文读源码衍生出来的问题； C++和JNI的数据转换：讲解了Java类型映射本地类型的相关知识； 《多线程编程指南》：帮助解答底层的困惑；]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[J.U.C并发框架之AQS(四)：ReentrantLock公平锁]]></title>
    <url>%2F2018%2F05%2F26%2FJUC_AQS04%2F</url>
    <content type="text"><![CDATA[本篇继续之前的系列，解析ReentrantLock公平锁。 公平锁源码解析之前的解析文章就已经提到，ReentrantLock默认创建的对象是非公平的： 123public ReentrantLock() &#123; sync = new NonfairSync();&#125; 要创建公平锁需要自己指定： 123public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 通过比较FairSync类和NonfairSync类，可知两者内部的tryAcquire方法在实现有所不同，具体到代码： 12345if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true;&#125; 实现公平锁的同步器FairSync会在尝试获得锁(tryAcquire方法)的过程中多出一行代码!hasQueuedPredecessors()。实现如下： 12345678910public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 在这个方法中，如果h == t，结合系列文章(一)的分析，要么之前还没有线程，要么前面只有一个线程，等待队列没有等待的线程，这时候直接返回false，当前线程尝试去获得锁；如果s != null且s.Thread是当前线程，那么当前线程就是head的后继节点，所以即便等待队列存在其它线程，也返回false并尝试去获取锁。 公平&amp;非公平的具体体现原理初探公平锁和非公平锁在实现上基本相同，这就不得不让人产生困惑，锁的公平与不公体现在哪？现在假设有这样一个场景，开6个线程，当第1个启动的线程持有锁的时候，其余5个线程进入等待队列等待，等持有锁的线程释放锁的时候，接下来等待的线程拿锁的过程遵守公平&amp;非公平原则吗？？ 看代码，这里创建一个非公平锁： 123456789101112131415161718192021222324252627282930313233343536public class UnfairsyncDemo &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new ThreadDemoSync(); Thread t2 = new ThreadDemoSync(); Thread t3 = new ThreadDemoSync(); Thread t4 = new ThreadDemoSync(); Thread t5 = new ThreadDemoSync(); Thread t6 = new ThreadDemoSync(); t1.start(); t2.start(); t3.start(); t4.start(); t5.start(); t6.start(); &#125; public static class ThreadDemoSync extends Thread &#123; public static ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; lock.lock(); System.out.println(Thread.currentThread().getName()); try &#123; if (Thread.currentThread().getName().equals("Thread-0")) Thread.sleep(3000); // 添加时间是为了确保所有的线程都已入列 System.out.println("线程" + Thread.currentThread() + "执行完sleep方法"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; 输出如下： 1234567891011121314Thread-0线程Thread[Thread-0,5,main]执行完sleep方法Thread-1线程Thread[Thread-1,5,main]执行完sleep方法Thread-2线程Thread[Thread-2,5,main]执行完sleep方法Thread-3线程Thread[Thread-3,5,main]执行完sleep方法Thread-4线程Thread[Thread-4,5,main]执行完sleep方法Thread-5线程Thread[Thread-5,5,main]执行完sleep方法Process finished with exit code 0 多次测试都是相同的输出结果，不严谨的表明了线程是按照开启的顺序依次拿锁执行的。这不难通过分析来证明：当其它线程都进入等待队列等待的时候，唤醒是按进入队列的先后顺序依次由前置节点唤醒，这是由源码的设计决定的。所以无论是否设置公平锁，此时获得锁的顺序都是公平的。 接下来再构造一个简单的模型，思路是开启若干线程，每个线程在执行的过程中经过若干轮的尝试获得锁、释放锁，通过观察程序执行的结果来分析公平锁非公平锁的工作原理，这个例子引用自ReentrantLock(重入锁)以及公平性。 构造观察模型不妨设计5个线程，每个线程内循环30次，之所以设置30次是为了最后输出效果好一点点，线程内循环次数过少会因为程序运行快而使得等待队列没有等待的线程。 老规矩还是先放代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class UnfairsyncDemo02 &#123; // private static Lock fairLock = new ReentrantLock02(true); private static Lock unfairLock = new ReentrantLock02(); public static void main(String[] args) &#123; System.out.println("unfair version"); for (int i = 0; i &lt; 5; i++) &#123; Thread thread = new Thread(new Job(unfairLock))&#123; @Override public String toString() &#123; return getName(); &#125; &#125;; thread.start(); &#125; &#125; private static class Job implements Runnable &#123; private Lock lock; public Job(Lock lock) &#123; this.lock = lock; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 30; i++) &#123; lock.lock(); try &#123; System.out.println("Lock by: " + Thread.currentThread().getName() + " Waiting Threads: " + ((ReentrantLock02)lock).getQueuedThreads()); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; &#125; private static class ReentrantLock02 extends ReentrantLock &#123; @Override public Collection&lt;Thread&gt; getQueuedThreads() &#123; return super.getQueuedThreads(); &#125; &#125;&#125; 简要说明一下这段代码，开5个线程，每个线程在执行“Job”任务时，会在run方法内循环30次，每1次都有一个获得锁释放锁的过程，并在run方法中打印当前持有锁的名称以及同步器内的等待队列的线程名。 这里再啰嗦一下：ReentrantLock内部拥有一个返回同步器等待队列的方法(返回的是一个list)，访问受限(protected)，所以在这里创建一个新的子类ReentrantLock02，目的就是方便程序调用getQueuedThreads方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153unfair versionLock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-0 Waiting Threads: []Lock by: Thread-2 Waiting Threads: [Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-1 Waiting Threads: [Thread-4, Thread-3, Thread-0]Lock by: Thread-0 Waiting Threads: [Thread-4, Thread-3]Lock by: Thread-0 Waiting Threads: [Thread-4, Thread-3]Lock by: Thread-0 Waiting Threads: [Thread-4, Thread-3]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-3 Waiting Threads: [Thread-4]Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Lock by: Thread-4 Waiting Threads: []Process finished with exit code 0 输出的每一行由相同的格式构成，比如这样一行：Lock by: Thread-2 Waiting Threads: [Thread-4, Thread-3, Thread-0, Thread-1]，表示当前的锁被Thread-2持有，等待队列由前到后的顺序是：Thread-1、Thread-0、Thread-3、Thread-4。 结果其实已经体现了非公平锁的非公平性，每次新获得锁的线程，并不是等待队列里排最靠前的线程，这是因为上一个持有锁的线程释放锁的时候，如果有某个线程正好“乱入”，那么它就有可能在竞争胜利的情况下获得锁，而不会经过!hasQueuedPredecessors()的判断。 在锁的公平和非公平这篇文章的最后提到了一个问题：为什么非公平锁下会出现线程连续获取锁的情况？实际上，由于本人将每个线程执行的循环设置为30次，输出结果已经表明线程并不是一直连续获取锁。而在循环次数少的情况下如果某个线程连续获取锁，我认为是因为线程的启动需要耗费资源和时间，而线程在由挂起到唤醒的过程中也会需要资源和时间，一个线程unlock()后也是优先执行tryAcquire方法，所以它比要被唤醒的线程更可能先获得锁。 将代码稍作修改就可以得到公平锁，由于前文已经将公平与否的原理分析清楚，这里不再赘述了，公平锁会按照等待队列的顺序依次获得锁，新近启动的线程也不能“插队”，例如(选取输出的一部分)： 123456789101112...Lock by: Thread-0 Waiting Threads: [Thread-4, Thread-3, Thread-2, Thread-1]Lock by: Thread-1 Waiting Threads: [Thread-0, Thread-4, Thread-3, Thread-2]Lock by: Thread-2 Waiting Threads: [Thread-1, Thread-0, Thread-4, Thread-3]Lock by: Thread-3 Waiting Threads: [Thread-2, Thread-1, Thread-0, Thread-4]Lock by: Thread-4 Waiting Threads: [Thread-3, Thread-2, Thread-1, Thread-0]Lock by: Thread-0 Waiting Threads: [Thread-4, Thread-3, Thread-2, Thread-1]Lock by: Thread-1 Waiting Threads: [Thread-0, Thread-4, Thread-3, Thread-2]Lock by: Thread-2 Waiting Threads: [Thread-1, Thread-0, Thread-4, Thread-3]Lock by: Thread-3 Waiting Threads: [Thread-2, Thread-1, Thread-0, Thread-4]Lock by: Thread-4 Waiting Threads: [Thread-3, Thread-2, Thread-1, Thread-0]... 小结公平锁虽然保证了所谓“公平”，但是线程状态的切换非常频繁，而且非公平锁等待队列中的线程被唤醒获得锁的过程也挺公平的，这就造成实际使用中通常采用非公平锁，但具体采用什么锁还是要结合具体的场景。 参考ReentrantLock(重入锁)以及公平性：借用AQS内部的方法展现公平锁实现原理的例子；]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池源码解析]]></title>
    <url>%2F2018%2F05%2F23%2FThreadPool%2F</url>
    <content type="text"><![CDATA[本篇主要解析线程池源码，最大的看点在于对shutdown()和shutdownNow()的比较分析以及对线程复用的深入研究，源码中还有很多巧妙的设计，比如ctl等，文章中相关的部分也会一并谈到。 线程池框架结构首先有必要了解一下线程池中主要的类和接口，初学很容易将它们混淆，实际上框架的继承结构非常简单，继承结构中没有出现@Override： Executor：一个接口，只有一个未实现的execute()； ExecutorService：一个接口，从实际的角度来看，拓展了Executor，最重要的可能就是添加了未实现的submit()，submit()的返回值是Future；当然，除此之外，还添加了一些未实现的方法，诸如shutdown()、isShutdown()、invokeAny()、invokeAll()等，这些方法的存在，让ExecutorService相对比较完备，所以在产生线程池实例时，完全可以用ExecutorService作为引用的类型； AbstractExecutorService：一个抽象类，实现了ExecutorService的submit()、invokeAll和invokeAny()； ThreadPoolExecutor：线程池具体实现类，直接继承自AbstractExecutorService，对后者实现的方法不进行覆盖(submit()等)，没有实现的方法均给出实现； Executors：一个工厂类，大部分返回ThreadPoolExecutor实例； 由此可见，几乎所有线程池具体的实现逻辑，都发生在ThreadPoolExecutor内部。 ThreadPoolExecutor实现机理构造 &amp; 运行流程下面是ThreadPoolExecutor带全参的构造器： 123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; corePoolSize：核心池的容量； maximumPoolSize：线程池的最大容量； keepAliveTime：当实际容量大于核心容量时，线程如果超过这个时间仍然“无事可做”，则要求被回收； unit：keepAliveTime单位，可有天、小时、分钟、毫秒、微秒和纳秒等； workQueue：工作队列； threadFactory：线程工厂，一般默认； handler：拒绝策略； 要想真正知道这些参数的意涵，需要先了解ThreadPoolExecutor的工作流程： 图中的1、2、3、4分别表示： execute()／submit()任务后，如果正在运行的线程在corePoolSize范围之内，则创建线程运行； 当运行的线程数已经达到corePoolSize容量的时候，将任务放入工作队列中； 当队列的容量也填满的时候，判断运行的线程是否达到了maximumPoolSize，没有则创建线程运行任务； 队列和maximumPoolSize容量都已满，则实行拒绝策略； 比如假设有一个线程池，corePoolSize为2，workQueue大小为3，如果corePoolSize和workQueue都满了的情况下，再多4个线程任务maximumPoolSize也将满额。现在添加7个线程任务，不妨设这些线程的线程名为1，2，3，4，5，6，7。那么执行的顺序就是1，2，6，7，3，4，5。 一般来说，推荐使用new ThreadPoolExecutor对象的方式创建线程池，而非Executors，因为后者使用默认参数构造对象，写出来的代码容易产生被忽视的问题，在文章最后附上了Executors创建的一些线程池的简要介绍，在这里只举newSingleThreadExecutor： 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 通过代码，连测试都不需要就可以看出，keepAliveTime针对的是实际alive线程数大于核心容量时的情况，不然这个“单例”线程池没有任何构造的必要。 拒绝策略默认的拒绝策略如下： 12private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); RejectedExecutionHandler是一个接口，内部只有一个待实现的方法： 1void rejectedExecution(Runnable r, ThreadPoolExecutor executor); 拒绝策略包括四种，他们分别是：CallerRunsPolicy、AbortPolicy、DiscardPolicy以及DiscardOldestPolicy。 CallerRunsPolicy首先给出源码： 123456789public static class CallerRunsPolicy implements RejectedExecutionHandler &#123; public CallerRunsPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125; &#125;&#125; 从r.run()可以看出，该策略是直接让主线程执行r的run方法，这样就可能面临很多意想不到的问题，比如主线程阻塞等等。 AbortPolicy123456789public static class AbortPolicy implements RejectedExecutionHandler &#123; public AbortPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException("Task " + r.toString() + " rejected from " + e.toString()); &#125;&#125; AbortPolicy策略就是抛异常。 DiscardPolicy123456public static class DiscardPolicy implements RejectedExecutionHandler &#123; public DiscardPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; &#125;&#125; DiscardPolicy就是什么也没做。 DiscardOldestPolicy12345678910public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123; public DiscardOldestPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125; &#125;&#125; 该策略就是将工作队列poll一个，然后再将任务提交到线程池。 以上就是线程池框架的基本结构，通过该结构，了解了一些类的基本信息和框架运行流程。 线程池生命周期上一节最后列出的代码中多次出现isShutdown方法，这里就来研究一下线程池的生命周期。 代码中的注释是这样说的： 1234567891011121314151617181920212223242526* The runState provides the main lifecycle control, taking on values:** RUNNING: Accept new tasks and process queued tasks* SHUTDOWN: Don&apos;t accept new tasks, but process queued tasks* STOP: Don&apos;t accept new tasks, don&apos;t process queued tasks,* and interrupt in-progress tasks* TIDYING: All tasks have terminated, workerCount is zero,* the thread transitioning to state TIDYING* will run the terminated() hook method* TERMINATED: terminated() has completed** The numerical order among these values matters, to allow* ordered comparisons. The runState monotonically increases over* time, but need not hit each state. The transitions are:** RUNNING -&gt; SHUTDOWN* On invocation of shutdown(), perhaps implicitly in finalize()* (RUNNING or SHUTDOWN) -&gt; STOP* On invocation of shutdownNow()* SHUTDOWN -&gt; TIDYING* When both queue and pool are empty* STOP -&gt; TIDYING* When pool is empty* TIDYING -&gt; TERMINATED* When the terminated() hook method has completed* 对各状态进行一个简要的“翻译”吧： RUNNING：正常运行状态，能接受新任务，也能处理工作队列的任务；SHUTDOWN：不接受新的任务，但是会处理还在工作队列中的任务；STOP：不接受新的任务，也不处理工作队列的任务，还会interrupt正在运行的任务；TIDYING：看名字就知道是一个过渡状态，所有任务销毁了，workerCount也变成0了，transitioning到该状态的时候，将运行terminated()，这是一个钩子方法，也就是空方法，待具体实现类去实现；TERMINATED：terminated()完成的状态； RUNNING -&gt; SHUTDOWN 调用shutdown()，而(RUNNING or SHUTDOWN) -&gt; STOP 调用shutdownNow()，这是两个可以直接干预生命周期的方法。 shutdown()shutdown()的源代码如下： 12345678910111213public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); advanceRunState(SHUTDOWN); interruptIdleWorkers(); onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate();&#125; checkShutdownAccess()：判断线程是否可shutdown，比如在内部实现中，某种情况会调用checkAccess()，如果线程为空会抛出空指针异常等等； advanceRunState(SHUTDOWN)：将状态设置为SHUTDOWN； interruptIdleWorkers()：中断空闲线程(此方法待与后面篇幅进行比较)； tryTerminate()：内部是一个循环，在满足条件的循环内，只要workerCountOf(c) != 0，就持续调用interruptIdleWorkers()。tryTerminate()会不断的像它的名字一样，尝试将执行完空闲出来的线程terminate掉； shutdownNow()shutdownNow()的源代码如下： 123456789101112131415public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); advanceRunState(STOP); interruptWorkers(); tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); return tasks;&#125; 和shutdown()最大的不同在于返回了一个集合，并且中断方法也不一样了，换成了interruptWorkers()。在interruptWorkers内，主要执行的代码如下： 12for (Worker w : workers) w.interruptIfStarted(); 而interruptIfStarted()核心代码是： 123if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; t.interrupt();&#125; 之所以需要判断getState() &gt;= 0，是因为每个worker在接到第一个任务的时候后，会将state设置为-1(Worker类本身就继承了AQS，它也是个同步器)，目的就是为了防止还没有执行runWorker方法之前就调用中断方法，“工人还没开工”，此时调用interrupt方法，不会更改中断标志位，使shutdownNow()失效。除此之外，只要线程不为null且没有被中断标识过都会调用interrupt方法。 而在shutdown()代码中，interruptIdleWorkers()方法最大的特点在于以下这段代码： 12if (!t.isInterrupted() &amp;&amp; w.tryLock()) t.interrupt(); 也就是说，在shutdown()中，要运行t.interrupt()，他首先需要尝试去拿到Worker对象持有的锁，拿不到锁它不会让线程对象调用interrupt()，这是shutdown()和shutdownNow()的区别之一。 除此之外，shutdownNow()内还调用了drainQueue方法，看代码： 123456789101112private List&lt;Runnable&gt; drainQueue() &#123; BlockingQueue&lt;Runnable&gt; q = workQueue; ArrayList&lt;Runnable&gt; taskList = new ArrayList&lt;Runnable&gt;(); q.drainTo(taskList); if (!q.isEmpty()) &#123; for (Runnable r : q.toArray(new Runnable[0])) &#123; if (q.remove(r)) taskList.add(r); &#125; &#125; return taskList;&#125; drainQueue()的作用主要就是用来清空workQueue到一个新的列表中。在调用了q.drainTo(taskList)后还进行if (!q.isEmpty())，是为了应对工作队列使用DelayQueue等其它方式实现的情况。一方面对线程池中的线程调用中断方法，另一方面清空工作队列中的任务，所以在之前源码注释中有这么一行：STOP -&gt; TIDYING When pool is empty，只需要pool为empty的条件。 ctlctl是一个线程池管理的工具，它打包了两个变量：workerCount和runState，前者表示活动线程数，后者就是前文说提到过的线程池状态。 在代码的实现中ctl用AtomicInteger表示，采用位运算来生成值，低29位保存workerCount，高三位保存runState。比如RUNNING状态用下面代码表示： 1private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; 然后用ctlOf方法来合成： 1private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; wc就是workerCount，这样就把两个变量合成在一串二进制数字中了，当要分别取出它们的时候可以调用下列方法： 12private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125; CAPACITY这个中间变量又是通过下面代码计算得来： 12private static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; 线程池中线程运行机制线程“包裹”在Worker类中，下面就开始研究线程池中线程的运行机制。 Worker类首先Worker的继承结构如下： 1private final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123;&#125; 先行注释有这样一段： This class opportunistically extends AbstractQueuedSynchronizer to simplify acquiring and releasing a lock surrounding each task execution. This protects against interrupts that are intended to wake up a worker thread waiting for a task from instead interrupting a task being run. 这就是shutdown()方法可以在内部调用tryLock()来判断空闲线程的原因所在，Worker继承了AQS，利用了它提供的锁的机制。 Worker类构造函数和run方法： 123456789101112final Thread thread;Runnable firstTask;Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this);&#125;public void run() &#123; runWorker(this);&#125; 变量thread是worker运行的线程，firstTask是初始运行的任务，可以为null。setState(-1)之前在剖析shutdownNow方法的时候已经提到过了，主要就是防止在runWorker之前就调用中断方法，造成线程池提供的shutdownNow方法“失效”。getThreadFactory().newThread方法传入this，为后续开启线程时运行Worker的run方法，而这个方法进一步代理了runWorker(this)。 runWorker()接下来继续看runWorker()代码，限于篇幅，本人把重要的部分抽离出来： 123456789101112131415161718192021222324final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); task.run(); task = null; w.completedTasks++; w.unlock(); &#125;&#125; 这段代码在设计上很好的表明了作者的意图，比如if语句中的Thread.interrupted()，它的目的注释写得很清楚：If pool is stopping, ensure thread is interrupted; if not, ensure thread is not interrupted. interrupted方法在这里调用后会清空标志位。 getTask()接下来研究getTask()代码，我将一些状态判断的代码抽离掉，毕竟前面已经分析够多次相似的情形，而且逻辑也并不复杂(但抽离掉的部分会在一定条件下返回null，这构成前文提到的while循环执行的判断条件，注意一下即可)，余下的代码如下： 123456789101112131415161718private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; nt c = ctl.get(); int wc = workerCountOf(c); boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; try &#123; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; workQueue通常是阻塞队列(不是阻塞队列的情形更简单)，一旦队列内为空，方法体将进入阻塞状态，类似生产者消费者模式。runWorker方法内的循环中，task = getTask()也会处于等待，这个时候，线程池中的这一线程并没有真正执行任务，那么无论之前已调用shutdown()还是shutdownNow()，都将执行Worker对象的interrupt方法。下面用一个小例说明。 下例中的线程池采用newFixedThreadPool，内部是LinkedBlockingQueue队列，先考虑程序中执行了shutdown()的情况： 12345678910111213141516public class ThreadPoolDemo03 &#123; public static void main(String[] args) &#123; ExecutorService pool = Executors.newFixedThreadPool(2); Runnable task01 = () -&gt; &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;; pool.execute(task01); pool.shutdown(); // 注释与未注释结果截然不同 // pool.shutdownNow(); &#125;&#125; 这段代码的结果是在sleep了三秒后正常结束，睡三秒是为了保证pool.shutdown()在sleep之前已经调用，如果调用的是pool.shutdownNow()，结果是程序抛中断异常然后退出。 如果将上述代码中pool.shutdown()语句注释掉，结果是程序将始终挂起。 为什么在while循环之前要调用w.unlock()也就清楚了，程序执行在runWorker()的while循环的判断语句时，如果出现阻塞，会被认为线程处于空闲状态，自然而然不应该持有锁。 到目前为止，已经明白了线程池是如何对所持有的线程进行复用的了。 小结线程池算是并发编程里面的一个“集大成”者，很多技术在线程池里都有涉及，部分技术的理解和运用参考本站其它内容，特别是本人之前对interrupt的分析，对理解线程池很有帮助。 附录Executors创建的线程池简介Executors提供了如下诸多线程池实现： newFixedThreadPool newSingleThreadExecutor newCachedThreadPool newWorkStealingPool newScheduledThreadPool newSingleThreadScheduledExecutor newFixedThreadPool的实现： 123456public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);&#125; corePoolSize和maximumPoolSize的大小相等，keepAliveTime当然只能为0了，这里可以看出它的工作队列采用的是LinkedBlockingQueue，此构造方法需要传入线程工厂实例，但在另一个重载的构造方法中，默认了ThreadFactory参数，所以该参数是可选的。 newSingleThreadExecutor： 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 和newFixedThreadPool最大不一样是将线程池中的线程数固定为1，它同样提供了重载的构造方法，可以自选线程工厂实现。 newCachedThreadPool： 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; corePoolSize设为了0，maximumPoolSize为Integer.MAX_VALUE，可以看作无限大(很难找到需要这么多线程的实际场景)，keepAliveTime设置了60L个单位，工作队列指定为SynchronousQueue，它同样提供了重载的构造方法，可以自选线程工厂实现。 后续JDK版本新增的newWorkStealingPool： 123456public static ExecutorService newWorkStealingPool() &#123; return new ForkJoinPool (Runtime.getRuntime().availableProcessors(), ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);&#125; ForkJoinPool内部实现了工作窃取算法，Runtime.getRuntime().availableProcessors()获取了处理器的核心数，ForkJoinPool.defaultForkJoinWorkerThreadFactory提供了线程工厂，拒绝策略设为null，同步模式为true。同时，存在一个重构方法，第一个参数可以指定为某个值，而不必采用处理器的核心数。 newScheduledThreadPool： 123public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125; 返回的是一个ScheduledThreadPoolExecutor实例，同样的它也存在一个重载构造方法，可以用来自定义线程工厂。继续追踪ScheduledThreadPoolExecutor，它继承自ThreadPoolExecutor并实现了ScheduledExecutorService接口，它的构造方法如下： 12345public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue(), threadFactory);&#125; 内部维护一个DelayedWorkQueue对象作为工作队列。Executors还提供newSingleThreadScheduledExecutor方法，可归在newScheduledThreadPool系列中。 参考资料《Java并发编程的艺术》 Introduction to Thread Pools in Java Java里一个线程调用了Thread.interrupt()到底意味着什么？ toArray() vs. toArray(new Object[0]) Thread pools and work queues 源码分析之ThreadPoolExecutor]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[J.U.C并发框架之AQS(三)：ReentrantLock中断锁]]></title>
    <url>%2F2018%2F05%2F22%2FJUC_AQS03%2F</url>
    <content type="text"><![CDATA[本篇文章将研究ReentrantLock中断锁，首先提两个问题预热：中断锁触发的时机是什么时候？中断锁响应中断后，线程接下来做什么？ 中断锁源码解析和非中断锁不同的是，方法调用的是lockInterruptibly()： 123public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1);&#125; 中断一处既然是中断锁，到底中断在哪里，我急切的问自己，继续追踪源码，发现产生中断的地方有这么两处，一处是在： 1234567public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg);&#125; 写一个简单的例子验证一下，start两个线程Thread-0和Thread-1，这里需要说明的是，为了防止在执行过程中Thread-1的Thread.interrupted()过早执行而未抛出此处异常，使用了LockSupport.park()先将程序挂起： 1234567891011121314151617181920212223242526272829303132333435363738public class ReentrantLockDemo &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new ThreadDemo01(); Thread t2 = new ThreadDemo01(); System.out.println(Thread.currentThread().getName()); t1.start(); t2.start(); Thread.sleep(3000); t2.interrupt(); &#125; public static class ThreadDemo01 extends Thread &#123; public static ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; if (Thread.currentThread().getName().equals("Thread-1")) &#123; LockSupport.park(); &#125; try &#123; lock.lockInterruptibly(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()); try &#123; Thread.sleep(7000); System.out.println("线程" + Thread.currentThread() + "执行完sleep方法"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; 输出为： 12345678910111213141516mainThread-0java.lang.InterruptedExceptionThread-1 at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1220) at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335) at com.demo.ReentrantLockDemo$ThreadDemo01.run(ReentrantLockDemo.java:27)线程Thread[Thread-0,5,main]执行完sleep方法Exception in thread &quot;Thread-1&quot; java.lang.IllegalMonitorStateException线程Thread[Thread-1,5,main]执行完sleep方法 at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151) at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261) at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457) at com.demo.ReentrantLockDemo$ThreadDemo01.run(ReentrantLockDemo.java:39)Process finished with exit code 0 AbstractQueuedSynchronizer.java:1220指的就是acquireInterruptibly方法抛出中断异常的语句。如果触发了这一处的异常，线程Thread-1将不再受AQS内部锁的约束，执行方法体到结束，后续还抛出了一个java.lang.IllegalMonitorStateException异常，这是执行了unlock语句的缘故。 中断二处另一处产生中断的地方在doAcquireInterruptibly方法内，也就是说一旦处于等待队列的挂起线程被非unpark()方式唤醒，将直接抛出中断异常，例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940public class ReentrantLockDemo &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new ThreadDemo01(); Thread t2 = new ThreadDemo01(); System.out.println(Thread.currentThread().getName()); t1.start(); t2.start(); Thread.sleep(3000); t2.interrupt();// LockSupport.unpark(t2); &#125; public static class ThreadDemo01 extends Thread &#123; public static ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123;// if (Thread.currentThread().getName().equals("Thread-1")) &#123;// LockSupport.park();// &#125; try &#123; lock.lockInterruptibly(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()); try &#123; Thread.sleep(7000); System.out.println("线程" + Thread.currentThread() + "执行完sleep方法"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; 输出为： 1234567891011121314151617mainThread-0java.lang.InterruptedException at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898) at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)Thread-1 at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335) at com.demo.ReentrantLockDemo$ThreadDemo01.run(ReentrantLockDemo.java:28)线程Thread[Thread-0,5,main]执行完sleep方法Exception in thread &quot;Thread-1&quot; java.lang.IllegalMonitorStateException线程Thread[Thread-1,5,main]执行完sleep方法 at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151) at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261) at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457) at com.demo.ReentrantLockDemo$ThreadDemo01.run(ReentrantLockDemo.java:40)Process finished with exit code 0 和之前的例子输出不同，这里产生异常的地方在AbstractQueuedSynchronizer.java:898。如果要观察unpark()对程序的影响，可以将代码中注释部分LockSupport.unpark(t2);与t2.interrupt();替换，此时线程并不会抛出中断异常。 小结从前文的分析可知，中断锁的目的就是响应中断，可以通过中断机制避免长时间的线程等待。线程在尝试获取中断锁的时候，中断标志位非零会触发线程抛出中断异常，线程在等待队列挂起时，如果被中断，也会抛出中断异常。 调试在线程上打断点要注意，因为这相当于阻塞线程，一旦一个线程阻塞，另一个竞争状态的线程会抢占锁，最终产生误导的结果。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Future模式]]></title>
    <url>%2F2018%2F05%2F21%2FFuture_Pattern%2F</url>
    <content type="text"><![CDATA[该模式的主要思想是：当你调用方法后，会开启新线程运行方法体，方法体可能不会马上计算出真正结果，但是方法会先给你返回一个值，让你不必一直守在这里等待，你可以去办其它事情，等未来真正需要方法体计算出的结果的时候，再尝试获取。 非java.util.Concurrent包实现首先创建一个接口IData： 123interface IData &#123; String getContent();&#125; FutureData和RealData都实现了这个接口。一开始我们需要的是RealData，但是RealData并没有创建好，没关系，此时并不着急使用RealData提供的数据，这时候返回一个FutureData，它就像RealData的代理一样，等“有朝一日”，需要真正数据的时候，就会用FutureData代理RealData的方法，如果这个时候RealData还是没有生成数据，那么就只有等待了。按照这个思路，接下来实现RealData，在构造器中添加睡眠函数模拟创建需要时间消耗的过程： 12345678910111213141516class RealData implements IData &#123; private String workout; public RealData() &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; workout = "计算出了真正的结果"; &#125; @Override public String getContent() &#123; return workout; &#125;&#125; FutureData的实现： 12345678910111213141516171819202122232425class FutureData implements IData &#123; private IData data; private boolean ready = false; public synchronized void setData(IData data) &#123; if (ready) &#123; return; &#125; this.data = data; ready = true; notifyAll(); &#125; @Override public synchronized String getContent() &#123; while (!ready) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; return data.getContent(); &#125;&#125; 在main函数的执行过程中，setData总是先行调用，第一次调用的时候ready为false，所以等待RealData实例的创建，如果这个创建一直没有完成，那么setData()就一直拿着锁，只要调用getContent()就会一直处于waiting状态。一旦RealData实例创建完成，ready为true此时FutureData的getContent()返回真正的结果。 代理客户端执行类： 1234567891011121314class Host &#123; public IData request() &#123; final FutureData future = new FutureData(); new Thread() &#123; @Override public void run() &#123; RealData realData = new RealData(); future.setData(realData); &#125; &#125;.start(); return future; &#125;&#125; main方法： 12345public static void main(String[] args) &#123; Host host = new Host(); IData iData = host.request(); System.out.println(iData.getContent());&#125; 至此，一个简单的Future模式就手工完成了。 接下来把以上代码改写为java.util.Concurrent包实现。 java.util.Concurrent包实现在Java中java.util.Concurrent包提供了相应的类，对一些核心操作进行了封装，例如不需要FutureData手动写同步方法，只需要去继承FutureTask类，此类是一个继承了Future接口的标准类。 创建FutureData02类，它是前文中FutureData的改写： 123456789101112131415161718class FutureData02 extends FutureTask&lt;RealData&gt; implements IData &#123; public FutureData02(Callable&lt;RealData&gt; callable) &#123; super(callable); &#125; @Override public String getContent() &#123; String result = null; try &#123; result = get().getContent(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; return result; &#125;&#125; 和之前实现FutureData类不同的地方在于，不需要写同步方法，要想获得RealData实例，必须首先调用FutureTask提供的get()。 接着就是代理客户端执行类的实现： 12345678910111213class Host02 &#123; public IData request() &#123; FutureData02 future02 = new FutureData02(new Callable&lt;RealData&gt;() &#123; @Override public RealData call() &#123; RealData realData = new RealData(); return realData; &#125; &#125;); new Thread(future02).start(); return future02; &#125;&#125; Callable可以理解为有返回值的Runnable，想想之前的get()，然后就能体会Callable返回的实例realData。在最后启动线程的时候，传入的是future02，实际上它的父类FutureTask实现了Runnable接口。 小结这里用两种方式，实现了简单的Future模式。 其他问题这里出现了内部匿名类引用外部方法的局部变量必须声明为final的问题，除此之外，引用外部作用域内的局部变量和外部方法的参数也要声明为final，Java 8增加的Effectively final功能聚焦的也是这个问题。可以参考链接： why are only final variables accessible in anonymous class? RednaxelaFX相关答案 也可利用可变对象，构造大小为1的数组来规避。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>Future模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[J.U.C并发框架之AQS(二)：ReentrantLock释放锁]]></title>
    <url>%2F2018%2F05%2F21%2FJUC_AQS02%2F</url>
    <content type="text"><![CDATA[当一个线程执行结束，是怎么唤醒后续线程的？一个线程cancel后是怎样出队的？上一篇主要分析了获取锁，这一篇将聚焦释放锁以解答自己的困惑。本篇还是承接《J.U.C并发框架之AQS(一)：ReentrantLock获取锁》的实验用例，锁限定为非中断且非公平且独占的情形，而中断锁、非公平锁以及独占锁的研究将在后续开专篇解析。 执行lock.unlock()释放锁当Thread-0执行到方法体的lock.unlock()语句时，预示着该线程将释放锁并运行结束。unlock()是这样一个方法： 123public void unlock() &#123; sync.release(1);&#125; release()如下： 123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 首先看看tryRelease(arg)都发生了什么： 123456789101112protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; 该方法releases被传入实参1，由于当前同步器的状态state = 1，所以c等于0，会执行第二个if语句的操作，但是脱离本实例来说，这里的锁是可重入的，所以也可能最后返回的free为false，不释放锁。 继续跟着实验用例分析，在tryRelease(arg)返回true后，程序向下运行，来到一个if语句，判断h是否为null以及h.waitStatus是否等于0。通过上一篇分析可知，head更改默认赋值，通常是在出现在第二个线程后，所以如果原本程序就只有一个线程在执行(这里不包括主线程以及守护线程等)，那么也不存在唤醒后继节点线程的操作了，同样的，h.waitStatus如果等于0，那么要么没有后继节点，要么后继节点不需要唤醒。 unparkSuccessor方法： 1234567891011121314151617181920212223242526private void unparkSuccessor(Node node) &#123; /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; 可以看出当执行了unparkSuccessor方法后，如果节点的ws小于0，会先通过CAS将值设置为0，然后获得node.next并赋值给s。如果s为空，或者s的状态大于0处于cancel状态，那么就从等待队列的尾节点开始，查找第一个ws小于等于0的节点，只要这个节点存在，就调用LockSupport.unpark()将其唤醒。 至此一个正常的释放锁过程就解析完了。 cancelAcquire()同步器内的Node持有CANCELLED字段，默认设置为1，是唯一一个大于0的waitStatus值。之前的解析多次考虑到ws大于1的情形，在AQS里，CANCELLED的设置出现在两个方法中，一个是fullyRelease()，一个是cancelAcquire()，前者主要出现在Condition的实现类，所以这里主要研究cancelAcquire()，且本文开头提到，先考虑研究独占、非中断、非公平锁的情形，也暂不考虑tryLock()，后续将用专门的篇章将这些情形补全。 cancelAcquire方法的代码不是特别长，直接放上： 12345678910111213141516171819202122232425262728293031323334353637383940414243private void cancelAcquire(Node node) &#123; // Ignore if node doesn't exist if (node == null) return; node.thread = null; // Skip cancelled predecessors Node pred = node.prev; while (pred.waitStatus &gt; 0) node.prev = pred = pred.prev; // predNext is the apparent node to unsplice. CASes below will // fail if not, in which case, we lost race vs another cancel // or signal, so no further action is necessary. Node predNext = pred.next; // Can use unconditional write instead of CAS here. // After this atomic step, other Nodes can skip past us. // Before, we are free of interference from other threads. node.waitStatus = Node.CANCELLED; // If we are the tail, remove ourselves. if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; compareAndSetNext(pred, predNext, null); &#125; else &#123; // If successor needs signal, try to set pred's next-link // so it will get one. Otherwise wake it up to propagate. int ws; if (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) &#123; Node next = node.next; if (next != null &amp;&amp; next.waitStatus &lt;= 0) compareAndSetNext(pred, predNext, next); &#125; else &#123; unparkSuccessor(node); &#125; node.next = node; // help GC &#125;&#125; 如果还没创建代表当前线程的节点，自然就直接返回了，如果结点不为空，首先将它内部的thread字段置空，然后就是出队的操作了，不断向前查找第一个waitStatus不大于0的节点，设其为pred，通过pred.next获得它的下个节点，实际上这个节点waitStatus大于0应该cancel，没错，这里获取它是为了后续的CAS操作。 如果传入的节点node是尾节点，那么之前通过不断寻觅获得的第一个waitStatus不大于0的节点pred之后的节点，都应该被移除，移除方法很简单，直接将pred设为尾节点，然后将其next节点置null就行了，在源代码中，这两步采用CAS的方式实现。 如果传入的节点node不是尾节点，那就要考虑要不要唤醒node.next节点的线程。试想，如果pred正好是head节点，就将node.next节点的线程唤醒，让它尝试获取同步锁，这种情形就变成了acquireQueued方法for循环内一开始调用的情形！如果pred引用的线程为null，则也应该唤醒。除此之外，node.next节点的线程可以不需要唤醒(这里之执行unparkSuccessor(node)操作)，只需要将pred的next字段指向node.next节点，而pred的ws如果不是Node.SIGNAL，还要将其设置为Node.SIGNAL。 小结本篇主要分析了ReentrantLock释放锁的过程，还解析了cancelAcquire方法，该方法通常出现在finally语句中，AQS将tryAcquire方法的具体实现交给了衍生类，自己只是抛出一个异常： 123protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125; 使用cancelAcquire方法是为了解决类似这样的bug：https://bugs.openjdk.java.net/browse/JDK-6503247 参考Java中什么样的对象才能作为gc root：在cancelAcquire方法中，处于CANCEL状态的Node对象最终会被垃圾回收，这个帖子下面的回答介绍了哪些算gc root，适合不时review；]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[J.U.C并发框架之AQS(一)：ReentrantLock获取锁]]></title>
    <url>%2F2018%2F05%2F20%2FJUC_AQS01%2F</url>
    <content type="text"><![CDATA[解析ReentrantLock，就是解析AQS！但后者毕竟是一个框架，大而全，且部分功能交由子类重现，不容易找到一个阅读源码的切入点，所以不妨从ReentrantLock开始，先理解AQS实现的独占锁。在解析的过程中，对一些过于简单的细节，不再堆砌，只抓核心功能的实现部分。本解析采用的是jdk1.8.0_171。 实验用例首先释出一个并发的程序： 12345678910111213141516171819202122232425public class ReentrantLockDemo02 &#123; public static void main(String[] args) &#123; Thread t1 = new ThreadDemo01(); Thread t2 = new ThreadDemo01(); System.out.println(Thread.currentThread().getName()); t1.start(); t2.start(); &#125; public static class ThreadDemo01 extends Thread &#123; public static ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; lock.lock(); System.out.println(Thread.currentThread().getName()); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; 运行后，程序先打印出main和Thread-0，过了5秒后打印出Thread-1，又过了五秒程序结束。此程序可以用来作为解析ReentrantLock源码的例子。 锁未被占用时的线程执行Thread-0和Thread-1都尝试过获得锁，但是它们的“际遇”是不一样的，首先我们看看Thread-0。 在自定义的线程类中一开始创建了ReentrantLock对象，而ReentrantLock无参构造方法默认产生的是NonfairSync实例：public ReentrantLock() { sync = new NonfairSync(); } 所以lock是不公平锁(这是什么现在不重要)； t1.start()：程序开始执行run()中的代码； lock.lock()调用的方法如下：final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); } 执行之后的打印语句与睡眠语句； 最后还会执行finally下的lock.unlock()释放锁； 这里重点将第3步一窥究竟。 一开始会进行一个compareAndSetState(0, 1)的判断，这是基于CAS，继续追踪其源码如下： 1234protected final boolean compareAndSetState(int expect, int update) &#123; // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; this指的就是当前锁持有的同步器对象，这里就是第1步里得到的sync，stateOffset是state的底层地址偏移量(用到了反射，也用到了unsafe方法来获得这个值)，expect是期望值，update是要更新成的值。state最开始的值为0，所以这个时候if判断语句为true，执行setExclusiveOwnerThread(Thread.currentThread())，将当前所在的线程设置为exclusiveOwnerThread，表明它是独占模式同步锁的持有者。 锁被占用时的线程执行让我们再来看看Thread-1，同样的，它也会尝试执行Thread-0一样的流程，但是当它在执行第3步的时候，出现了不一样的情况，它会去执行acquire(1)，这个方法的构造是这样的： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 调用上面的方法会先调用tryAcquire(arg)： 123protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires);&#125; 而返回的nonfairTryAcquire()长这样： 123456789101112131415161718final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 这段代码虽然比之前的稍长，但不难理解。Thread.currentThread()获得当前线程，即Thread1，此时的state是1，所以c等于1，第一个if的判断语句为false，直接跳转到else if，但Thread1并不是exclusiveOwnerThread，所以直接跳转到最后的返回语句，返回false。 接着看看acquireQueued(addWaiter(Node.EXCLUSIVE), arg))发生了什么。 先是addWaiter()： 1234567891011121314private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125; 该方法体第一句的作用是根据当前所在的线程，创建一个新的Node实例。由于之前没有提到过Node，这里稍稍解释一下，AQS内部维护一个基于”CLH”(Craig, Landin, and Hagersten)队列修改得到的FIFO队列，每个元素是一个Node实例，而每个Node实例封装了一个线程对象以及一些相关字段和方法，在这里可以先简单理解为一个Node实例代表了一个线程。方法的形参mode传入的是Node.EXCLUSIVE，它将模式标记为独占。 第二句为Node pred = tail，在当前的情况下，所谓的队列还是空的，没有添加任何节点，所以第一个if语句直接跳过，进入到enq()中，if语句的作用注释已经说的很清楚“Try the fast path of enq”，尝试最快入列。 enq()： 123456789101112131415private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 在for循环里，第一个if进行一个null判断，由于当前t是null，所以执行内部语句，内部又嵌入了一个if语句，compareAndSetHead方法是一个CAS方法，作用是如果当前head节点为null，那么就设置为指向一个新创建的Node对象。而当前head节点的确是null，所以head = new Node()，然后执行tail = head语句。程序运行到此时AQS内部结构如下： head和tail指向相同的Node对象，之前本人说过，为了方便，一个Node实例可以简单的被理解为代表一个线程，但是在这里它内部的thread指向的是null，所以这个Node对象是一个“Fake Node”。 注意this后面的打印输出“[State = 1, empty queue]”，也就是说此时被认为队列是空的，我们追踪程序的相关代码，发现判断内部是否存在线程队列，主要在于方法hasQueuedThread： 123public final boolean hasQueuedThreads() &#123; return head != tail;&#125; 至此，AQS维护一个队列的方式也就清楚了，它并不会主动在内部创建Queue对象，而是通过一头(head)一尾(tail)来操作。 方法的执行到这里并没有返回和结束，它会继续执行for循环，这个时候t不再是null，开始执行else语句，词句段的作用相当于将代表Thread-1的Node对象设置为队尾，AQS结构如下： 此时的队列是“nonempty”，一个作为队列头Fake Node实例，双向连接于代表Thread-1的作为队列队尾的Node实例。 回到起初的acquire方法，分析方法内调用的acquireQueued()，它的作用在我看来，就是入队时：尝试获得锁，如果未遂，进而挂起；出队时：挂起被唤醒，尝试去获取锁： 123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 一些参数和变量：addWaiter方法return了代表Thread-1的node，这里作为实参传入，arg在这里为1，方法内声明failed这个标志字段，并将其设置为true，还设置了interrupted字段，此interrupted非彼interrupted(Thread的静态方法)，用来作为是否中断过的标志。 接下来是一个for循环，p是node的前驱，在本例子中，p == head返回true，然后Thread-1还会进行一次获取同步锁的尝试，我个人是觉得两个if的顺序改变不会带来特别大的变化，所以如果非要问为什么一进入方法首先要再次重新尝试tryAcquire()，本人能给出可能的原因是线程在不同状态下切换是一个很“重”的操作，所以赶在切换成等待状态之前，看看能不能获得锁。 如果执行到第一个if语句内部，那么证明该线程拿到了锁，此时setHead(node)做了这么几件事： 将head指针指向自己； // head = node; 将内部持有的线程字段置为null； // node.thread = null; 将前驱指针置为null； // node.prev = null; 这样一来，该节点也演变为“Fake Node”。将p.next = null，这样原本的head指向的“Fake Node”内已经没有指向任何对象，而p又只是一个局部变量，所以没有强引用指向该节点对象，那么它将会被GC。 第一个if的判断语句返回false，不能继续执行括号内的语句，接着跳转到第二个if，shouldParkAfterFailedAcquire方法作用如其名，放上源码： 123456789101112131415161718192021222324252627private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; if (ws &gt; 0) &#123; /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; waitStatus是节点的等待状态，它包括SIGNAL、CANCELLED、CONDITION、PROPAGATE等，这里先重点说说SIGNAL和CANCELLED：SIGNAL的值设置为-1，它表示后继节点的线程需要被唤醒(unparking)，所以显然，当一个节点前驱的waitStatus处于SIGNAL时，那么它就可以放心睡眠；CANCELLED的值为1，它表示线程已经注销。 结合当前的例子，第一次执行该方法时，ws为0，然后他会跳转到else语句，compareAndSetWaitStatus将ws设置为Node.SIGNAL，然后返回false。继续执行acquireQueued()的for循环，由于当前线程仍然不能拿到同步锁，所以又开始执行shouldParkAfterFailedAcquire()，直到前驱节点的ws的值为Node.SIGNAL，整个方法返回true，简单描述过程： 如果前驱节点的ws为Node.SIGNAL，那就直接返回； 如果当前的前驱节点ws值大于1，那么就不断递归查找ws不再大于0的节点作为前驱节点； 与找到的新的前驱节点进行双向链接； 如果前驱节点的ws不大于0，那么将它的ws设置为Node.SIGNAL； 接着就是执行parkAndCheckInterrupt()： 1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; LockSupport.park(this)是不会更改标志位的值的，所以一旦调用了interrupt方法，线程被唤醒，此时Thread.interrupted()的值为true，作为方法的返回值，中断标志位清零。这里多说一下，清零是很重要的动作(虽然默认调用interrupted()就会完成这个动作)，因为在两个park()之间，如果不进行标志位清零，for循环又一次执行到parkAndCheckInterrupt()，线程不会再挂起。而且interrupted()只会响应中断操作，如果是调用了unpark方法唤醒线程，interrupted方法只会返回false(写到这里让我产生interrupted()就是为AQS而生的感觉)。 总之，要了解interrupt()和unpark()作用于等待队列中线程所产生的区别。比如，有一个处于睡眠状态的线程，通过中断机制唤醒后，他会尝试获得锁，如果没有获得锁，它会挂起，不会执行到selfInterrupt()语句，一旦获得锁，会执行到selfInterrupt()，他处于RUNNABLE状态，也不会立即响应中断，但此时它的标志位的值是true。而如果是通过unpark()唤醒，无论它获没获得锁，由于interrupted的值是false，所以永远不会执行到selfInterrupt()语句。 以下代码说明了上述结论： 12345678910111213141516171819202122232425262728public class ReentrantLockDemo &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new ThreadDemo01(); Thread t2 = new ThreadDemo01(); System.out.println(Thread.currentThread().getName()); t1.start(); t2.start(); Thread.sleep(1000); t2.interrupt(); &#125; public static class ThreadDemo01 extends Thread &#123; public static ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; lock.lock(); System.out.println(Thread.currentThread().getName()); try &#123; Thread.sleep(5000); System.out.println("线程" + Thread.currentThread() + "执行完sleep方法"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; 输出结果为： 123456789mainThread-0线程Thread[Thread-0,5,main]执行完sleep方法Thread-1java.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at com.demo.ReentrantLockDemo$ThreadDemo01.run(ReentrantLockDemo.java:24)Process finished with exit code 0 Thread-0在执行的时候，Thread-1进入等待队列，中途Thread-1被interrupt()，当Thread-1获得锁后开始执行，selfInterrupt()更改了中断标志位，Thread-1执行到sleep()语句时，立马响应中断抛出异常。 小结本篇主要介绍线程获取锁的过程，由于跟随实例来进行分析，所以中间有些细节跳过了，但是这些细节都不是需要烧脑理解的部分，比如在shouldParkAfterFailedAcquire方法里，ws &gt; 0的时候，前驱节点的线程被注销，此时应该不断执行node.prev = pred = pred.prev，直到pred.waitStatus &lt;= 0。本篇小文还解析了在线程获取锁过程中，中断操作对线程运行的影响。 参考JDK-6503247：acquireQueued()添加finally机制来处理这种bug；]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[J.U.C并发框架之CAS]]></title>
    <url>%2F2018%2F05%2F19%2FJUC_CAS%2F</url>
    <content type="text"><![CDATA[本篇将入门J.U.C并发框架CAS，会对一部分源码进行解析。 CAS维基百科对CAS的定义：比较并交换(compare and swap, CAS)，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。 CAS源码追踪为了理解这个操作，不妨从一个原子变量开始解析，进入AtomicInteger类查看源码，这个类提供了很多方法，比如compareAndSet()： 123public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update);&#125; 又比如getAndSet()： 123public final int getAndSet(int newValue) &#123; return unsafe.getAndSetInt(this, valueOffset, newValue);&#125; 继续追踪getAndSetInt()，有： 12345678public final int getAndSetInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var4)); return var5;&#125; 可见，该原子类很多方法最终都和compareAndSwapInt()的实现有关，在sun.misc包的Unsafe类下这是一个native方法： 1public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); 在HotSpot源码中继续追踪，打开目录hotspot-327ea6f9647c/src/share/vm/prims下的unsafe.cpp文件，查找compareAndSwapInt方法的实现： 123456UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) UnsafeWrapper("Unsafe_CompareAndSwapInt"); oop p = JNIHandles::resolve(obj); jint* addr = (jint *) index_oop_from_field_offset_long(p, offset); return (jint)(Atomic::cmpxchg(x, addr, e)) == e;UNSAFE_END cmpxchg是一个CPU指令，这里将其视其为一个原子操作即可。 当然CAS包含一系列方法，比如CompareAndSwapLong()等，实现原理基本相同。 CAS操作流程compareAndSwapInt的参数形式是这样的：compareAndSwapInt(Object var1, long var2, int var4, int var5)，参数简要说明如下： var1：进行CAS操作的对象； var2：对象内部当前值的内存地址偏移量； var4：期望值； var5：更新到的值； 在AtomicInteger中复合操作的方法基本上都依靠CAS实现，而compareAndSet更是直接对native方法compareAndSwapInt进行封装。为了说明CAS操作的流程，这里用getAndIncrement()举例。 首先列出Java源码： 123public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125; 追踪getAndAddInt()： 12345678public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; getIntVolatile是一个native方法，读取值的同时也要保证内存可见性。 CAS操作流程大体如下： 调用方法，传入当前对象(this)、所持有的值的内存地址偏移量以及增加值“1”这三个变量； 读取所持有的值，读取时保证内存可见； 以第二步为循环体进行do-while循环，当持有的值和预期值(var5)不相同，则循环一直执行； 满足循环终止条件后，方法返回第二步读取到的值； ABA问题维基百科解释得很清楚： ABA问题是无锁结构实现中常见的一种问题，可基本表述为： 进程P1读取了一个数值A P1被挂起(时间片耗尽、中断等)，进程P2开始执行 P2修改数值A为数值B，然后又修改回A P1被唤醒，比较后发现数值A没有变化，程序继续执行。 通常解决的方法是每次修改value的时候添加个时间戳，可以借助AtomicStampedReference这个原子引用类来完成，但是这个类比较“鸡肋”，因为通常ABA不是一个必须解决的问题，而且当遇到ABA问题使用传统互斥同步的方法更高效(见《深入理解Java虚拟机》 P396)。 小结每个刚接触并发的新人，一开始都会被介绍一个多线程增加共享的counter值的程序，在线程不安全下运行该程序，得到的结果总是和预期值差一点点。一方面告诉我们写程序要考虑并发的安全，同时其实也表明，大多数情况下，多个线程彼此之间不总是处于引发线程不安全的竞争关系中，不然最后的结果也不会只是离预期“差一点点”(是否差一点点还是要根据具体案例)。如果程序员对不发生竞争这件事保持乐观，那么可能更倾向于使用乐观锁。在本篇中CAS实现了乐观锁(当然CAS也可以实现悲观锁)，这是通过底层CPU指令赋予compareAndSwapInt方法以原子性做到的。 参考JAVA CAS原理深度分析：这一篇中关于CPU锁的介绍很通俗易懂。 Java Programming TutorialJava Native Interface (JNI)：这是一篇JNI入门，对以后本文相关内容的扩展解析有裨益。 Intel’s ‘cmpxchg’ instruction：一篇简介CPU指令cmpxchg的PDF。 J.U.C并发框架：Doug Lea的文章，描述了J.U.C并发框架的根源、设计、实现、用法及性能。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程生命周期 & 中断机制]]></title>
    <url>%2F2018%2F05%2F17%2FThread01%2F</url>
    <content type="text"><![CDATA[这一篇主要涉及线程的生命周期和中断机制，对Thread类下的interrupt()源码进行了解析。 线程生命周期线程的生命周期包括一些特有的状态，而Thread提供可以获取这些状态的方法，该方法如下： 1public State getState() 返回的是枚举类型，枚举类结构如下： 12345678public enum State() &#123; NEW, // 还没调用start的线程状态； RUNNABLE, // 调用start执行run方法时的状态，包括了准备状态和运行状态； BLOCKED, // 阻塞状态； WAITING, // 等待状态； TIMED_WAITING, // 限时等待状态； TERMINATED; // 线程运行结束后的状态；&#125; 以上代码中的注释对这些状态进行了简要说明，它们彼此的转换关系可以用一张图来说明： 此图出自Java Thread States and Life Cycle。 在这里对这张图中的某些要点进行一次强调和说明： Runnable状态可以分成Ready和Running，Runnable并不代表一定在执行线程，可能在等待操作系统分配时间片； Timed Waiting在sleeptime elapsed后可以直接进入Runnable态，因为它可以拥有锁，这是它和Waiting的主要区别； Waiting在被唤醒后，除非terminated，否则都会进入Blocked状态，等待monitor lock acquired； 接下来将解析线程的中断机制，最后将尝试在线程的不同状态下进行中断操作，配合源码分析出现的不同结果。 线程中断机制run()方法正常执行到最后，当然是最好的结束线程生命的方式，而这里，将讨论线程的中断机制。(注：本篇不讨论一些过时的结束线程生命的方法) Thread提供的interrupt()是线程中断机制最重要的方法，源代码如下： 1234567891011121314public void interrupt() &#123; if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) &#123; Interruptible b = blocker; if (b != null) &#123; interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; &#125; &#125; interrupt0();&#125; checkAccess()进行访问权限检查，blockerLock是普通Object对象，这里用来加锁保证线程安全。 interrupt()源码解析第一部分本人将synchronized作用的区域作为interrupt()源码的第一部分，首先对这一部分进行解析。 Interruptible是一个普通接口： 123public interface Interruptible &#123; void interrupt(Thread var1);&#125; 在Thread类内部blocker赋值方法如下： 12345void blockedOn(Interruptible b) &#123; synchronized (blockerLock) &#123; blocker = b; &#125;&#125; 在JDK源代码查找这个方法： 除了System类的内部可以指定Thread和Interruptible来调用blockedOn()以外，其它blockedOn()的调用都和AbstractInterruptibleChannel这个抽象类有关。 当然，必须说明的是，这些blockedOn()大都只是同名，并非调用的相同的方法，但即便如此，在具体实现中都封装了Thread的blockedOn()。下面简单梳理一下调用过程： JavaLangAccess是一个接口，内部只声明了一个blockedOn()： 1void blockedOn(Thread t, Interruptible b); SharedSecrets拥有get和set JavaLangAccess实例的方法： 1234567public static void setJavaLangAccess(JavaLangAccess jla) &#123; javaLangAccess = jla;&#125;public static JavaLangAccess getJavaLangAccess() &#123; return javaLangAccess;&#125; System内部有一个私有方法： 12345678910private static void setJavaLangAccess() &#123; // Allow privileged classes outside of java.lang sun.misc.SharedSecrets.setJavaLangAccess(new sun.misc.JavaLangAccess()&#123; ... public void blockedOn(Thread t, Interruptible b) &#123; t.blockedOn(b); &#125; ... &#125;;&#125; 正如我之前所说，最终在实现匿名接口的时候会在blockedOn(Thread t, Interruptible b)内调用Thread类的blockedOn()，那么System的这个方法又是什么时候调用的呢？ 在java.lang包下的System 虽然是一个不能实现化的类，但是它有一个私有的静态方法initializeSystemClass()，通过类的静态初始化，registerNatives()会注册本地方法，虚拟机就会调用initializeSystemClass()方法完成类的初始化(非clinit)，该方法调用于线程初始化后。 AbstractInterruptibleChannel 也拥有一个静态blockedOn方法，源码如下： 1234static void blockedOn(Interruptible intr) &#123; // package-private sun.misc.SharedSecrets.getJavaLangAccess().blockedOn(Thread.currentThread(), intr);&#125; 最终它调用的正是System类设置的实现匿名JavaLangAccess接口的 blockedOn()。 接下来重点关注AbstractInterruptibleChannel类的begin()、end(boolean completed)，看看给blockedOn传参执行的时机。 首先简单介绍一下AbstractInterruptibleChannel，源码注释有一句是这么说的： 1* Base implementation class for interruptible channels. 直译过来就是说这个类是中断通道实现类的基础。 接下来有一段关键的注释： 1234567891011121314151617* &lt;p&gt; This class encapsulates the low-level machinery required to implement* the asynchronous closing and interruption of channels. A concrete channel* class must invoke the &#123;@link #begin begin&#125; and &#123;@link #end end&#125; methods* before and after, respectively, invoking an I/O operation that might block* indefinitely. In order to ensure that the &#123;@link #end end&#125; method is always* invoked, these methods should be used within a* &lt;tt&gt;try&lt;/tt&gt;&amp;nbsp;...&amp;nbsp;&lt;tt&gt;finally&lt;/tt&gt; block: &lt;a name=&quot;be&quot;&gt;** &lt;blockquote&gt;&lt;pre&gt;* boolean completed = false;* try &#123;* begin();* completed = ...; // Perform blocking I/O operation* return ...; // Return result* &#125; finally &#123;* end(completed);* &#125;&lt;/pre&gt;&lt;/blockquote&gt; 意思是这个类封装了实现异步关闭和中断通道的low-level机制，一个具体的通道类必须在一个可能出现无限期IO阻塞的操作之前和之后分别调用begin和end方法，为确保调用了end方法，应将该方法放在finally语句块中。 先来看看begin方法，源码如下： 1234567891011121314151617181920protected final void begin() &#123; if (interruptor == null) &#123; interruptor = new Interruptible() &#123; public void interrupt(Thread target) &#123; synchronized (closeLock) &#123; if (!open) return; open = false; interrupted = target; try &#123; AbstractInterruptibleChannel.this.implCloseChannel(); &#125; catch (IOException x) &#123; &#125; &#125; &#125;&#125;; &#125; blockedOn(interruptor); Thread me = Thread.currentThread(); if (me.isInterrupted()) interruptor.interrupt(me);&#125; 前文已经提到过，Interruptible 是一个普通的接口，内部只有一个带有Thread形参的interrupt方法(和Thread的interrupt方法同名)，在begin中匿名实现了这个接口，而这个接口的实现内容都有什么呢？ 一开始使用通道默认标志open设为true，代表通道是打开状态，Interruptible的interrupt方法中，如果检查open为false，那么直接return，为true时继续执行，继续执行过程中将true设置为false，因为继续执行意味着将在最后关闭通道(后续try内的代码起到了关闭通道的作用)，这样下次再进行相同的检测时，就处于关闭状态进而return了。 接下来是try catch语句，主要功能是对通道进行关闭处理。implCloseChannel是一个没有实现的抽象方法，看看注释是怎么解释的： 12345678* &lt;p&gt; This method is invoked by the &#123;@link #close close&#125; method in order* to perform the actual work of closing the channel. This method is only* invoked if the channel has not yet been closed, and it is never invoked* more than once.** &lt;p&gt; An implementation of this method must arrange for any other thread* that is blocked in an I/O operation upon this channel to return* immediately, either by throwing an exception or by returning normally. 大致意思是说，该方法由close方法调用，以关闭通道，仅当通道未关闭时调用，且永远只会调用一次；此方法的实现还必须运作此通道内阻塞在IO操作上的其它线程立即返回，或抛异常或正常返回。 后续的代码解释起来就不复杂了：blockedOn(interruptor)相当于将interruptor注册到当前的线程中，在调用begin方法的时候首先判断一次线程是否被中断(调用当前线程isInterrupted方法来判断)，如果为true，就会调用interruptor的interrupt方法。 我们再次回到Thread的interrupt方法，看下面这段代码： 12345678synchronized (blockerLock) &#123; Interruptible b = blocker; if (b != null) &#123; interrupt0(); // Just to set the interrupt flag b.interrupt(this); return; &#125;&#125; interrupt0()在这段代码中Just to set the interrupt flag！而后面b.interrupt(this)相当于回调了Interruptible的方法，等同于begin()中最后代码的作用。 再来看end方法： 123456789101112protected final void end(boolean completed) throws AsynchronousCloseException&#123; blockedOn(null); Thread interrupted = this.interrupted; if (interrupted != null &amp;&amp; interrupted == Thread.currentThread()) &#123; interrupted = null; throw new ClosedByInterruptException(); &#125; if (!completed &amp;&amp; !open) throw new AsynchronousCloseException();&#125; completed用来表示IO操作是否完成，整个end主要用来置空和抛出相应异常。在方法begin()中设置了interrupted，而end中第一个if用来判断中断线程是否为当前线程，如果为true，将interrupted置空并抛出ClosedByInterruptException异常，如果通道关闭，IO操作未完成，抛出AsynchronousCloseException异常。 第一部分小结Thread interrupt()的第一部分就解析完了，这一部分主要“服务于”实现了AbstractInterruptibleChannel的通道类。在解析源码之前的先验知识告诉我们，interrupt()通常是set flag，但在这一段代码中，我们可以发现，interrupt会主动回调interruptor的interrupt()来关闭通道，同时回调的方法也会更改字段open的状态，这个状态可以作为条件之一用于end()中判断是否抛出AsynchronousCloseException。 interrupt()源码解析第二部分第二部分是对剩下的interrupt()进行简要解析。 目标代码如下： 1private native void interrupt0(); 这是一个native方法，去往链接： http://hg.openjdk.java.net/jdk7u/jdk7u/jdk/file/tip/src/share/native/java/lang/Thread.c 查找interrupt0方法，得到： 1&#123;"interrupt0", "()V", (void *)&amp;JVM_Interrupt&#125; 这是JNINativeMethod结构体的一个实例，该结构体描述了注册信息，我在前文介绍System类时提到过本地方法注册(关于JNI注册本地方法这里就不展开了)。这里”interrupt0”为Java类中Native方法名，”()V”表示无参无返回值，”JVM_Interrupt”为对应的本地方法名，所以这里的注册信息表明了一个一一对应的映射关系。 那么本地方法实现到底在什么地方？ RednaxelaFX在这个链接进行了回答： http://hllvm.group.iteye.com/group/topic/35385#post-236056 具体的实现代码在这里： http://hg.openjdk.java.net/jdk7u/jdk7u/hotspot/file/tip/src/share/vm/prims/jvm.cpp 源码如下： 12345678910111213JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread)) JVMWrapper("JVM_Interrupt"); // Ensure that the C++ Thread and OSThread structures aren't freed before we operate oop java_thread = JNIHandles::resolve_non_null(jthread); MutexLockerEx ml(thread-&gt;threadObj() == java_thread ? NULL : Threads_lock); // We need to re-resolve the java_thread, since a GC might have happened during the // acquire of the lock JavaThread* thr = java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)); if (thr != NULL) &#123; Thread::interrupt(thr); &#125;JVM_END 定位关键方法：Thread::interrupt(thr)，此方法来自这里： http://hg.openjdk.java.net/jdk7u/jdk7u/hotspot/file/tip/src/share/vm/runtime/thread.cpp 继续查找相关实现，跳转到798行： 12345void Thread::interrupt(Thread* thread) &#123; trace("interrupt", thread); debug_only(check_for_dangling_thread_pointer(thread);) os::interrupt(thread);&#125; 定位关键方法：os::interrupt(thread)，这里os对应多个系统，所以有多个不同场景，具体对应哪些系统见下图： 这里不妨选取Linux进行分析，先摆出代码： 123456789101112131415161718192021222324void os::interrupt(Thread* thread) &#123; assert(Thread::current() == thread || Threads_lock-&gt;owned_by_self(), "possibility of dangling Thread pointer"); OSThread* osthread = thread-&gt;osthread(); if (!osthread-&gt;interrupted()) &#123; osthread-&gt;set_interrupted(true); // More than one thread can get here with the same value of osthread, // resulting in multiple notifications. We do, however, want the store // to interrupted() to be visible to other threads before we execute unpark(). OrderAccess::fence(); ParkEvent * const slp = thread-&gt;_SleepEvent ; if (slp != NULL) slp-&gt;unpark() ; &#125; // For JSR166. Unpark even if interrupt status already was set if (thread-&gt;is_Java_thread()) ((JavaThread*)thread)-&gt;parker()-&gt;unpark(); ParkEvent * ev = thread-&gt;_ParkEvent ; if (ev != NULL) ev-&gt;unpark() ;&#125; 接下来将解读上述代码： 程序通过thread-&gt;osthread()来获取系统线程，Java线程基于操作系统原生线程来实现。 osthread-&gt;set_interrupted(true)用来设置中断标志。 通过OrderAccess::fence()这段代码创建内存屏障，其目的是让其它线程对我们执行unpark()之前保存的interrupted()值具有可见性。 slp-&gt;unpark()是中断Thread.sleep()的方法。 ((JavaThread*)thread)-&gt;parker()-&gt;unpark()是中断LockSupport.park()的方法。 ev-&gt;unpark()是中断Object.wait()的方法。 关于ParkEvent和Parker的区别，HotSpot注释里有一个比较简要的概括： The JVM uses 2 very similar constructs: ParkEvent are used for Java-level “monitor” synchronization. Parkers are used by JSR166-JUC park-unpark. We`ll want to eventually merge these redundant facilities and use ParkEvent. 所以它们结构基本上是相似的，未来HotSpot可能将它们进行整合。不同的地方在于ParkEvent“服务”于monitor，monitor依赖底层实现，对象头Mark Word记录了一些相关信息，这里为了方便理解可以认为monitor被对象持有，所以ParkEvent需要同步对象。 unpark()：这里留个钩子，暂时没有继续进行解析，未来有需要再展开。 第二部分小结通过第二部分的解析，了解了调用Thread类的interrupt()会对线程的哪些状态进行直接操作，对照本文起初的线程状态转换关系图，这些状态属于Timed Waiting状态以及Waiting状态，本文后续部分，将讨论interrupt()对线程不同状态的作用。 线程不同状态的中断响应RUNNABLE状态在这个状态下，interrupt()只会设置线程的中断标志，现在假设在目标线程运行的时候，对它进行interrupt()，然后将该线程睡眠，此时线程会响应中断吗？运行代码： 12345678910111213141516171819202122232425262728public class ThreadInterruptTestDemo03&#123; public static volatile boolean flag01 = true; public static void main(String[] args) throws InterruptedException &#123; Thread t = new ThreadDemo(); t.start(); t.interrupt(); Thread.sleep(2000); System.out.println("主线程睡眠结束！"); flag01 = false; &#125;&#125;class ThreadDemo extends Thread &#123; @Override public void run() &#123; while (flag01) &#123; &#125; try &#123; Thread.sleep(10000); System.out.println("正常睡眠结束！"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果如下： 123456主线程睡眠结束！java.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at com.cg.ThreadDemo.run(ThreadInterruptTestDemo03.java:26)Process finished with exit code 0 Timed Waiting / Waiting状态此状态，本人在之前的篇幅中已经解析完毕。现在考虑这样一种情形，在一个线程的run()里，首先interrupt()一个sleep()，如果run()后续存在LockSupport.park()，那么线程会转为waiting状态吗？ 123456789101112131415161718192021222324252627282930313233343536public class ThreadInterruptTestDemo03 &#123; public static volatile boolean flag01 = true; public static void main(String[] args) throws InterruptedException &#123; Thread t = new ThreadDemo(); t.start(); t.interrupt(); Thread.sleep(2000); System.out.println("主线程睡眠结束！"); flag01 = false; &#125;&#125;class ThreadDemo extends Thread &#123; @Override public void run() &#123; while (flag01) &#123; &#125; try &#123; Thread.sleep(10000); System.out.println("正常睡眠结束！"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().isInterrupted()); LockSupport.park(); &#125; // try &#123; // Thread.sleep(10000); // System.out.println("又睡醒了！"); // &#125; catch (InterruptedException e) &#123; // e.printStackTrace(); // &#125;&#125; 该程序会运行结束。如果取消注释掉的代码，程序会timed waiting十秒然后结束。 BLOCKED如果线程处在BLOCKED状态，interrupt()只会设置线程的中断标志。 线程状态中断响应小结对照本文起初的线程状态转换关系图，可以知道，通常，线程调用sleep方法、wait方法、join方法以及park方法后会进入waiting / timed waiting状态，如果是await等JUC提供的方法呢？由于这些方法实现上都借助了park等方法，所以它们仍将进入此状态。 本篇小结见各部分小结。 参考相关源码的查找见此篇： http://hllvm.group.iteye.com/group/topic/35385#post-236056 HotSpot源码目录注释： http://hllvm.group.iteye.com/group/topic/26998#193368 这是一篇关于LockSupport的park和unpark的源码剖析：http://www.dayexie.com/detail1684592.html]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git带着问题去实践(四)]]></title>
    <url>%2F2018%2F05%2F15%2FGit-Prac04%2F</url>
    <content type="text"><![CDATA[本篇主要用来入门Git协作。 首先来熟悉一些团队协作涉及的基本命令。 如何查看当前仓库的远程连接情况？ 可以通过remote命令来实现： 123$git remote -vorigin https://github.com/cgIIrw/Git_Prac.git (fetch)origin https://github.com/cgIIrw/Git_Prac.git (push) 也可以只使用git remote显示连接别名，这里是origin。 通过git remote rename &lt;old&gt; &lt;new&gt;可以更改old名为new名。 通过fetch拉取的远程提交存放在什么地方？ 执行命令： 123$git fetch origin masterFrom https://github.com/cgIIrw/Git_Prac * branch master -&gt; FETCH_HEAD 拉取的信息被保存在.git下的FETCH_HEAD文件中，读取该文件： 12$cat .git/FETCH_HEAD050b5ea26b2594f7d78c6a9271221edf86dfe6e9 branch 'master' of https://github.com/cgIIrw/Git_Prac 可见该文件保存了远程仓库master分支的提交号。 如何合并fetch到的远程提交？ 首先要确定合并到本地的哪一个提交，这一步可以使用git checkout &lt;branch&gt;来实现，然后将fetch到的远程提交合并到该上，采用命令： 1$git merge FETCH_HEAD 要注意的是，git pull通常相当于执行了git fetch再执行git merge，但一般不建议使用git pull而是使用后者。 如何将git pull默认的merge改为rebase？ 前面已经提到了，git pull相当于git fetch + git merge，如果希望merge更改为rebase，那么只要显式的调用git pull --rebase origin即可，它表示拉取当前分支对应的公共仓库中的提交，然后并入当前分支。 git push origin serverfix:serverfix命令的意涵是什么？ progit-zh-v2.1.1.pdf里这样写道：“推送本地的serverfix分支，将其作为远程仓库的serverfix分支”，但是如果执行git push origin branch01:master，会提示： 1234567To https://github.com/cgIIrw/Git_Prac.git ! [rejected] branch01 -&gt; master (non-fast-forward)error: failed to push some refs to 'https://github.com/cgIIrw/Git_Prac.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 说明了你要推送的这个版本落后于服务器上的版本，如果非要推送，可以尝试添加-f参数。 如何使用pull request参与一个项目？ 首先，pull request是GitHub的一个功能，并非Git的特性，而同一个GitHub账号通过不同分支也能进行pull request，下面就来模拟一下。 新建一个分支名为pullrequestbranch，修改text01.md的内容，添加一行“Add pull request branch.”语句。将该分支推送到公共仓库，进入到该分支： 点击new pull request选项，然后撰写comment： 点击Create pull request，解决掉冲突后出现的画面： 点击Merge pull request后完成合并： 小结本篇介绍了几个常用的写作命令，并用实践的方式尝试使用使用pull request参与一个项目。 参考progit-zh-v2.1.1.pdf]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git带着问题去实践(三)]]></title>
    <url>%2F2018%2F05%2F11%2FGit-Prac03%2F</url>
    <content type="text"><![CDATA[本篇继续之前系列，实践变更、回滚提交的操作。 怎么修改最近一次提交？ 假设最近完成了一次提交，但是对提交的内容以及描述的信息都不满意，那么就可以使用git commit --amend指令。 完整的格式可以是： 1git commit -a --amend -m "描述信息" 如果不想修改描述信息，可以将-m &quot;描述信息&quot;更改为--no-edit。 这次提交不会修改提交时间，但是是一次新的提交，之前的旧的提交会被取消。 所以一般来说，这个命令的作用有两个： 如果提交后，发现有漏掉的文件没有添加，可以将其git add，将其添加进暂存区，使用该命令会替换上一次提交的结果； 如果单纯想要修改上一次提交的描述信息，可以使用该命令； git reset –soft和git reset –hard的区别是什么？ 首先测试一番git reset --soft命令： 12345678910111213141516$git log --oneline5100572 (HEAD -&gt; master) text git reset soft02ec78d25 add reset head02a05a787 After stash02.06961ba (branch02) Second commit2d7fae0 First commit$git statusOn branch masternothing to commit, working tree clean$git reset --soft head^$git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) modified: text01.md 上面的结果可以看出，git reset --soft head^将当前的版本回退到上一次提交，但回退后会保留上一次提交后staged状态下的内容。 git reset --hard head^命令不会保留上一次提交后staged状态下的内容。 git reset(AKA git reset –mixed)和git reset –hard区别是什么？ 这里引用《Git团队合作》中的图片： 这张图讨论的情形并不周全，比如之前第二个问题涉及的git reset --soft命令就没有出现，翻译也不精准，但是还是可以凑合的说明git reset --hard和git reset的区别。 当修改处于staged状态下的内容时，通过git reset --hard可以将staged状态下的内容清除；而通过git reset则会将staged状态下的内容转为modified状态。 当修改已经提交的内容时，git reset --hard &lt;commit&gt;会将当前版本切换到&lt;commit&gt;提交的那次版本，modified以及staged状态下的内容都清空；而git reset &lt;commit&gt;会回退到&lt;commit&gt;提交后的modified状态。 什么是变基？ 首先使用git log --oneline --graph --decorate --all打印提交图查看当前的提交状况： 12345678910111213$git log --oneline --graph --decorate --all* 5100572 (HEAD -&gt; master) text git reset soft02* ec78d25 add reset head02| * d06e697 (refs/stash) On master: have modified have staged| |\|/ /| * 11e6b30 index on master: a05a787 After stash02.|/* a05a787 After stash02.| * 336688c (branch01) commit branch01|/* 06961ba (branch02) Second commit* 2d7fae0 First commit 切换到提交ec78，创建分支rebasebranch，修改text01.md然后保存并提交，当前的提交状况变为： 1234567891011121314* 73725f1 (HEAD -&gt; rebasebranch) add rebasebranch| * 5100572 (origin/master, master) text git reset soft02|/* ec78d25 add reset head02| * d06e697 (refs/stash) On master: have modified have staged| |\|/ /| * 11e6b30 index on master: a05a787 After stash02.|/* a05a787 After stash02.| * 336688c (branch01) commit branch01|/* 06961ba (branch02) Second commit* 2d7fae0 First commit 使用命令git rebase master进行变基，结果出现冲突： 123456789101112131415First, rewinding head to replay your work on top of it...Applying: add rebasebranchUsing index info to reconstruct a base tree...M text01.mdFalling back to patching base and 3-way merge...Auto-merging text01.mdCONFLICT (content): Merge conflict in text01.mderror: Failed to merge in the changes.Patch failed at 0001 add rebasebranchhint: Use 'git am --show-current-patch' to see the failed patchResolve all conflicts manually, mark them as resolved with"git add/rm &lt;conflicted_files&gt;", then run "git rebase --continue".You can instead skip this commit: run "git rebase --skip".To abort and get back to the state before "git rebase", run "git rebase --abort". 进入文件修改冲突，然后使用git add进行提交，继续输入命令git rebase --continue有： 12345678910111213* 050b5ea (HEAD -&gt; rebasebranch) add rebasebranch* 5100572 (origin/master, master) text git reset soft02* ec78d25 add reset head02| * d06e697 (refs/stash) On master: have modified have staged| |\|/ /| * 11e6b30 index on master: a05a787 After stash02.|/* a05a787 After stash02.| * 336688c (branch01) commit branch01|/* 06961ba (branch02) Second commit* 2d7fae0 First commit 此时切换到master分支并运行merge命令，有： 12345678910111213* 050b5ea (HEAD -&gt; master, rebasebranch) add rebasebranch* 5100572 (origin/master) text git reset soft02* ec78d25 add reset head02| * d06e697 (refs/stash) On master: have modified have staged| |\|/ /| * 11e6b30 index on master: a05a787 After stash02.|/* a05a787 After stash02.| * 336688c (branch01) commit branch01|/* 06961ba (branch02) Second commit* 2d7fae0 First commit 本人将每一步历史记录的提交图贴出，目的就是为了说明rebase的作用。总的来说，它和merge拥有一样的功能，但是和merge不一样的点在于，它能保持一个线性的项目提交史。 在上文中，如果要进行变基，需要首先切换到rebasebranch，然后进行git rebase master，为了简便，可以使用git rebase master rebasebranch的方法来取代。 变基遵循法则：不要对在你的仓库外有副本的分支执行变基。公共仓库通常都拥有副本，所以不要在公共仓库的分支中使用它。该条同样适用于git commit --amend以及git reset命令。 git revert如何使用？ 前面提到了git reset等命令也遵循变基遵循的法则，那么如果要在公共仓库对版本进行回退，可以使用git revert命令。 执行命令git revert head得到结果： 123456789101112131415Revert "add rebasebranch"This reverts commit 050b5ea26b2594f7d78c6a9271221edf86dfe6e9.# Please enter the commit message for your changes. Lines starting# with '#' will be ignored, and an empty message aborts the commit.## On branch master# Your branch is up to date with 'origin/master'.## Changes to be committed:# modified: text01.md#~ ... 保存后退出，完成了一次新的提交，该提交是之前head指向的提交撤销了更改的一个版本。线性提交的各个版本罗列如下： 1234567455760d (HEAD -&gt; master) Revert "add rebasebranch"050b5ea (origin/master, rebasebranch) add rebasebranch5100572 text git reset soft02ec78d25 add reset head02a05a787 After stash02.06961ba (branch02) Second commit2d7fae0 First commit 可见git revert命令不会删除回退的版本，这是它和git reset最大的不同。正是因为这个特性，在公共仓库进行回退操作时优先使用git revert。 查看text01.md，其内容变更为： 123456Test git reset --hard command.Test amend command.Test git reset --soft. 而之前add rebasebranch版本的提交是添加了add rebasebranch语句的，所以的确拥有回退的效果。 小结本篇重点介绍了一些前篇没有涉及的一些git命令，并对这些命令的功能、使用场景进行了简要分析。 参考Git团队协作 progit-zh-v2.1.1.pdf]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机之本地方法调用实现]]></title>
    <url>%2F2018%2F05%2F07%2FJVMNative%2F</url>
    <content type="text"><![CDATA[Java虚拟机规范对本地方法和本地方法栈的实现要求是非常宽松的，甚至明确说明“如果Java虚拟机不支持native方法，自己也不依赖传统栈(通常指“C Stacks”)的话，可以无需支持本地方法栈”。商业级别的HotSpot将虚拟机栈和本地方法栈合并，并采用JNI规范来实现本地方法。而本文也采用虚拟机栈和本地方法栈合并的模式来模仿编写。 很容易想到，要调用本地方法，可以采用一个Map来做映射： 12345// 一一映射public static void registerMethod(String className, String methodName, String methodDescriptor, NativeMethod nativeMethod) &#123; String key = className + "~" + methodName + "~" + methodDescriptor; register.put(key, nativeMethod);&#125; 暂时将registerNatives()设置为空实现。 本地方法的调用本地方法调用还是在Java方法的架构下进行，可以是静态方法也可以是非静态方法，修改方法调用的公有逻辑MethodInvokeLogic()，将以前的钩子处理(用来忽略本地方法registerNatives，遇到该方法就将方法从虚拟机栈弹出)注释掉。 接着修改Method_的构造方法，思路无非就是如果这个方法是Native的，那么就填充一些参数(设定maxStack和maxLocals，注入code等)，让原本的框架仍然“认为”它就是一个普通的方法，而在执行的时候真正去执行本地方法，执行完后，还要通过返回指令回到框架。 根据上面的思路，首先修改Method_构造方法，在末尾添加： 1234567891011// 判断方法是否是本地方法，如果是，那么求出代表返回值的描述符片段，// 通过该片段来判断返回字节码指令的类型if (this.isNative()) &#123; // 获得方法的描述符 String des = this.getDescriptor(); Pattern pattern = Pattern.compile("(?=\\().*(?&lt;=\\))"); Matcher matcher = pattern.matcher(des); // 得到代表返回值的描述符片段 String returnDes = matcher.replaceAll(""); this.injectCodeAttribute(returnDes);&#125; 然后实现injectCodeAttribute方法： 12345678910111213141516171819202122232425262728// 注入字节码，为调用本地方法服务private void injectCodeAttribute(String returnType) &#123; // 幸运数字7 this.maxStack = 7; this.maxLocals = this.getArgSlotCount(); // 第二个字节码指令用于执行本地方法后的返回 switch (returnType.charAt(0)) &#123; case 'V': this.code = new int[]&#123;0xfe, 0xb1&#125;; break; case 'D': this.code = new int[]&#123;0xfe, 0xaf&#125;; break; case 'F': this.code = new int[]&#123;0xfe, 0xae&#125;; break; case 'J': this.code = new int[]&#123;0xfe, 0xad&#125;; break; case 'L': case '[': this.code = new int[]&#123;0xfe, 0xb0&#125;; break; default: this.code = new int[]&#123;0xfe, 0xac&#125;; break; &#125;&#125; 这里用到了Java虚拟机预留的字节码指令0xfe，当虚拟机遇到该指令时，就会执行指令背后的相关逻辑，也就是如下代码： 123456789101112131415161718public class INVOKE_NATIVE extends NoOperandsInstruction &#123; @Override public void execute(StackFrame_ frame) &#123; Method_ method = frame.getMethod_(); String className = method.getClass_().getThisClassName(); String methodName = method.getName(); String methodDescriptor = method.getDescriptor(); // 查找相应的本地方法 NativeMethod nativeMethod = Registry.findNativeMethod(className, methodName, methodDescriptor); // 如果返回的是null，那么抛出一个带有信息的运行时异常 if (nativeMethod == null) &#123; String methodInfo = className + "." + methodName + methodDescriptor; throw new RuntimeException(methodInfo); &#125; // 执行本地方法 nativeMethod.execute(frame); &#125;&#125; 最后要做的是在字节码指令工厂内对0xfe进行注册。 完成了上面的步骤，接下来只需要添加本地方法的实现就可以了。 如果想知道运行当前项目会调用几次registerNatives方法，可以在registerNatives的方法体添加打印语句，具体处理如下： 123456if (methodDescriptor.equals("()V") &amp;&amp; methodName.equals("registerNatives")) &#123; return frame -&gt; &#123; // do nothing System.out.println(frame.getMethod_().getClass_().getThisClassName()); &#125;;&#125; 会打印出： 12java/lang/Objectjava/lang/System 这两个类都拥有registerNatives方法，在static语句块内会先运行registerNatives()，输出打印语句。 不知不觉已经完成了一次本地方法的调用。 实现hashCode()本地方法的实现都大同小异，这里列举如何实现Object类的hashCode方法。 首先进入Object.java的源代码有： 1public native int hashCode(); 然后在OpenJDK里查询Object.c有： 1234567891011121314static JNINativeMethod methods[] = &#123; &#123;"hashCode", "()I", (void *)&amp;JVM_IHashCode&#125;, &#123;"wait", "(J)V", (void *)&amp;JVM_MonitorWait&#125;, &#123;"notify", "()V", (void *)&amp;JVM_MonitorNotify&#125;, &#123;"notifyAll", "()V", (void *)&amp;JVM_MonitorNotifyAll&#125;, &#123;"clone", "()Ljava/lang/Object;", (void *)&amp;JVM_Clone&#125;,&#125;;JNIEXPORT void JNICALLJava_java_lang_Object_registerNatives(JNIEnv *env, jclass cls)&#123; (*env)-&gt;RegisterNatives(env, cls, methods, sizeof(methods)/sizeof(methods[0]));&#125; 按照这个结构仿写。 JObject &amp; JSystem这里的JObject和JSystem对应Object.c和System.c。JObject代码如下： 1234567891011121314151617public class JObject &#123; private static JNINativeMethod[] methods = &#123; new JNINativeMethod("hashCode", "()I", new JVM_IHashCode()), new JNINativeMethod("wait", "(J)V", new JVM_MonitorWait()), new JNINativeMethod("notify", "()V", new JVM_MonitorNotify()), new JNINativeMethod("notifyAll", "()V", new JVM_MonitorNotifyAll()), new JNINativeMethod("clone", "()Ljava/lang/Object;", new JVM_Clone()), &#125;; // 传入className，对本地方法进行注册 public static void Java_java_lang_Object_registerNatives(String className) &#123; for (JNINativeMethod jniNativeMethod : methods) &#123; Registry.registerMethod(className, jniNativeMethod.getMethodName() , jniNativeMethod.getMethodDescriptor(), jniNativeMethod.getNativeMethod()); &#125; &#125;&#125; JNINativeMethod类用来存储参数，这些参数可以用来注册本地方法。而本地方法都声明在JVM_ENTRY接口中。 接下来需要修改Registry类，处理查找到registerNatives方法时的逻辑。前面已经提到了，在Java中Object和System都拥有registerNatives方法用来注册本地方法。当查找到registerNatives方法后，应该确定是哪一个类的registerNatives()，具体代码见下： 1234567891011121314151617181920String[] temp = className.split("/");String string = "";for (int i = 0; i &lt; temp.length - 1; i++) &#123; string = string + temp[i] + ".";&#125;// 将原本className的最后的简单名前添加一个“J”，在className前添加“native_.”String name = "native_." + string + "J" + temp[temp.length - 1];try &#123; Class&lt;?&gt; c = Class.forName(name); for (Method method : c.getMethods()) &#123; // 方法名以"registerNatives"结尾时，为要寻找的方法 if (method.getName().endsWith("registerNatives")) // 静态方法，所以第一个参数为null method.invoke(null, className); &#125;&#125; catch (ClassNotFoundException | IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace();&#125; 一些核心代码的理解见注释。同理可以修改JSystem.java中的代码。 完成JVM_IHashCode接下来只要完成JVM_ENTRY下的JVM_IHashCode类，就能实现调用本地方法的功能，下面给出代码： 12345678910class JVM_IHashCode implements NativeMethod &#123; @Override public void execute(StackFrame_ frame) &#123; Instance_ thisRef = frame.getLocalVars().getRef(0); // 本地方法的调用 int hashCode = thisRef.hashCode(); frame.getOperandStack().pushInt(hashCode); &#125;&#125; 代码中没有自己去实现hashCode的计算，而是直接采用的虚拟机编写语言Java的API，这样就完成了本地方法调用。 小结要完成更多本地方法的调用，就需要先行完成库的编写。本篇旨在了解基本原理，实现的过程中借用了0xfe这个保留的字节码来触发执行本地方法的逻辑，也可以采用其它方式。而如果要探究商业级虚拟机本地方法调用的过程，可以参考相关技术规范。 参考JNI技术规范：JNI 6.0官方技术文档翻译 向JVM注册本地方法是怎么实现的]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机之方法引用实现原理(下)]]></title>
    <url>%2F2018%2F05%2F04%2FJVM_032%2F</url>
    <content type="text"><![CDATA[本篇将主要记录invokestatic、invokespecial、invokevirtual指令的实现以及类初始化的编写，invokeinterface的实现基本类似就不赘述了。 invokestatic该指令用来实现静态方法的调用。 123456789101112131415public class INVOKE_STATIC extends Index16Instruction &#123; @Override public void execute(StackFrame_ frame) &#123; RuntimeConstantPool_ cp = frame.getMethod_().getClass_().getRuntimeConstantPool(); MethodRef methodRef = (MethodRef) (cp.getConstant(index).getVal()); Method_ resolvedMethod = methodRef.resolvedMethod(); if (!resolvedMethod.isStatic()) &#123; throw new IncompatibleClassChangeError(); &#125; // todo 类初始化判断，类没有初始化要进行初始化 MethodInvokeLogic.invokeMethod(frame, resolvedMethod); &#125;&#125; 在调用静态方法之前必须进行类初始化，这里先留空。而MethodInvokeLogic.invokeMethod方法是方法调用指令的公有逻辑，它包含了上一篇提到的操作数栈到局部变量表的映射逻辑，具体参看源码。 invokespecial该指令用来调用实例构造器方法、私有方法以及父类方法。所以实现过程中需要排除解析出来的不满足条件的方法，具体详见源代码。 如果方法是父类的方法，且简单名不是，则解析出父类的方法作为解析方法，代码如下： 12345678910// JDK 1.0.2之后编译的类的这个标志必须为真 见《深入理解Java虚拟机》P173if (currentClass.isSuper() // 解析出来的类是父类 &amp;&amp; resolvedClass.isSuperClassOf(currentClass) // 解析的是父类的方法而且不是&lt;init&gt;构造器方法 &amp;&amp; !(resolvedMethod.getName().equals("&lt;init&gt;"))) &#123; // 通过简单名和描述符找出父类满足条件的方法 resolvedMethod = MethodLookup.lookupMethodInClass(currentClass.getSuperClass(), methodRef.getName(), methodRef.getDescriptor());&#125; 最后调用公有逻辑。 在实际的编写中本人遇到了一个bug，每个类在创建实例时会调用父类的构造器，最终也会调用java.lang.Object的，具体字节码见反编译结果： 12345678Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 1: 0 java.lang.Object的方法Code属性内操作数栈大小为0，所以操作数栈在初始化的过程中需要添加是否大于0的判断： 12345678public OperandStack_(int maxStack) &#123; if (maxStack &gt; 0) &#123; slots = new Slot_[maxStack]; for (int i = 0; i &lt; slots.length; i++) &#123; slots[i] = new Slot_(); &#125; &#125;&#125; invokevirtualJava动态分派的原理就来自于这个指令，非静态方法的局部变量表的第0位存储着方法指向的实际对象，先获取该对象： 12345// 被调用方法局部变量表第0号索引代表this，是从调用该方法的帧的操作数栈倒入的Instance_ ref = frame.getOperandStack().getRefFromTop(resolvedMethod.getArgSlotCount());if (ref == null) &#123; throw new NullPointerException();&#125; 然后解析出方法： 12resolvedMethod = MethodLookup.lookupMethodInClass(ref.getClass_(), methodRef.getName(), methodRef.getDescriptor()); 最后调用公有逻辑。 类初始化我们知道在类加载过程的连接阶段类变量只会被赋值为初始值，而且何时开始类加载《Java虚拟机规范》也没有进行强制约束，但是对于类初始化的时机，规范进行了严格规定，在下面的五种情形下如果还没有进行类初始化需要先进行类初始化： 遇到new、getstatic、putstatic、invokestatic四条指令； 对类进行反射调用； 初始化一个类之前，父类必须先初始化； 执行的主类需要先初始化； 使用JDK1.7动态语言支持时的某些场景； 类或接口最多只能调用一个初始化方法进行类或接口的初始化，该方法名为&lt;clinit&gt;，不带参数且是void的。关于&lt;clinit&gt;，甲骨文文献有这样一段话： Class and interface initialization methods are invoked implicitly by the Java Virtual Machine; they are never invoked directly from any Java Virtual Machine instruction, but are invoked only indirectly as part of the class initialization process. 这就是为什么反编译后看不到字节码指令调用该方法，因为Java虚拟机会隐式调用处理。 在51.0以上的JDK版本该方法必须设置ACC_STATIC才能被当作是初始化方法，而之前的版本没有该要求，皆表示初始化方法。之所以可以通过查询静态方法找到&lt;clinit&gt;正是因为： 123public boolean isStatic() &#123; return 0 != (accessFlags &amp; AccessFlags.ACC_STATIC);&#125; 接下来看看类初始化方法的具体实现： 1234567891011121314151617181920212223242526// 类初始化方法public static void clinitClass(Thread_ thread, Class_ class_) &#123; getClinitMethod(thread, class_); clinitSuperClass(thread, class_); class_.setClinitedFlag(true);&#125;// 获取&lt;clinit&gt;方法，一旦获取到就生成栈帧压入虚拟机栈中private static void getClinitMethod(Thread_ thread, Class_ class_) &#123; Method_ clinit = class_.getStaticMethod("&lt;clinit&gt;", "()V"); // 从当前的类查找类初始化器，如果不存在就要考虑在父类中查找了， // 后者相当于递归调用，将在clinitSuperClass方法中实现 if (clinit != null) &#123; StackFrame_ clinitFrame = new StackFrame_(thread, clinit); thread.pushStackFrame_(clinitFrame); &#125;&#125;// 在父类中递归查找和获取&lt;clinit&gt;方法private static void clinitSuperClass(Thread_ thread, Class_ class_) &#123; if (!class_.isInterface()) &#123; Class_ superClass = class_.getSuperClass(); if (superClass != null &amp;&amp; !superClass.getClinitFlag()) clinitClass(thread, superClass); &#125;&#125; 后两个方法封装在前一个方法中。getClinitMethod方法查找当前类的&lt;clinit&gt;方法，查找不到就通过clinitSuperClass方法在父类中递归查找和获取。 假设现在遇到了指令NEW，此时没有进行类初始化会去获取&lt;clinit&gt;方法进行类初始化，新栈帧压入虚拟机栈执行，类初始化代码中包含return表示不会继续完成NEW指令后续的操作，于是类初始化后需要再次执行之前的指令NEW，所以nextPC要重新设置为执行指令之前的状态： 1234// 修改frame中的nextPC(用以重置线程pc)public static void revertNextPc(StackFrame_ frame) &#123; frame.setNextPC(frame.getThread_().getPc());&#125; 当然这不是必须的，如果类初始化后继续执行指令内未完成的代码，就不需要设置计数器记录之前的指令状态。前提是在类初始化之前不要引用未初始化的变量，类初始化完后要确保初始化完成。 限于当前的虚拟机实现，在类初始化的五种情形中，可以先满足1、3、4三种情形。在相关指令中添加下面这段代码： 123456// 类初始化if (!class_.getClinitFlag()) &#123; Clinit.revertNextPc(frame); Clinit.clinitClass(frame.getThread_(), class_); return;&#125; 最后，因为所有的类都是java.lang.Object类的子类，所以所有的类在初始化之前会先进行java.lang.Object类的初始化，在该类中存在： 123static &#123; registerNatives();&#125; registerNatives方法是一个本地方法，在撰写本篇之时还未实现过本地方法，所以这里用一个钩子程序跳过它： 123if (method.isNative() &amp;&amp; method.getName().equals("registerNatives")) &#123; thread.popStackFrame_();&#125; 最后的测试就不附上了，达到了应有的效果。 小结通过本篇可以很好的了解Java方法调用的实现，帮助本人进一步巩固动态分派、静态分派和类初始化的知识。 参考2.9. Special Methods：第2.9.小节介绍了]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机之方法引用实现原理(上)]]></title>
    <url>%2F2018%2F05%2F03%2FJVM_031%2F</url>
    <content type="text"><![CDATA[本篇主要涉及四种方法调用指令：invokestatic、invokespecial、invokevirtual以及invokeinterface。invokestatic和invokespecial指令调用的方法，都可以在解析阶段确定唯一调用版本，在类加载的时候就把符号引用解析为该方法的直接引用，剩下两种需要在运行时再确定。此外，final方法是非虚方法。 解析方法的符号引用如无特别强调，下文中提到的参数个数表示参数所占Slot_实例数。 节约篇幅这里只列举解析非接口方法符号引用的例子(接口方法类似)，首先放出代码： 12345678910111213141516171819202122232425262728293031// 解析方法的符号引用public static Method_ resolveMethodRef(MethodRef methodRef) &#123; // 当前代码所处的类d Class_ d = methodRef.getRuntimeConstantPool().getClass_(); // 要解析的非接口方法所属的类或接口c Class_ c = methodRef.getClass_(); if (c == null) &#123; c = ResolvedRef.resolvedClassRef(methodRef.getClassName(), methodRef.getRuntimeConstantPool()); &#125; // 判断c是否是接口，如果是则抛出IncompatibleClassChangeError异常 if (c.isInterface()) &#123; throw new IncompatibleClassChangeError(); &#125; // 注释见lookupMethod实现 Method_ method = methodRef.lookupMethod(c, methodRef.getName(), methodRef.getDescriptor()); // 执行到这一步如果仍然没有查找到符合条件的方法，则抛出NoSuchMethodError异常 if (method == null) &#123; throw new NoSuchMethodError(); &#125; // 查找到了方法，返回了直接引用，还要在这一步进行权限验证，当前类应该能访问查找到的方法， // 否则抛出IllegalAccessError异常 if (!method.isAccessibleTo(d)) &#123; throw new IllegalAccessError(); &#125; return method;&#125; 解析的步骤： 解析方法出所属的类，判断是否是接口； 在继承中查找方法； 判断方法是否查找到； 判断当前类是否对解析的方法有访问权限； 由于Java 8之后接口可以拥有默认方法，所以在继承中查找方法未遂将继续在接口中查找。具体查找方式是通过比较简单名和描述符来实现的： 1if (method.getName().equals(name) &amp;&amp; method.getDescriptor().equals(descriptor)) 方法参数计数一个简单的例子： 1234567891011121314151617public class ClassFileDemo &#123; int a; int b; public void add01() &#123; a = a + 1; &#125; public static String add02(int x, int y, String s, ClassFileDemo a) &#123; return "hehe"; &#125; public static void main(String[] args) &#123; add02(11, 13, "nihao", new ClassFileDemo()); ClassFileDemo aa = new ClassFileDemo(); ClassFileDemo bb = aa; aa = null; System.out.println(aa == null); &#125;&#125; 将其编译后用javap反编译字节码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Compiled from "ClassFileDemo.java"public class ClassFileDemo &#123; int a; int b; public ClassFileDemo(); Code:0: aload_01: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V4: returnpublic void add01();Code:0: aload_01: aload_02: getfield #2 // Field a:I5: iconst_16: iadd7: putfield #2 // Field a:I10: returnpublic static java.lang.String add02(int, int, java.lang.String, ClassFileDemo);Code:0: ldc #3 // String hehe2: areturnpublic static void main(java.lang.String[]);Code:0: bipush 112: bipush 134: ldc #4 // String nihao6: new #5 // class ClassFileDemo9: dup10: invokespecial #6 // Method "&lt;init&gt;":()V13: invokestatic #7 // Method add02:(IILjava/lang/String;LClassFileDemo;)Ljava/lang/String;16: pop17: new #5 // class ClassFileDemo20: dup21: invokespecial #6 // Method "&lt;init&gt;":()V24: astore_125: aload_126: astore_227: aconst_null28: astore_129: getstatic #8 // Field java/lang/System.out:Ljava/io/PrintStream;32: aload_133: ifnonnull 4036: iconst_137: goto 4140: iconst_041: invokevirtual #9 // Method java/io/PrintStream.println:(Z)V44: return&#125; add02方法的描述符是(IILjava/lang/String;LClassFileDemo;)Ljava/lang/String ;，下面给出本人计算传入参数个数的思路： 用正则表达式计算出括号内的字符串； 从上一步计算出的字符串中以非贪婪的方式解析出L开头;结尾的字符串，求出此类字符串出现的次数r； 从第一步计算出的字符串中剔除第二步算出的字符串部分，计算非D和J的个数m以及D和J的个数n； 参数个数即为r + m + 2 * n(如果方法不是静态还需要在此基础上加1)； 用代码实现即： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static int countMethod(String descriptor) &#123; String paramsString = null;// test：String descriptor = "(IILjava/lang/String;LClassFileDemo;)Ljava/lang/String;"; // 贪婪式 Pattern pattern = Pattern.compile("(?&lt;=\\().*(?=\\))"); Matcher matcher = pattern.matcher(descriptor); if (matcher.find()) &#123; // 计算出传入描述符字符串括号内的子串 paramsString = matcher.group(); &#125; if (paramsString == null || paramsString.equals("")) &#123; return 0; &#125; // 非贪婪式 Pattern pattern1 = Pattern.compile("L.*?;"); Matcher matcher1 = pattern1.matcher(paramsString); // 引用类参数的个数 int refCount = 0; while (matcher1.find()) &#123; refCount++; &#125; // 非引用类型部分的参数 String nonRefPart = matcher1.replaceAll(""); int nonRefCount = 0; char[] chars = nonRefPart.toCharArray(); for (char c : chars) &#123; switch (c) &#123; case 'B': case 'C': case 'F': case 'I': case 'S': case 'Z': nonRefCount++; break; case 'D': case 'J': nonRefCount += 2; break; default: break; &#125; &#125; return refCount + nonRefCount; &#125; 操作数栈到局部变量表的映射逻辑在main方法中观察add02()被调用前后的字节码指令，可知将传入被调用方法的参数首先会被压入当前帧的操作数栈，而在Java中，一个方法如果是静态的，那么参数会从方法局部变量表的0号位置开始依次保存。所以当前帧的操作数栈中的元素和被调用方法的参数的对应关系如下： 根据对应关系给出核心代码： 123456789101112int argSlots = method.getArgSlotCount();if (argSlots &gt; 0) &#123; for (int i = argSlots - 1; i &gt;= 0; i--) &#123; // 方法参数首先是存储在调用方法的栈帧的操作数栈中 Slot_ slot = invokerFrame.getOperandStack().popSlot(); // 将弹出的参数存储在新创建的局部变量表中 newFrame.getLocalVars().setSlot(i, slot); &#125;&#125; 总结本篇讲解方法符号引用的解析，方法参数的计数和参数的映射，下篇将完成四种指令的实现。 参考正则表达式全集 正则表达式在线测试]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单词查找树]]></title>
    <url>%2F2018%2F05%2F03%2FTrie%2F</url>
    <content type="text"><![CDATA[《算法(第4版)》5.2节讲到了单词查找树(也就是字典树)，这里结合LeetCode相关题目进行分析。 LeetCode描述： Implement a trie with insert, search, and startsWith methods.You may assume that all inputs are consist of lowercase letters a-z. 这里用26个字母代替原书中ASCII扩展字符，要求实现insert、search and startsWith方法。 构造NodeTrieNode和普通Node最大区别是，添加了一个boolean字段，这个字段表示从根节点到当前节点命中一个已知字符串。 12345678class TrieNode &#123; public boolean bool; public TrieNode[] next; public TrieNode() &#123; next = new TrieNode[26]; bool = false; &#125;&#125; 构造单词查找树(insert)每一棵树都有一个大小为26的数组，将已知的字符串抽离成一个个字符，每个字符按先后顺序分别与’a’作差，每一个差值对应的就是当前树节点中数组的索引，数组索引位置指向的节点为空，就new，不为空，就以该节点出发继续遍历，遍历结束后，将当前节点的boolean值设为true： 123456789101112public void insert(String word) &#123; TrieNode p = root; for (int i = 0; i &lt; word.lengh(); i++) &#123; int index = word.charAt(i) - 'a'; if (p.next[index] == null) &#123; p.next[index] = new TrieNode(); &#125; root = p.next[index]; &#125; p.bool =true;&#125; 查找查找和构造的区别在于，构造的时候没有就new，查找的时候没有就返回null，所以代码如下： 1234567891011private TrieNode find(String s) &#123; TrieNode p = root; for (int i = 0; i &lt; s.length(); i++) &#123; int index = s.charAt(i) - 'a'; if (p.next[index] == null) &#123; return null; &#125; p = p.next[index]; &#125; return p;&#125; 搜索搜索和查找的区别在于，搜索需要判断便利结束后当前node的bool值是否为true，所以代码如下： 1234public boolean search(String s) &#123; TrieNode p = find(s); return p != null &amp;&amp; p.bool;&#125; startsWithstartsWith和搜索的区别在于，它不需要直到当前node的bool值是否为true： 1234public boolean startsWith(String s) &#123; TrieNode p = find(s); return p != null;&#125; 小结字典树用空间换取时间，搜索和构造的时间复杂度都是O(m)，m为最长字符串长度。空间成本最坏情况为RNm，R为字母表大小。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机之Class文件(续)：探索Java异常处理原理]]></title>
    <url>%2F2018%2F04%2F30%2FJVM_Class02%2F</url>
    <content type="text"><![CDATA[之前通过《Java虚拟机之Class文件》成功解析了目标Class文件，了解了类文件结构，本篇是对之前的补充，内容涉及CONSTANT_NameAndType表以及Code属性表中的异常表。 特别是本人通过分析Code属性表中的字节码指令，对Java异常处理有了更深入的理解。 关于CONSTANT_NameAndType先看一个例子： 12345678910111213141516public class ClassFileDemo &#123; int a; int b; public void add01() &#123; a = a + 1; &#125; public static void add02() &#123; &#125; public static void main(String[] args) &#123; add02(); &#125;&#125; 这个例子提供了两个字段a、b，两个方法add01()、add02()。编译这段程序，然后用javap翻译字节码，输出带NameAndType的内容如下： 12345...#19 = NameAndType #9:#10 // "&lt;init&gt;":()V#20 = NameAndType #6:#7 // a:I#21 = NameAndType #14:#10 // add02:()V... 这段输出表明，b和add01()没有对应的CONSTANT_NameAndType表，仔细观察a与b以及add01()与add02()的区别，发现最大的不同在于，字段或者方法是否被调用过，比如a在add01()中被调用，add02()在main方法中被调用。我想这样做是为了便于解析与分派。 异常表实例分析《深入》一书在第187页给出了一个演示异常表的例子，这里稍加修改，不吝笔墨的将代码贴出来： 123456789101112131415161718192021public class ExceptionTableDemo01 &#123; public static void main(String[] args) &#123; System.out.println(inc(7, 8)); &#125; public static int inc(int a, int b) &#123; int y; int x; try &#123; x = 1; return x; &#125; catch (Exception e) &#123; x = 2; return x; &#125; finally &#123; x = 3; &#125; &#125;&#125; 这段代码输出为： 1231Process finished with exit code 0 相较于书中的原例，这里给方法inc添加了形参a、b和局部变量y，再就是将方法设为static。先用javap对Class文件进行反编译，贴出inc方法的部分： 1234567891011121314151617181920212223242526272829303132public static int inc(int, int); flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=7, args_size=2 0: iconst_1 1: istore_3 2: iload_3 3: istore 4 5: iconst_3 6: istore_3 7: iload 4 9: ireturn 10: astore 4 12: iconst_2 13: istore_3 14: iload_3 15: istore 5 17: iconst_3 18: istore_3 19: iload 5 21: ireturn 22: astore 6 24: iconst_3 25: istore_3 26: aload 6 28: athrow Exception table: from to target type 0 5 10 Class java/lang/Exception 0 5 22 any 10 17 22 any 22 24 22 any 首先解释最后出现的异常表：它的逻辑是，从from到to(不包括)执行的过程中，如果发生了type类型的异常，则PC计数器指针跳转到target行。 局部变量表假定用数组localVars表示，因为是静态方法所以没有this，localVars[0]和localVars[1]分别代表传入的参数a、b，localVars[2]代表y，localVars[3]代表x，此时已经确定了四个槽位。这里啰嗦一下： iconst_1：这个命令首先将1推入操作数栈的栈顶，而不会先保存值到局部变量表； istore_3：这个命令将操作数栈栈顶的int型数值存入局部变量表索引为3的位置，此时是一个出栈的过程，操作数栈不会再保留这个数值； iload_3：这个命令将局部变量表索引为3的位置保存的int型数值复制一份到操作数栈的栈顶； 在字节码中第二行，“突然”就执行起iload_3命令，这只可能是因为程序执行到了return语句。这说明：代码中的return和字节码中的ireturn不是一一对应的，return语句会让编译器编译出多条指令。 下面通过本人所作的拙劣图进行说明： 从这张图似乎明白了finally语句“一定会执行”的原理：编译器不仅将try中的return编译成多条指令，还将finally编译的指令插在其中。具体来说就是：当执行到try块中的return语句后，会将原本load的值(不妨称之为temp)保存在局部变量表中(《深入》书中说会保存在最后一个本地变量表的slot，经本机测试并非如此，本机中保存在原位置后移的一位)，等finally指令执行完后，载入temp到栈顶，最后ireturn。 写到这里，很容易产生两个疑问： 如果finally语句中存在return，会出现什么情况？ 如果没有执行到try中的return语句就抛出了异常，会出现什么情况？ 首先来分析第一个问题 在前文代码finally括号内添加一行return x;并运行代码，结果为3，返回的是finally里的值。前面已经分析过，finally语句块被编译后得到的指令会插入在try块里return被编译后得到的指令中，可是现在的情况是，finally语句块本身就会被编译出ireturn指令，而ireturn使用汇编编写，执行jmp跳转命令。也就是说程序在执行到这一步就直接跳转了。 所以，如果finally语句中存在return，执行该return，方法返回。 再分析第二个问题 将前文代码针对问题进行修改，修改后的代码如下： 1234567891011121314151617181920212223242526public class ExceptionTableDemo01 &#123; public static void main(String[] args) &#123; System.out.println(inc(7, 8)); &#125; public static int inc(int a, int b) &#123; int y; int x; try &#123; x = 1; if (x == 1) &#123; throw new RuntimeException(); &#125; return x; &#125; catch (NullPointerException e) &#123; x = 2; return x; &#125; finally &#123; x = 3; return x; &#125; &#125;&#125; 这段代码在try里抛出一个运行时异常，然后在catch尝试捕获空指针异常，在finally里将x赋值为3并返回之。 运行代码： 1233Process finished with exit code 0 也许此时又会产生疑问：运行时异常不是catch设定的能捕获的异常，异常应该继续抛出啊，为什么结果为3呢？ 反编译Class文件，相关字节码行如下： 123456789101112131415161718192021222324252627282930313233343536373839public static int inc(int, int); flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=7, args_size=2 0: iconst_1 1: istore_3 2: iload_3 3: iconst_1 4: if_icmpne 15 7: new #5 // class java/lang/RuntimeException 10: dup 11: invokespecial #6 // Method java/lang/RuntimeException."&lt;init&gt;":()V 14: athrow 15: iload_3 16: istore 4 18: iconst_3 19: istore_3 20: iload_3 21: ireturn 22: astore 4 24: iconst_2 25: istore_3 26: iload_3 27: istore 5 29: iconst_3 30: istore_3 31: iload_3 32: ireturn 33: astore 6 35: iconst_3 36: istore_3 37: iload_3 38: ireturn Exception table: from to target type 0 18 22 Class java/lang/NullPointerException 0 18 33 any 22 29 33 any 33 35 33 any 为了进行比较，这里还需要一个finally不含return的例子： 1234567891011121314151617public class ExceptionTableDemo01 &#123; public static void main(String[] args) &#123; System.out.println(inc(7, 8)); &#125; public static int inc(int a, int b) &#123; int y; int x; try &#123; throw new RuntimeException(); &#125; finally &#123; x = 3; &#125; &#125;&#125; 运行程序输出为： 12345Exception in thread &quot;main&quot; java.lang.RuntimeException at com.demo.ExceptionTableDemo01.inc(ExceptionTableDemo01.java:17) at com.demo.ExceptionTableDemo01.main(ExceptionTableDemo01.java:7)Process finished with exit code 1 反编译： 12345678910111213141516public static int inc(int, int); flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=5, args_size=2 0: new #5 // class java/lang/RuntimeException 3: dup 4: invokespecial #6 // Method java/lang/RuntimeException."&lt;init&gt;":()V 7: athrow 8: astore 4 10: iconst_3 11: istore_3 12: aload 4 14: athrow Exception table: from to target type 0 10 8 any 要想明白执行流程必须弄懂字节码指令athrow。Oracle官网某章有这样一段描述： The objectref must be of type reference and must refer to an object that is an instance of class Throwable or of a subclass of Throwable. It is popped from the operand stack. The objectref is then thrown by searching the current method (§2.6) for the first exception handler that matches the class of objectref, as given by the algorithm in §2.10. 所以当执行到这一指令时RuntimeException对象从操作数栈顶pop出，然后会被抛给通过§2.10算法在当前方法中查找到的第一个匹配该异常的异常处理的地方；如果当前方法找不到处理该异常的地方，那么该方法的调用就会突然完成并弹出当前的栈帧，继续向调用该栈帧的栈帧抛异常，如此向上传递。 匹配该异常的异常处理的地方就需要借助前文分析过的异常表了，这里以finally有返回值的ExceptionTableDemo01程序为例，它的异常表如下： 123456Exception table: from to target type 0 18 22 Class java/lang/NullPointerException 0 18 33 any 22 29 33 any 33 35 33 any 第一个匹配的是0 18 33 any这一行，所以当虚拟机执行到athrow的时候，会跳转到target为33的地方执行，之后异常对象会astore，先行完成finally中的内容。 小结对CONSTANT_NameAndType的困惑源自本人编写玩具JVM的实践，通过本篇小文解决了困惑；对Java的异常处理，通过本次实例分析，也有了更深理解。 不同的语言，对异常的处理，体现了不同的语言特性。虽然在本文中，本人不断追溯源码以求能够彻底明白相关原理，但目前仍然处在探索之中，因为在Java里，该语言特性是通过虚拟机和编译器共同完成的。“编译器如何做到将finally编译出来的指令正确插入到return编译出的指令中的”之类的问题，还需等待后续的研究。 参考Jclasslib Bytecode Viewer：a tool that visualizes all aspects of compiled Java class files and the contained bytecode. In addition, it contains a library that enables developers to read and write Java class files and bytecode. The Java Virtual Machine Instruction Set Java Virtual MachineOnline Instruction Reference]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机之Java内存模型]]></title>
    <url>%2F2018%2F04%2F29%2FJVM04%2F</url>
    <content type="text"><![CDATA[本章很多内容参考了其它资料，但总体编排还是按照《深入理解Java虚拟机》的流程进行。 Java内存模型Java虚拟机规范试图定义一种Java内存模型屏蔽掉各硬件和操作系统的内存访问差异，使Java在各平台下都能达到一致性的内存访问效果。 JSR-133中并没有Working Memory、Main Memory的概念，所以不纠结这些名词，规范中的定义为Shared variables/Heap memory，所有的实例字段,静态字段以及数组元素都存储其中。这里variables不包括局部变量和方法参数。较《深入》书中的关系图，下图可能更方便理解(规范中用了Heap memory一词，而方法区被规范描述为堆的逻辑部分p41)： 而Bridging The Gap Between The Java Memory Model And The Hardware Memory Architecture可以用下图表示： 也就是说，作图者认为，Thread Stack和Heap都可以被内存的各部分表示。所以内存模型对内存的划分，和实际物理内存以及Java内存区域的划分是没有关系的。详见：原文链接 内存间交互操作原书有提JSR-133只用四种操作去定义Java内存模型的访问协议： lock unlock read write 具体内容不用赘述，为方便，以上被称为action。虽然描述方式改变了(以前八种现在四种)，但是Java内存模型并没有改变。所以： Thread Stack的变量改变必须同步回Heap； 不允许一个线程无故把数据同步回Heap; Thread Stack变量要初始化； 执行多少次lock，就要执行多少次unlock操作才能解锁； 变量被lock后，会清空Thread Stack变量的值，在使用变量之前，需要重新初始化； unlock前必须有lock； unlock后需要同步回Heap； 再加上volatile的特殊规定，就完全确定Java程序中哪些内存访问操作在并发下是安全的。 volatile两种特性： 保证此变量对所有线程可见； 禁止指令重排； 原书有这么一句话：“这里的‘可见性’是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知。” 这里的“立即得知”，我的理解是，立即得知改变了，而不是得知新值。其它线程获取新值仍需要对主存进行read。下面简单了解一下volatile实现原理： 在线程对volatile修饰的变量进行write的时候，比起修改不同代码，会在程序运行时多产生一行汇编代码，这行代码包含一个lock前缀的指令，这个指令会引发两件事： 将当前处理器的缓存行的数据写回共享内存； 这个回写操作会使其它CPU缓存了该内存地址的数据失效； 第二条的“失效”，对应“立即得知”。至于其它线程何时获得新值，《Java并发编程的艺术》写到：“下次访问相同内存地址时。”不过本人认为，无论是下次访问还是立即修改，都没有破坏Java内存模型。 volatile变量的运算在并发下是不安全的，从前文也可以看出，volatile的“锁”作用于汇编代码中的指令，如果说它的操作是“原子操作”，那么它的“锁”操作就是“夸克操作”。类似一个变量的++，对应的就是多条字节码指令，而一条字节码指令往往又可能转化为若干机器码指令，多线程执行会产生并发问题。 所以当破坏了下面两个原则，volatile还是要加锁： 运算结果不依赖变量的当前值，或者能确保只有单一的线程修改变量的值； 变量不需要与其它的状态变量共同参与不变约束； 指令重排的目的是为了优化性能(Out-Of-Order Execution优化)。单线程下编译器和处理器的重排会遵守数据依赖性，但是编译器和处理器并不会考虑多处理器间和多线程间的数据依赖。 名称 代码示例 说明 写后读 a = 1; b = a; 写一个变量后，再读这个位置 写后写 a = 1; a = 2; 写一个变量后，再写这个变量 读后写 a = b; b = 1; 读一个变量后，再写这个变量 上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。 那volatile是如何做到禁止指令重排的呢？它会生成一条lock前缀指令，起到了内存屏障的作用。这条指令会把修改同步到内存，那么这就意味着之前的操作都已经完成，好似一道“屏障”。 所以volatile变量操作和普通变量操作在性能上最大的区别，是在写操作上，因为会在程序执行的过程中插入很多内存屏障指令。 前面提到了Java内存模型对volatile变量的定义有特殊规定，这些规定包括： Thread Stack变量在使用前必须从内存刷新最新的值，用于保证能看到其它线程对该变量的修改； 对Thread Stack变量修改后要同步回Heap，用于保证其它线程能看到本线程对该变量的修改； 对volatile修饰的变量不能被指令重排，保证代码的执行顺序和程序的顺序相同； 原子性、可见性和有序性Java内存模型是围绕着并发过程中如何处理原子性、可见性和有序性这三个特征建立的。 这三点无需多谈，要注意的是，volatile之外，synchronized和final都可以实现可见性，synchronized可以满足三种特性，但滥用会带来性能影响。 happens-before原则 程序次序原则：在一个线程里，按程序代码顺序，书写在前面的操作先行发生于书写在后面的操作(单线程下处理器和编译器会遵守依赖性)。 程序锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作，“后面”指时间上的顺序； volatile变量原则：对volatile变量操作先发生于后面对这个变量的读操作，“后面”指时间上的顺序； 线程启动规则：start()先发生于每个操作； 线程终止规则：线程中所有操作都先行发生于对这个线程的终止检测； 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中中断事件的发生； 对象终结规则：一个对象的初始化完成先行发生于它的finalize()； 传递性：A先发生于B，B先发生于C，A就先发生于C； 这个原则，字面意思解释很清楚。 小结本章主要是罗列出一些在学习中有疑惑并需要了解的点，学习的过程也引用了其它的相关资料： JSR-133 Java Concurrency / Multithreading Tutorial by Jakob Jenkov Java并发编程的艺术]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机之类加载实战]]></title>
    <url>%2F2018%2F04%2F28%2FJVM03%2F</url>
    <content type="text"><![CDATA[本人在前篇《Java虚拟机之Class文件》中已经分析了Class文件结构，末尾小结提到了“自己动手实现远程执行功能”的实战，本篇就来进行该实战。 自定义ClassLoader自定义ClassLoader都需要继承 Classloader类，这是一个抽象类。诸如findClass()在ClassLoader中是这样一个方法： 123protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; throw new ClassNotFoundException(name);&#125; 权限修饰符为protected，还默认只在方法体中抛出个异常，看来等待着实现呢。 再看看loadClass()的源码： 12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 这个类如果重写，会破坏双亲委派机制，通常只要重写findClass()就能满足类加载方面的需求。 defineClass()具体实现很复杂(一部分涉及native底层实现，需要单独开一篇来分析)，而且用final修饰(不能重写)，在自定义ClassLoader的时候直接调用即可。调用之前需要先获得要读取的Class文件字节数据，而这个在《Java虚拟机之Class文件》关联的项目中有实现，要说明的是这里只是通过实现了解原理，所以不考虑读取jar包等压缩文件中的Class，在那个项目中Dir_Entry类的readClass()具有这样的功能。稍作修改代码如下： 12345678910111213141516171819202122232425public byte[] readClass(String absDir, String className) &#123; byte[] buf = new byte[1024]; byte[] b = null; File f; if (absDir != null) &#123; f = new File(absDir, className); if (!f.exists()) &#123; return null; &#125; &#125; else &#123; f = new File(className); &#125; try (BufferedInputStream in = new BufferedInputStream(new FileInputStream(f)); ByteArrayOutputStream out = new ByteArrayOutputStream()) &#123; int bufread = 0; while ((bufread = in.read(buf)) != -1) &#123; out.write(buf, 0, bufread); &#125; b = out.toByteArray(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return b; &#125; 这里用到的defineClass四参数方法： 12protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) throws ClassFormatError &#123;&#125; 只重写findClass()方法仍然保证了基本的双亲委派机制，这里放上完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package classloaderdemo;import java.io.BufferedInputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;public class MyClassLoader extends ClassLoader &#123; String absDir; MyClassLoader() &#123; super(MyClassLoader.class.getClassLoader()); &#125; MyClassLoader(String absDir) &#123; this.absDir = absDir; &#125; public Class loadByte(byte[] classByte) &#123; return defineClass(null, classByte, 0, classByte.length); &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] data = readClass(absDir, name); return defineClass(name, data, 0, data.length); &#125; public byte[] readClass(String absDir, String className) &#123; byte[] buf = new byte[1024]; byte[] b = null; File f; if (absDir != null) &#123; f = new File(absDir, className); if (!f.exists()) &#123; return null; &#125; &#125; else &#123; f = new File(className); &#125; try (BufferedInputStream in = new BufferedInputStream(new FileInputStream(f)); ByteArrayOutputStream out = new ByteArrayOutputStream()) &#123; int bufread = 0; while ((bufread = in.read(buf)) != -1) &#123; out.write(buf, 0, bufread); &#125; b = out.toByteArray(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return b; &#125;&#125; 因为没有重写loadClass()，如果显示调用loadClass()，仍然能触发双亲委派机制；如果直接用loadByte()载入字节数据，则应该在构造函数中添加super(MyClassLoader.class.getClassLoader())。 ClassModifierClassModifier负责更改Class文件字节数据。有了上一篇文章的基础，这里实现起来容易很多。首先通过遍历找到Class常量池中出现的CONSTANT_Utf8常量类型，判断这个常量类型转化成的字符串是否与给定的需要被替换的字符串相等，相等就将表示这段CONSTANT_Utf8的字节码转换为要替换成的字符串相应的字节码，不相等就遍历到下一个，直到跳出循环。 这里我沿用了上一篇项目中的类ClassReader，它的特点在于每次读取字节数据的时候，内部的游标变量cursor自动更新(为了方便调用此字段设为public)。一开始读取数据需要跳过表示咖啡北鼻和版本号的8个字节。所以先直接执行cr.readUint64();，cr是ClassReader实例。接下来的流程大致如下： 读取字节，获取常量池中的常量个数cpc； 遍历常量池常量，每次遍历并通过ClassReader计算出tag，通过tag获知是什么常量类型，判断是否为CONSTANT_Utf8_info，如果不是，跳过当前判断； 如果是，计算出CONSTANT_Utf8_info字符，判断该字符串是否等于要更改的字符串部分； 等于，则进行目标替换，创建一个新的数组表示替换成功的数组并返回；反之跳过当前判断； 字符串替换的源码如下： 12345678public byte[] bytesReplace(byte[] bytes01, int offset, int len, byte[]bytes02) &#123; byte[] newBytes = new byte[bytes01.length + bytes02.length - len]; System.arraycopy(bytes01, 0, newBytes, 0, offset); System.arraycopy(bytes02, 0, newBytes, offset, bytes02.length); System.arraycopy(bytes01, offset + len, newBytes, offset + bytes02.length, bytes01.length - offset - len); return newBytes; &#125; 当然，本实战还包括一个被替换类、一个替换类以及一个执行类，实现起来并不复杂就不敷述了，最核心的部分已经在上文进行了分析，详细代码请见GitHub。 小结本实战的难点在于对类加载器的理解，以及一些字符串数组边界的处理。在处理Class文件时，直接将byte[]转换成String亦没有出错，并没有在中间转换一道MUTF-8。 参考文献 《深入理解Java虚拟机》 Difference between loadClass(String name) and loadClass(String name, boolean resolve) How to convert Java String into byte[]? Java中String和byte[]间的转换浅析]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机之Class文件]]></title>
    <url>%2F2018%2F04%2F27%2FJVM02%2F</url>
    <content type="text"><![CDATA[这一篇主要解析Class文件结构，并通过Java编程实现相关细节对解析的结构进行验证。 字节码分析用例首先准备一段用例代码： 12345678910111213public class ClassFileTest &#123; public static final boolean FLAG = true; public static final byte BYTE = 123; public static final char X = 'x'; public static final short SHORT = 12345; public static final int INT = 123456789; public static final long LONG = 12345678901L; public static final float PI = 3.14f; public static final double E = 2.71828; public static void main(String[] args) throws RuntimeException &#123; System.out.println("Hello, World!"); &#125;&#125; 使用javap工具的-verbose参数输出的ClassFileTest.class文件字节码内容如下多图： 图1 图2 图3 图4 以上就是javap“翻译”的Class文件字节码内容。 创建字节读取工具ClassReader首先编写ClassReader类。翻开《深入理解Java虚拟机》这本书的165页可知，class文件格式基本上是无符号数和表组成，而表自身又是由多个无符号数或者其它表作为数据项构成。一个字节、二个字节、四个字节和八个字节的无符号数用u1、u2、u4、u8表示，ClassReader就是提供对应的方法来读取这样大小的字节。 接下来用ClassReader类一一读取这些数据项，首先是u1: 1234public int readUint8() &#123; int val = data[cursor++] &amp; 0xff; return val; &#125; 接着是u2： 12345678public int readUint16() &#123; int val = 0; for (int i = 1 + cursor; i &gt;= cursor; i--) &#123; val |= (data[i] &amp; 0xff) &lt;&lt; ((1 + cursor - i) * 8); &#125; cursor = cursor + 2; return val; &#125; 这段代码中，通过位运算，将byte[]高索引的元素放在读取内容的低位，将低索引的元素放在读取内容的高位，然后再通过或运算，整合出新的内容并返回，通过这种方法解决BigEndian问题。 u4、u8同理，但考虑到Java没有无符号基本类型，试想byte[]数组中第一个元素二进制表示为11111111，这样在求u4的过程中，三十二位的首位是1，如果返回为int类型的话，Java会认为是负数。所以u4用long表示，代码如下： 12345678public long readUint32() &#123; long val = 0; for (int i = 3 + cursor; i &gt;= cursor; i--) &#123; val |= (data[i] &amp; 0xff) &lt;&lt; ((3 + cursor - i) * 8); &#125; cursor = cursor + 4; return val;&#125; u8就用BigInteger表示： 12345678public BigInteger readUint64() &#123; byte[] bytes = new byte[8]; for (int i = 0; i &lt; 8; i++) &#123; bytes[i] = data[cursor + i]; &#125; cursor = cursor + 8; return new BigInteger(bytes);&#125; 这段代码还包括读取uint16表和用于读取指定数量的字节的功能的函数，比较简单就不罗列了。详细代码(包括本篇后续所述功能的完整源代码)见GitHub。 ClassFile每一个Class文件对应于一个如下所示的ClassFile结构体(图片引用自《Java虚拟机规范》)： 图5 接下来需要构建一个ClassFile类的读取方法read(): 1234567891011121314public void read(ClassReader reader) &#123; MemberInfo mb = new MemberInfo(); readAndCheckMagic(reader); readAndCheckVersion(reader); constantPool = new ConstantPool(); constantPool.readConstantPool(reader); accessFlags = reader.readUint16(); thisClass = reader.readUint16(); superClass = reader.readUint16(); interfaces = reader.readUint16s(); fields = mb.readMembers(reader, constantPool); methods = mb.readMembers(reader, constantPool); attributes = GreateAttributeInfo.readAttributes(reader, constantPool); &#125; 该方法通过对编译后的字节码文件进行读取，每个无符号数或表获取到相应字节数的数据。例如readAndCheckMagic(reader)方法： 123456public void readAndCheckMagic(ClassReader reader) &#123; long magic = reader.readUint32(); if (magic != 0xCAFEBABE) &#123; throw new RuntimeException("java.lang.ClassFormatError: magic!"); &#125; &#125; 这个方法读取4个字节的数据，然后判断该数据表示的long数是否==十六进制表示的“CAFEBABE”，需要了解的是，此时ClassReader中的游标cursor向前进4，下一个数据的读取从新的cursor开始读取。 constantPool这里重点需要了解的是constantPool常量池，常量池的项目类型见下图： 图6 这里有14种常量类型，它们各自均有自己的结构。接下来再放上编译后的字节码文件解析出的字节码数据，后续将根据这个数据分析一二： 图7 从第十一个字节0A(十六进制)开始，就进入到读取常量池第一个表的部分了，虽然“常量池是最繁琐的数据”(《深入》书中语)，但是所有常量池的表头项目都是“tag”，大小为u1(也就是一个字节)，所以在实现和理解上并不复杂，比如上图中的0A，表示10，在图6中，10表示CONSTANT_Methodref，再去图1中查证，果然#1指向的是CONSTANT_Methodref。CONSTANT_Methodref的结构是确定的，除了一个tag，还包括两个index，index指向的就是常量池中的常量，当然这个表自己本身也是常量池中的一部分。这里对两个index进行解读： 第一个index指向声明方法的类描述符CONSTANT_Class_info的索引：0006(见图7，十六进制，两个字节)，在图1中查看表示java/lang/Object(实际上常量#6也需要指向#51才能拿到真正的字符串)； 第二个index指向名称及类型描述符CONSTANT_NameAndType的索引：002C(十六进制，表示十进制的44)，然后可以在图2中找到#44对应的常量。 按照如此这般的规则，整个常量池就可以解析出来，再回过头来看第9和第10个字节组成的数据：003B，换算成十进制表示59，从图1到3可以看出常量实际只有58个，这是因为常量池的容量计数值是从1而不是0开始的，这里的范围在1～58，0表示不引用任何常量池项目。 ConstantPool构造代码如下： 1234567891011public void readConstantPool(ClassReader reader) &#123; int cpCount = reader.readUint16(); cp = new ConstantInfo[cpCount]; for (int i = 1; i &lt; cpCount; i++) &#123; cp[i] = CreateConstantInfo.readConstantInfo(reader, this); if (cp[i] instanceof ConstantLongInfo || cp[i] instanceof ConstantDoubleInfo) &#123; i++; &#125; &#125; &#125; 通过前面的分析不难理解cpCount是常量池的容量计数(实际范围在1~cpCount-1)，观察图2，代表long和double的常量#25和#32分别占用了两个索引，所以在readConstantPool中添加上相应的代码。 readConstantPool是ConstantPool类中最重要的方法，在该类下还包括一个索引方法和若干起到了返回字符串值作用的工具方法，这里就不赘述了，由于常量池中的表具有类似的结构，所以抽象出一个统一接口ConstantInfo，常量池中涉及到的14种表都实现了该接口，内容比较简单，然后再通过构造一个静态方法读取tag，进而获取并返回相应的表，解析常量池这部分的工作就完成了。 MemberInfo常量池解析完后，就是访问标志、类索引、父类索引与接口索引集合的部分了，但这部分要么是读取十六进制的值，要么是索引常量池中的部分，实现起来没什么复杂度索性就不搬运代码了。本条目主要解析字段表集合和方法表集合，这两部分的结构非常相似，具体结构如下： 图8 图9 所以在这里统一用memberInfo类来表示，先来看下面这几行代码： 123456789public static MemberInfo readMember(ClassReader reader, ConstantPool cp) &#123; MemberInfo mb = new MemberInfo(); mb.cp = cp; mb.accessFlags = reader.readUint16(); mb.nameIndex = reader.readUint16(); mb.descriptorIndex = reader.readUint16(); mb.attributes = GreateAttributeInfo.readAttributes(reader, cp); return mb; &#125; 要构造表的集合，先构造表，此段代码通过静态方法readMember()来初始化单个表对象。 接下来的代码通过读取表集合前的fields_count/methods_count构造出这个数值大小的数组，将依次读取到的表“装”进该数组并返回，相关代码如下： 12345678public MemberInfo[] readMembers(ClassReader reader, ConstantPool cp) &#123; int memberCount = reader.readUint16(); MemberInfo[] members = new MemberInfo[memberCount]; for (int i = 0; i &lt; memberCount; i++) &#123; members[i] = readMember(reader, cp); &#125; return members; &#125; AttributeInfo最后就是属性表集合，在本篇提供的完整代码中，本人并没有实现全部预定义属性表，在《Java虚拟机规范(Java SE 7)版中预定义属性为21项。其中Code属性是Class文件中最重要的一个属性，在这里就单讲一下这个属性，首先看一下规范中定义的Code结构： 图10 属性表和前述的表不一样，它不使用tag，而是在索引常量池中的常量后，用这个常量来对彼此进行标识。这个索引也就是图中的attibute_name_index，类型为u2；接下来是attribute_length，指示了属性值的长度；max_stack是操作数栈深度的最大值；max_locals代表局部变量所需要的存储空间，单位时slot；code_length表示字节码指令长度；code表示code_length长度的字节码指令；字节码指令后的是显式异常处理表；最后的部分还是一个属性表集合，程序在这里可以递归的进行。 有了前面的基础，异常处理表之前的代码很容易写，这里要注意，code_length是一个u4类型的长度值，理论上最大可以达到二进制的32位，但是虚拟机规范中明确限制了一个方法不允许超过65535条字节码指令，所以实际使用了u2长度。所以本人用下面这条代码编写： 1int codeLength = (int)(reader.readUint32()); 这里主要说说异常处理表： 编写这个表的时候，需要读取数据后初始化四个字段startPc endPc handlerPc catchType；它们都是u2型，这些字段的含义是：当start_pc到end_pc之间（不包括后者）如果出现了catch_type或者其子类的异常，则转到handler_pc行继续处理，当catch_type的值为0时，代表任意异常情况都需要转向handler_pc处理。 表的内容很清晰了，就要构造表的集合，和前面的例子是类似的，代码如下： 12345678static ExceptionTableEntry[] readExceptionTable(ClassReader reader) &#123; int exceptionTableLength = reader.readUint16(); ExceptionTableEntry[] exceptionTable = new ExceptionTableEntry[exceptionTableLength]; for (int i = 0; i &lt; exceptionTableLength; i++) &#123; exceptionTable[i] = new ExceptionTableEntry(reader); &#125; return exceptionTable; &#125; 先读取出表集合的大小，然后依次读取“装”进数组。 验证在Main方法中添加如下代码： 123456789System.out.println((cf.getFields()).length); System.out.println(cf.getMajorVersion()); System.out.println(cf.getAccessFlags()); System.out.println(cf.getClassName()); System.out.println(cf.getSuperClassName()); System.out.println(cf.getInterfaceNames().length); for (MemberInfo m: cf.getFields()) &#123; System.out.println(m.getName()); &#125; cf时ClassFile的实例(具体细节见github)，运行代码结果如下： 图11 小结《深入理解Java虚拟机》的相关章节曾写到：“Class类文件结构这部分是了解虚拟机的重要基础之一，要深入了解虚拟机，这部分是不能不接触的。”而该书后面章节中介绍的“自己动手实现远程执行功能”的实战，正是利用Java类加载机制的技术并修改替换Class文件字节码来实现的。 参考文献 《自己动手写Java虚拟机》 《深入理解Java虚拟机》 《Java虚拟机规范(Java SE 7版)》]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Union-Find算法]]></title>
    <url>%2F2018%2F04%2F23%2FUnion_Find%2F</url>
    <content type="text"><![CDATA[并查集是一种数据结构，而union-find算法定义了用于此数据结构的操作。这是维基给的简单定义，而这篇笔记主要是针对《算法》这本书上出现的相关问题，暂且不深入展开这个定义。 准备工作在《算法》这本书中，列举出union-find算法的API有以下这些：1UF(int N) 这是一个初始化类的构造器。 1void union(int p, int q) 表示对输入的两个点进行连接。 1int find(int p) 表示该点所在分量的标识符（分量名）。 1boolean connected(int p, int q) 判断两个点是否连接。 1int count() 分量的个数。 算法的优劣，主要决定于find()和union()这两个函数，所以下面给出书中暂时没有实现find()和union()的UF类的代码：123456789101112131415161718192021222324252627282930313233343536public class UF &#123; private int[] id; private int count; public UF(int N) &#123; count = N; id = new int[N]; for (int i = 0; i &lt; N; i++) &#123; id[i] = i; &#125; &#125; public int count() &#123; return count; &#125; public boolean connected(int p, int q) &#123; return find(p) == find(q); &#125; public int find(int p) &#123; // 未实现 &#125; public void union(int p, int q) &#123; //未实现 &#125; public static void main(String args[]) &#123; int N = StdIn.readInt(); UF uf = new UF(N); while (!StdIn.isEmpty()) &#123; int p = StdIn.readInt(); int q = StdIn.readInt(); if (uf.connected(p, q)) continue; uf.union(p, q); StdOut.println(p + " " + q); &#125; StdOut.println(uf.count() + "components"); &#125;&#125; 注：代码用到了本书作者自己编写的函数库，比如StdIn.readInt()基本上就是封装了scanner.nextInt()等，为了方便和兼容，这里就使用原书的代码。 UF的构造很容易理解，最初将所有点当作单个的联通分量，然后每个联通分量有一个自己的分量名id，通过find()可以找到当前输入点所属的分量名，而union()就是不断通过所给输入条件合并已知分量。 quick-find由于算法的优劣，主要决定于find()和union()这两个函数，首先考虑对find()进行优化。 find()操作速度很快的一种情况是，通过给出的点(假设为p)，立马就可以得到p所属的分量名，以下代码就可以满足： 123public int find(int p) &#123; return id[p];&#125; 数组id[]直接存储各个点所属的分量名，每次调用find()只访问一次数组。 注：访问一次数组指的是通过数组名[索引](这里指的是id[p])进行的一次操作，认识这一点方便后面的算法分析。 由于每个点p调用id[p]就能得到它所在的分量名，那么当输入两个点p, q，如果find(p)和find(q)相等，就说明它们在同一个分量，不需要采取动作；当不等的时候，就把和其中一个点拥有相同分量名的所有点的id改为另一个点的分量名。实现如下： 1234567891011121314public void union(int p, int q) &#123; int pID = find(p); int qID = find(q); if (pID == qID) return; for (int i = 0; i &lt; id.length, i++) &#123; if (id[i] == pID) &#123; id[i] = qID; &#125; &#125; count--;&#125; 书中说union()访问数组的次数在N+3到2N＋1之间。只要理解了成本模型，就能得出这个结果。 在本算法中，成本模型是数组的访问次数，而每进行一次id[p]的操作就会访问一次数组。所以int pID = find(p)和int qID = find(q)进行了两次数组访问，if (pID == qID) return;没有进行数组访问，接下来的for循环中if (id[i] == pID)进行了N次判断，每一次都会进行一次id[]操作，id[i] = qID;的执行分最好最坏两种情形，最好的情形是，p是孤立的一个分量，于是只需要访问一次id[i]就可以了(2+N+1=N+3)；最坏的情形是，p所在的分量有N-1个点，这时候要访问并修改N-1个id[]的元素的值(2+N+N-1=2N+1)。 注：虽然循环中经过编译的代码对id[p]的第二次引用一般不会访问数组，但是在这个算法中第二次是会修改元素值的，所以是会访问数组的。 由于调用union()的次数是线性级别的(0到N-1)，所以quick-find算法的时间复杂度是平方级别的。 quick-union如果说quick-find算法是把“查找”的过程放在了union()(这里指代其中的for语句)，那么quick-union算法就是把“查找”丢给了find()函数。 要理解quick-union算法，首先要知道它约定的“游戏规则”，这个“游戏规则”适合用类似迭代的方法说明： 首先，假设有两个点p和q，它们分别是独立的分量，分量名分别是id[p]和id[q]，如果要求构造p和q的连接，则有两种情况，一种是将id[p]更改为q的分量名id[q]，这个过程好似q成为了p的父节点；另一种是将id[q]更改为q的分量名id[p]，这个过程好似p成为了q的父节点。 现在新增加一个点m，此点如果构造为与刚刚p，q组成的分量相连，则构造方法有两种，一种是将id[m]设为p，q分量的根节点，此时好似把m点的父节点设为p，q分量的根节点；一种是将id[p，q分量的根节点]设为id[m]，好似把p，q分量根节点的父节点设为m，如图所示(这里假定q是p，q分量的根节点)： 经过多次迭代，现假设有两个分量A，B，每个分量都包含多个节点，如果要求构造两个分量相连，则构造方法同样有两种，一种是将A分量根节点的父节点设置为B的根节点，另一种则相反。 find()代码就是寻找每个分量根节点的函数： 123456private int find(int p) &#123; while (p != id[p]) &#123; p = id[p]; &#125; return p;&#125; 而“游戏规则”可以通过union()来描述： 1234567891011public void union(int p, int q) &#123; int pRoot = find(p); int qRoot = find(q); if (pRoot == qRoot) &#123; return; &#125; id[pRoot] = qRoot; count--;&#125; 由前述的“游戏规则”可知，代码id[pRoot] = qRoot;是根据输入点的顺序而采用的构造相连方法的两种中的一种，所以整个构造过程有可能出现最坏的情况，例如每次构造单点分量与多点分量相连，单点分量都设置成多点分量根节点的父节点。find()可能进行2N+1次数组访问(树中节点深度的两倍加1)。 注：find()函数中while部分经过编译的代码对id[p]的第二次引用一般不会访问数组。 加权quick-union &amp; 路径压缩加权quick-union前面已经提到了，代码id[pRoot] = qRoot;是根据输入点的顺序而采用的构造相连方法的两种中的一种，加权quick-union就是来规避这种随输入的选取造成的整个算法出现最坏情况的问题。 在前述“游戏规则”中，A，B两个多点分量的连接过程中，只要保证其中较小的树连接到较大的树，最坏情况就不会出现，具体的实现方法是增加一个数组专门用来记录一个分量的大小： 1234int[] sz = new int[N]; for (int i = 0; i &lt; N; i++) &#123; sz[i] = 1; &#125; 首先初始化一个数组，每个元素设为1。 将union()作相应更改： 123456789101112131415161718public void union(int p, int q) &#123; int i = find(p); int j = find(q); if (i == j) return; if (sz[i] &gt; sz[j]) &#123; id[j] = id[i]; sz[i] += sz[j]; &#125; else &#123; id[i] = id[j]; sz[j] += sz[i]; &#125; count--;&#125; 路径压缩则是对加权quick-union算法的再优化，在quick-find算法中，find之所以快是因为，每个节点的分量名只要访问一次数组id[]就可以得到，如果多点分量中每个节点都直接链接到同一个父节点，就可以将算法无限接近与quick-find的效果。 改进find()： 1234567891011121314151617private int find(int p) &#123; int r, n, t; r = p; n = p; while (r != id[r]) &#123; r = id[r]; &#125; while (n != r) &#123; t = id[n]; id[n] = r; n = t; &#125; return r;&#125; 添加的部分是将p节点路径上节点的父节点全部设置为分量的根节点。 注：知乎上有一个递归的解法： 123int find(int x)&#123; return x==id[x]?x:id[x]=find(id[x]);&#125; 总结本笔记按照书中的流程复习了union-find算法，并增加了如下几个工作： 分析了为什么书中quick-find算法的union()函数访问数组的次数在N+3到2N+1之间； 用自己的语言描述了quick-union算法的构造过程； 添加了书中没有实现的路径压缩加权quick-union算法；]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>union-find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用确定有限状态自动机解KMP算法]]></title>
    <url>%2F2018%2F04%2F22%2FKMP%2F</url>
    <content type="text"><![CDATA[这里介绍的方法来自于《算法(第4版)》一书，通过构造一个确定有限状态自动机来解决KMP算法。 预热KMP算法解决这样一个问题：已知一个文本字符串和一个模式字符串，在前者中查找并返回后者第一次出现的位置。先看用暴力方法如何求解，代码如下： 12345678910111213141516public static int search(String pat, String txt) &#123; int j, M = pat.length(); int i, N = txt.length(); for (i = 0, j = 0; i &lt; N &amp;&amp; j &lt; M; i++) &#123; if (txt.charAt(i) == pat.charAt(j)) j++; else &#123; i -= j; j = 0; &#125; &#125; if (j == M) return i - M; else return N;&#125; 在暴力算法中，每次字符串上对应的单个字符匹配失败，i会回退到i-j+1的位置与j=0再次尝试新的匹配，在for循环执行完后，如果j等于模式字符串的长度M，则表示匹配成功，返回第一次出现的位置i-M，否则表示匹配失败，返回文本字符串的长度N来表示。 KMP算法“KMP算法的主要思想是提前判断如何重新开始查找，而这种判断只取决于模式字符串本身。” ——摘自《算法》中文版496页 如果说这本书中介绍的关于实现KMP算法的方法和其它文章中构建next数组的方法有什么不同的话，我认为是前者不仅不回退，而且一直在”前行”，而后者的i不回退但是会“停留”。 不过这篇文章只单独针对《算法》书中的方法进行分析。 示例说明为了方便理解，现假设有一个文本字符串txt（此字符串转化成的字符数组为t）：ACBACBACAB和一个模式字符串pat（此字符串转化成的字符数组为p）：ACBACAB，当i=0，j=0时文本第一个字符和模式第一个字符相等，各自+1进行下一次比较…一直到当i＝5、j＝5时，对应的字符分别是文本的第六个字符B和模式的第六个字符A，此时B不等于A所以不匹配(下图中浅红色部分)： 要使i继续“前行”变更为i+1（也就是i＝6，指向第七个字符）的同时，还能保证算法的正确，那么找到与i＋1进行匹配的j的值就是本算法的关键。假设此时j＝k，k就是这样一个数： 满足p[0]，p[1]，…，p[k-1]组成的字符串与t[i-k+1]，t[i-k+2]，…，t[i]所组成的字符串相等； 为了减少后续比较次数以保证算法花费的时间尽可能少，在满足(1)的条件下k要尽可能大； 不难发现，p[0]，p[1]，…，p[j-1]所组成的字符串和t[i-j]，t[i-j+1]，…，t[i-1]所组成的字符串是相等的，即模式字符串的ACBAC和文本字符串的ACBAC相等(下图中紫色部分)： 那么求k不就是求p[0]，p[1]，…，p[j-1]加上t[i]所组成字符串的前缀字符串和后缀字符串的最长共有元素的长度吗？ 要说明的是，一个字符串的前缀字符串指的是除了最后一个字符外，该字符串的全部头部组合；一个字符串的后缀字符串指的是除了第一个字符外，该字符串的全部尾部组合。例如ACBACB的前缀字符串包括：A、AC、ACB、ACBA、ACBAC，后缀字符串包括：B、CB、ACB、BACB、CBACB。 p[0]，p[1]，…，p[j-1](即紫色部分ACBAC)和t[i](即字符B)组成的字符串为下图中蓝色部分表示： 上图中蓝色部分ACBACB的前缀字符串和后缀字符串最长共有元素为ACB(下图中绿色部分分别为前缀字符串和后缀字符串ACB)，长度为3： 这个3也就是k的值，那么接下来t[i+1]就只需要从p[k](k等于3)开始进行比较(虚线部分)，而p[2]与t[i]、p[1]与t[i-1]、p[0]与t[i-2]就不用再去一一比较了(下图中绿色的部分)，因为他们肯定是相等的： 如此一来，i就做到了不用回退还能一直“前行”，达到了优化之前暴力算法的目的。 DFA由前文的分析可得，i一直前进，且每进一位，只需要知道位于文本字符串上该位置的字符与模式字符串上的哪个位置的字符进行匹配。 不妨把j停留在的位置理解成一种状态，模式字符串一共有0，1，2，3，…，M-1这M个状态，那么用KMP算法成功查找到模式字符串第一次出现的位置的过程，其实也是一种j从0不断跳转，直到跳转到M-1状态并满足t[i] == p[j]的过程。 接下来需要构造一个int类型的二维数组dfa，用来模拟一个确定有限状态自动机： 第一维：对应需要比较的文本字符串的字符(在实际的Java代码中传入的字符类型自动向上转化为int类型)； 第二维：表示要比较的模式字符串所处的状态； dfa元素的值：表示比较后应该跳转到的状态； dfa一旦构造成功，就可以通过它找到文本字符串每个位置应该和模式字符串的什么位置比较，从而对之前的暴力解法for循环内的部分进行优化，这，就是《算法》一书介绍的KMP算法思想，暴力算法改进如下： 12345678910public static int search(String pat, String txt) &#123; int j, M = pat.length(); int i, N = txt.length(); for (i = 0, j = 0; i &lt; N &amp;&amp; j &lt; M; i++) j = dfa[txt.charAt(i)][j]; if (j == M) return i - M; else return N;&#125; 字符匹配那么dfa如何构造？ 考虑到跳转分两种情形，一种是当前i和j指向的字符匹配不成功，一种则是匹配成功，所以分别对这两种情形进行分析。 匹配不成功在匹配之前，由于p[0]，p[1]，…，p[j-1]组成的字符串和t[i-j]，t[i-j+1]，…，t[i-1]组成的字符串相等，设此时这个相等字符串的前缀字符串和后缀字符串的最长共有元素的长度为k，当匹配不成功时，t[i]不等于p[j]，dfa[t[i]][j]的值表示i+1后，t[i+1]从什么地方开始匹配，它应该等于dfa[t[i]][k]。 为什么dfa[t[i]][j]应该等于dfa[t[i]][k]？ 这个问题可以转化为：已知一个字符串S，它的前缀字符串和后缀字符串的最长共有元素的长度为k，现将一个字符拼接在S的尾部组成新的字符串S’，求S’的前缀字符串和后缀字符串的最长共有元素的长度k’。 首先能够确定的是，k’的大小不会超过k+1，也就是说k’只可能&lt;= k+1。分两种情况讨论： 当拼接的字符等于S[k]时，k’的大小为k+1； 当拼接的字符不等于S[k]时，k’等于S[0]、S[1]、S[2]、…、S[k-1]与该字符组成的字符串的前缀字符串和后缀字符串的最长共有元素的长度； 实际上这正是dfa[t[i]][k]的含义，当跳过这一小段文字，读至本文末尾就会发现，以上便是字符匹配的成功和不成功的两种情形，也就是说，本方法不停通过迭代进行构造。 所以匹配不成功的代码如下： 123for (int c = 0; c &lt; R; c++) &#123; dfa[c][j] = dfa[c][k];&#125; c是扩展ASCII中的字符，范围在0 ～ 255。 匹配成功如果t[i]等于p[j]，说明匹配成功，j应该跳转到j+1，表示t[i+1]将与p[j+1]进行比较。所以dfa需要满足dfa[p[j]][j] = j+1的条件，代码如下： 1dfa[p[j]][j] = j + 1; 更新k无论匹配成功与否，每经过一轮匹配，k值都应该更新： 1k = dfa[p[j]][k]; 完整代码设定初始值后，通过以上两种情形的处理，k可以不断迭代更新，最终构建出dfa，代码编写如下： 12345678dfa[pat.charAt(0)][0] = 1;for (int k = 0, j = 1; j &lt; pat.length(); j++) &#123; for (int c = 0; c &lt; 256; c++) &#123; dfa[c][j] = dfa[c][k]; dfa[pat.charAt(j)][j] = j + 1; k = dfa[pat.charAt(j)][k]; &#125;&#125; 关于初始值的说明：pat.charAt(0)是模式字符串的第一个字符，它与模式字符串所处的第0号状态的字符当然相等，所以dfa[pat.charAt(0)][0]的结果是跳转到状态1。 实际编写代码的时候需要注意：每次循环中匹配成功的代码不能在匹配失败的代码之前，不然会被覆盖。 小结本篇主要分析了《算法(第4版)》一书介绍的方法。再回味一下书中给出的那句话：“KMP算法的主要思想是提前判断如何重新开始查找，而这种判断只取决于模式字符串本身。”这句话揭示KMP算法的本质。 参考《算法(第4版)》]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>KMP</tag>
        <tag>自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TreeMap源码摘要]]></title>
    <url>%2F2018%2F04%2F21%2FTreeMap%2F</url>
    <content type="text"><![CDATA[本篇主要分析TreeMap源码。 TreeMap是用红黑树实现的，不妨按照之前《红黑树》的那一篇笔记的流程来分析，这里采用的是JDK1.8.0_91对应的源码。 初始化注释写到：“Node in the Tree. Doubles as a means to pass key-value pairs back to user (see Map.Entry).”之前某篇我提到过JDK8在部分源码中已经使用Node替代Entry，这里仍然使用的是Entry： 1234567891011121314151617static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; V value; Entry&lt;K,V&gt; left; Entry&lt;K,V&gt; right; Entry&lt;K,V&gt; parent; boolean color = BLACK; /** * Make a new cell with given key, value, and parent, and with * &#123;@code null&#125; child links, and BLACK color. */ Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125; 和以往不同的是，这里增加了parent字段，Entry是静态类。 Put先看看源码中put()是怎么实现的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; if (t == null) &#123; compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; else &#123; if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null;&#125; 这段代码一开始采用了compare(key, key)的比较，其实不难理解：如果root为null的话，构造root的时候(也就是new一个新的Entry)天然缺少类型检查，比如你可以不强迫新的Entry键值为类型K和V，而当root存在的时候，put()的元素都是会和父节点比较的，这样就隐式进行过类型(包括null)检查了。这里compare()是内部实现的一个final方法： 12345@SuppressWarnings("unchecked")final int compare(Object k1, Object k2) &#123; return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2);&#125; comparator不为null就用Comparator比较，为null就用Comparable比较。Comparator和Comparable的区别我在某篇中提到过，前者是外部比较器，后者可以视为内部比较器，通过重写外部比较器，可以方便更改比较规则。 modCount++的意涵在之前某源码摘要中也提到过，这里和那篇中的用法一样。fixAfterInsertion(e)用来插入后再平衡，基本原理见之前涉及红黑树的那篇。 应用TreeMap的构造函数如下： 1234567public TreeMap() &#123; comparator = null;&#125;public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator;&#125; 可见，默认采用Comparable，Comparator实例可以作为实参更改排序规则。 Collections的一个静态方法reverseComparator()返回逆序比较器： 1234@SuppressWarnings("unchecked")public static &lt;T&gt; Comparator&lt;T&gt; reverseOrder() &#123; return (Comparator&lt;T&gt;) ReverseComparator.REVERSE_ORDER;&#125; 所以通过给构造器传入该方法，遍历的时候可以得到逆序结果。 再者，TreeMap的排序默认是高位优先(具体可见《算法(第4版)》)的。所以排序的内容如果有自己特定的逻辑规则，也应该自行实现Comparator。 小结较之HashMap，TreeMap很稳，不然在Java8的HashMap源码中，就不会将某些特定情况转换成TreeMap来实现，基本操作的时间复杂度和红黑树一样。]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2018%2F04%2F20%2FRedBlackTree%2F</url>
    <content type="text"><![CDATA[二叉树分完美(Perfect)完全(Complete)完满(Full)，本篇涉及到二叉树的完美平衡。 Brief理想情况下，我们希望能够保持二分查找树的平衡，但是在动态插入的过程中保证完美平衡代价太高。 为了保证查找树的平衡，现放宽灵活性，允许树中的一个节点保存多个键，由此产生出2-3查找树。但用直白的方法实现大多数操作并不方便，需要的代码和额外开销都是大量的。 本篇涉及的红黑树就是一种用来表达和实现2-3树的数据结构。 红黑树即是二叉查找树，又是2-3树，在满足基本的条件下，给出一种简洁的定义： 红链接均为左链接； 没有任何一个节点同时和两条红链接相连； 该树完美黑色平衡； 关于红黑树最核心特点的一个不严格表述：“将红链接画平，一棵红黑树就是一棵2-3树。” 初始化结合代码步步分析。初始化代码如下： 1234567891011121314151617181920212223242526private static final boolean RED = true;private static final boolean BLACK = false;private class Node &#123; Key key; Value val; Node left, right; int N; boolean color; // 节点初始化 Node(Key key, Value val, int N, boolean color) &#123; this.key = key; this.val = val; this.N = N; this.color = color; &#125;&#125;private boolean isRed(Node x) &#123; if (x == null) &#123; return false; &#125; else &#123; return x.color == RED; &#125;&#125; 每一个节点只有一个父节点指向的链接或者没有父节点(这个节点是根节点)，这里约定空链接为黑色。 节点变换节点变换使得红黑树在完成插入、删除等操作之后，仍能符合红黑树的一般定义。 左旋左旋是为了符合定义中的“红链接均为左链接”，考虑一种情况： 此时需要通过左旋变换，将红链接“置左”，变成如下图： 此时这棵子树的父节点从h变成x并返回，代码如下： 12345678910Node rotateLeft(Node h) &#123; Node x = h.right; h.right = x.left; x.left = h; x.color = h.color; h.color = RED; x.N = h.N; h.N = 1 + size(h.left) + size(h.right); return x;&#125; 右旋右旋是为了符合定义中的“没有任何一个节点同时和两条红链接相连”，考虑一种情况： 此时势必需要进行右旋，然后才能经过其它操作转换这种情形，具体代码比照左旋： 12345678910Node rotateRight(Node h) &#123; Node x = h.left; h.left = x.right; x.right = h; x.color = h.color; h.color = RED; x.N = h.N; h.N = 1 + size(h.left) + size(h.right); return x;&#125; 色转在右旋后往往会出现下图中出现的情况： 此时将连接在同一个节点上的两个红链接变色，然后将该指向该节点的链接设置为RED。代码如下： 12345void flipColors(Node h) &#123; h.color = RED; h.left.color = BLACK; h.right.color = BLACK;&#125; 实现这里给出完整插入方法： 12345678910111213141516171819202122232425262728private Node put(Node h, Key key, Value val) &#123; if (h == null) &#123; return new Node(key, val, 1, RED); &#125; int cmp = key.compareTo(h.key); if (cmp &lt; 0) &#123; h.left = put(h.left, key, val); &#125; else if (cmp &gt; 0) &#123; h.right = put(h.right, key, val); &#125; // 存在这个键 else &#123; h.val = val; &#125; if (isRed(h.right) &amp;&amp; !isRed(h.left)) &#123; h.rotateLeft(h); &#125; if (isRed(h.left) &amp;&amp; isRed(h.left.left)) &#123; h = rotateRight(h); &#125; if (isRed(h.left) &amp;&amp; isRed(h.right)) &#123; flipColors(h); &#125; return h;&#125; 小结红黑树的原理并不难理解，但是其中的变换比较冗杂，从操作上来说，运行的时间都是对数级别，最坏的情况是最左边的路径交替出现红链接和黑链接，而且红黑树继承了二叉查找树的特质，通过中序遍历，就可以按照键的比较规则有序输出。如果要进行删除操作，会涉及四种删除情形。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机之自己编写命令行工具(下)]]></title>
    <url>%2F2018%2F04%2F18%2FJVM012%2F</url>
    <content type="text"><![CDATA[上篇编写的是响应命令行输入的功能，本篇将编写反馈命令行输入的功能，即可以读取指定路径上目标文件的内容，没有指定路径时采用默认路径。 思路与流程假设注册一个Option实例cp： 1options.addOption("cp", "classpath", true, "classpath"); 当在命令行正确输入后，程序就可以得到一个path字符串，这里会出现几种情况： 字符串内用系统分隔符分开，每个分开的部分属于独立的路径； 字符串用“*”结尾，代表访问该路径下的所有文件； 字符串以“.jar”等结尾； 字符串非null； 当命令行没有输入代表Option以及该Option参数的字符串时，会采用默认路径继续执行； 命令行一旦输入了path并成功得到了path字符串，那么如果这些字符串代表的路径不exists，程序就退出，不会再去默认路径查找。显式获得了路径就不会再去访问默认路径。 上述考虑的是用户路径的情形，实际上程序的运行还需要获取系统路径(包括扩展路径，通过-Xjre参数)，同用户路径一样，当显式获得了通过命令行指定的系统路径后就不会再去访问默认路径。 接下来还需要实现读取路径上目标文件的内容(如果存在)，和获取路径不同的是，即使路径上没有目标文件，程序也不会退出，它会按照系统路径 -&gt; 扩展路径 -&gt; 用户路径的顺序依次查找目标文件并读取其内容，事实上这也符合双亲委派机制。直到这些路径都没有目标文件才抛出表示“不能读取到.class文件”的异常。 路径抽象字符串以“*”结尾的路径相对来说是最复杂的，就以其为例简要分析。 先看其构造器： 1234567891011121314151617181920212223Wildcard_Entry(String path) &#123; String baseDir = path.substring(0, path.length() - 1); File file = new File(baseDir); if (!file.exists()) throw new RuntimeException("不存在当前路径！"); File[] files = file.listFiles(); if (files == null) &#123; throw new RuntimeException("没有获得目录下的子文件和子目录！"); &#125; for (File f : files) &#123; // 如果当前遍历的目录下的实体不是文件，则跳过单次遍历 if (!f.isFile()) continue; if (f.getName().endsWith(".jar") || f.getName().endsWith(".JAR")) &#123; cp.add(new Zip_Entry(baseDir + f.getName())); &#125; &#125; // 当前目录下有可能存在目标文件，且同一目录下不会有同名的多个文件 // 所以添加一个Dir_Entry对象处理 cp.add(new Dir_Entry(baseDir));&#125; getabsolutepath和getcanonicalpath的区别见文末参考，前者总是一个后者，只不过前者包含的一些相对路径的部分没有绝对化。 关于 File file = new File()： 生成的实例file仅仅抽象的表示一个路径(文件夹)或者文件对象，并不会在文件系统真正创建一个路径或文件； 如果文件系统的确存在真实的路径或文件，那么file.exists()就返回true，反之返回false； 接下来再看起readClass方法： 12345678910@Overridepublic byte[] readClass(String className) throws IOException &#123; for (Entry entry : cp) &#123; if (entry.readClass(className) != null) &#123; // 不考虑多个路径返回多个结果 return entry.readClass(className); &#125; &#125; return null;&#125; 本人注释已然说明了，代码中的判断语句不为null证明查找到了目标文件并成功读取，直接返回不会再继续尝试去其它路径查找。 ClassPath编写Classpath主要用来抽象出系统路径、扩展对象以及用户对象的实例，并在readClass方法中确定了读取路径中目标文件内容的顺序。 需要注意的地方有： File.pathSeparator和File.separator区别：File.pathSeparator指的是分隔连续多个路径字符串的分隔符，而File.separator才是用来分隔同一个路径字符串中的目录的。顺带提一下在main方法中采用File.separator.charAt(0)是为了获得单个字符而非字符串； Intellij中System.getenv(“JAVA_HOME”)并不会返回.bash_profile中的设置，可以在Edit Configurations中手动添加环境变量：String jh = “/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home”; 小结编写好的程序可以进行多次测试，当本人将参数设置为-cp . java.lang.Object时，虽然当前目录并没有java.lang.Object.class文件，但是由于在此之前会先在系统变量提供的地址中查找，所以能顺利读取其内容。 参考What’s the difference between getPath(), getAbsolutePath(), and getCanonicalPath() in Java?：重点 -&gt; A canonical path is always an absolute path.]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>命令行工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机之自己编写命令行工具(上)]]></title>
    <url>%2F2018%2F04%2F17%2FJVM01%2F</url>
    <content type="text"><![CDATA[本篇主要涉及如何用Java编写命令行工具(此命令行工具用来加载.class文件)。 准备工作在Java中本人使用Apache Commons CLI这款开源的工具，这里是官方主页：Commons CLI。 工具包下载地址为Apache Commons CLI，也可以通过在maven中配置依赖的方式使用。 定义 &amp; 解析为了编写一个命令行工具，首先需要完成定义(Definition Stage)和解析(Parsing Stage)。新建一个Cmd.java文件，创建一个Cmd类，用一个静态方法进行封装： 1234567891011121314151617class Cmd &#123; public static CommandLine cmd(String[] args) throws ParseException &#123; //定义 Options options = new Options(); options.addOption("help", false, "print help message"); options.addOption("?", false, "print help message"); options.addOption("version", false, "print version and exit"); //解析 CommandLineParser paraer = new DefaultParser(); CommandLine cmd = paraer.parse(options, args); return cmd; &#125; public static void printUsage(String classMainName) &#123; System.out.println("Usage: java " + classMainName + " [-options] class [args...]"); &#125;&#125; 注意： options.addOption()的第二参数表示whether the option requires an argument or not； 在命令行没有输入参数的时候，Java代码读取args[0]会抛出异常，这和Go中args[0]为命令文件名是不一样的； 询问询问(Interrogation Stage)阶段放在主类Main.java中，具体代码如下： 1234567891011121314151617181920212223242526272829303132import org.apache.commons.cli.*;public class Main &#123; public static void main(String[] args) throws ParseException &#123; String className = getMainName(); CommandLine cmd = Cmd.cmd(args); if (cmd.hasOption("version")) &#123; System.out.println("version 0.0.1"); &#125; else if (cmd.hasOption("help") || cmd.hasOption("?") || args.length == 0)) &#123; Cmd.printUsage(className); &#125; else &#123; startJVM(); &#125; &#125; private static void startJVM() &#123; System.out.println("Hello JVM!"); &#125; // 该方法用来返回静态方法main所属的类的类名 public static String getMainName() &#123; return new Object() &#123; String getClassName() &#123; String clazzName = this.getClass().getName(); return clazzName.substring(0, clazzName.lastIndexOf('$')); &#125; &#125;.getClassName(); &#125;&#125; 注意： 当参数输入为-help、?或者没有输入参数的时候，将会返回printUsage方法返回的打印语句，提示正确的输入格式； 如果程序强制要求传入Option参数，则需要使用cmd.getOptions().length != 0而非判断null的方式； getMainName方法是通过匿名类让静态方法main能得到主类名，不直接采用类名字符串带入也是为了避免硬编码； 关于Apache Commons CLI更详细的使用见本文最后列出的官方手册等资料。 小结通过使用Apache Commons CLI这款开源的工具，可以很方便的用Java实现一个命令行工具，访问路径和读取文件的功能将在下一篇释出，源代码见GitHub。 参考《自己动手写Java虚拟机》的作者用Go语言写了一个简易的Java虚拟机 HotSpot和OpenJDK入门：一篇虚拟机的入门文章 Apache Commons CLI官方手册]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>命令行工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机之对象探秘]]></title>
    <url>%2F2018%2F04%2F16%2FJVM_Oop_Desc%2F</url>
    <content type="text"><![CDATA[前篇《Java虚拟机之内存区域》做了一个提纲式的总结，这里将“对象探秘”部分做一个稍稍的展开，包括创建对象的基本流程、对象的内存布局、Class &amp; Klass &amp; KlassKlass浅析以及实例数据重排序等内容。 创建对象的基本流程Java里创建对象通常有五种方式，new，Class类调用newInstance方法，Constructor类调用newInstance方法，clone方法以及反序列化，后四种反编译后可知使用的是invokevirtual指令来做方法调用，而第一种使用的是new和invokespecial指令。一般的，我们都是用new来创建对象，这里以new为例分析创建对象的基本流程，其大致如下： 检查指令参数能否定位符号引用； 检查符号引用代表的类是否已经被加载、解析和初始化过，没有就要先执行这些过程(《深》P210)； 分配内存(CAS / TLAB)； 初始化为零值(不包括对象头)； 对对象头进行必要设置； 通常，执行方法(由invokespecial决定)； 类的初始化自有其它篇章进行介绍，这里需要知道的是，在遇到new等字节码指令时，需要先触发类的初始化。在类加载的连接过程中，准备阶段也会为类变量设置初始化零值，注意区别和类比。 普通字段的初始化器会在每个构造方法中被执行，而且是在写进构造方法内初始化内容执行前执行，但这一切初始化过程发生之前，会先在构造方法中调用父类的方法。 对象内存布局简析对象在内存中的布局包括三个部分：对象头、实例数据和对齐填充。 为了很好的研究这一部分，采用实验的方式来进行，这里用到了一个小工具jol，本人的Java环境为jdk1.8.0_171，64-bit HotSpot VM。 首先看看官方提供的JOLSample_01_Basic代码： 12345678910111213141516171819public class JOLSample_01_Basic &#123; /* * This sample showcases the basic field layout. * You can see a few notable things here: * a) how much the object header consumes; * b) how fields are laid out; * c) how the external alignment beefs up the object size */ public static void main(String[] args) throws Exception &#123; out.println(VM.current().details()); out.println(ClassLayout.parseClass(A.class).toPrintable()); &#125; public static class A &#123; boolean f; &#125;&#125; 这个例子的作用注释已经说明清楚，这段代码的输出为： 1234567891011121314151617# Running 64-bit HotSpot VM.# Using compressed oop with 3-bit shift.# Using compressed klass with 3-bit shift.# WARNING | Compressed references base/shifts are guessed by the experiment!# WARNING | Therefore, computed addresses are just guesses, and ARE NOT RELIABLE.# WARNING | Make sure to attach Serviceability Agent to get the reliable addresses.# Objects are 8 bytes aligned.# Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]# Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]org.openjdk.jol.samples.JOLSample_01_Basic$A object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 12 (object header) N/A 12 1 boolean A.f N/A 13 3 (loss due to the next object alignment)Instance size: 16 bytesSpace losses: 0 bytes internal + 3 bytes external = 3 bytes total 前篇已经总结过，这里再提一下：对象头(object header)分为两个部分：一部分称为Mark Word，用于存储对象自身的运行时数据；另一部分是类型指针：用来确定对象是哪个类的实例。(当然，在数组里，对象头还记录了数组大小) 对以上输出结果做一个简要说明： Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]对应：[Oop(Ordinary Object Pointer), boolean, byte, char, short, int, float, long, double]大小。 OFFSET是基于首地址偏移量，SIZE是大小，因为本人采用的Java虚拟机是64位，那么object header中Mark Word占据64位，也就是8个单位的大小，类型指针占据4个单位大小，所以一共占据12个单位。instance data占据一个单位大小，由于对象大小必须是8字节的整数倍，所以还要对齐填充，此时填充三个单位。 对象内存布局深入首先贴出RednaxelaFX的PPT中的相关章节： 图1 图2 图3 图4 虽然图中的有些描述并不适用较新的Java版本——实际上这些图依据的是JDK6(或之前)的HotSpot VM，但大体来说，我们仍然可以从中有所收获。 图1描述了Mark Word存储了哪些信息，最后一句话提到了并非一次性记录所有信息； 图2中提到的PermGen在Java8里面已经被删除掉了(见文末参考链接)，但通过图中的讲解，我们还是能get到有用的信息。 比如，Java对象实例中对象头存储的klass并不是Java语言级别的那个java.lang.Class类的实例。接下来就重点写写这方面的内容。 Class &amp; Klass &amp; KlassKlass常常能听到有人问，对象的Class实例到底存在哪里。回答这个问题之前，先要搞清楚，想要问的真的是java.lang.Class实例吗？ 我们继续欣赏RednaxelaFX的分享： 图5 如果是第一次看到这张图是不是想感慨Java果然是面向对象语言：instanceOopDesc –&gt; instanceKlass –&gt; instanceKlassKlass –&gt; KlassKlass。(后三个归为klassOopDesc包装层，包装在GC管理的klassOopDesc对象中) RednaxelaFX的解释： HotSpot VM里，Klass其实是用于描述能被GC的对象的类型信息的元数据对象。在JDK8之前的HotSpot VM里，类元数据存在由GC管理的PermGen区里。这些xxxKlass对象（例如instanceKlass的实例）自身也是被GC管理的，所以也需要有Klass对象去描述它们，叫做xxxKlassKlass。然后它们又…所以就有了KlassKlass这个终极的描述xxxKlassKlass对象的东西。 而： 从JDK8开始，既然元数据不由GC直接管理了，Klass这系对象就都不需要再被KlassKlass所描述，所以KlassKlass就全去除了。 看到这里可能会问，为什么元数据不由GC直接管理了，Klass就不需要KlassKlass描述了呢？ RednaxelaFX在留言区回答了热心网友： 因为HotSpot的GC框架通过Klass来获得被GC管理的对象的结构信息；在Metaspace里内存管理是人工写特化的代码做的而不是GC自动做的，就不需要这个KlassKlass结构来描述Klass了。 关于Klass所在的Metaspace的回收，RednaxelaFX也点到： Metaspace有特殊的收集逻辑，跟GC可以联动但是不直接由GC管理 回到本小节起初提到的问题，也许一开始，我们并没有区分InstanceKlass和java.lang.Class，这两个是不同的东西。java.lang.Class对象从来都是存储在普通的Java堆中。那么它们彼此有什么关系呢？ 每个Java对象的对象头里，_klass字段会指向一个VM内部用来记录类的元数据用的InstanceKlass对象；InsanceKlass里有个_java_mirror字段，指向该类所对应的Java镜像——java.lang.Class实例。HotSpot VM会给Class对象注入一个隐藏字段“klass”，用于指回到其对应的InstanceKlass对象。这样，klass与mirror之间就有双向引用，可以来回导航。java.lang.Class实例并不负责记录真正的类元数据，而只是对VM内部的InstanceKlass对象的一个包装供Java的反射访问用。 对象实例数据重排序我们继续看图3中的内容，“宽度相同的字段总是相邻分配”？显然宽度相同的字段肯定不一定按顺序声明初始化，那么如果要满足引号中给出的要求，则需要重排序。下面本人写一个简单的例子： 12345678910111213public class CumTest02 &#123; public static void main(String[] args) throws Exception &#123; out.println(VM.current().details()); out.println(ClassLayout.parseClass(A.class).toPrintable()); &#125; public static class A &#123; int i01; int i02; long l; int i03; &#125;&#125; 首先按照一般逻辑分析对象的内存分布情况： Mark Word：八个单位； 类型指针：四个单位； i01：四个单位； i02：四个单位； l：八个单位； i03：四个单位； 布局应该是这样的： 实际输出结果如下： 123456789org.openjdk.jol.samples.CumTest02$A object internals: OFFSET SIZE TYPE DESCRIPTION VALUE 0 12 (object header) N/A 12 4 int A.i01 N/A 16 8 long A.l N/A 24 4 int A.i02 N/A 28 4 int A.i03 N/AInstance size: 32 bytesSpace losses: 0 bytes internal + 0 bytes external = 0 bytes total 没有对齐填充，实例的大小也只是32字节，也就是说，产生了重排序，布局见下图： 图中l在i02和i03之前，遵照的规则(排序的先后顺序)和Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]列出的顺序相反。i01在l之前是因为已经排好一部分后，剩下的空间能容纳size满足的实例数据，尽管这个数据并不是后续数据中最大的。 对基类是否生成对象的判断创建派生类对象的过程中，基类会生成对象吗？ 首先这个问题可以通过实验轻松验证，但是此问题是在本人看图3想到的，自然就用图3的逻辑稍微判断一下。 在图3中，有这么一句：“笼统的说，基类声明的实例字段会出现在派生类声明的实例字段之前。” 所以基类字段的数据是会在派生类对象中存储一份的，想象一下，如果每一个派生类生成实例时，都需要基类创建一个对象，那么字段等数据就会既存储在基类又存储在派生类中，造成资源浪费，在如今这个追求性能优化极致的时代，一款商业级虚拟机怎么会犯这种让人不能忍受的“错误”？ 所以基类并没有生成对象，只是通过super()调用了构造器。 为了判断是否理解了本篇涉及的一些内容，这里举个例子，看看输出是多少： 12345678910111213141516171819202122public class Base &#123; private String baseName = "base"; public Base() &#123; callName(); &#125; public void callName() &#123; System.out.println(baseName); &#125; static class Sub extends Base &#123; private static String baseName = "sub";// 删去static后运行再观察结果 public void callName() &#123; System.out.println(baseName); &#125; &#125; public static void main(String[] args) &#123; Base b = new Sub(); &#125;&#125; 这个小问题，涉及到对象的创建流程，涉及到基类是否生成对象等等，注意观察注解部分更改后的输出结果。 注：设置VM options参数为-XX:+TraceClassLoading，可以追踪类的加载过程。 鸣谢看过《深入理解Java虚拟机》的读者对RednaxelaFX这个名字不会感到陌生，这篇小文引用了很多他在某平台分享的内容，得益于这些分享，本人对对象内存的布局有了更清晰的理解和认识，在此由衷感谢。 参考RednaxelaFX回答01 RednaxelaFX回答02 Java8内存模型—永久代(PermGen)和元空间(Metaspace)：通过实验印证永久代和元空间在不同Java版本下存在与否]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机之内存区域]]></title>
    <url>%2F2018%2F04%2F15%2FJVM00%2F</url>
    <content type="text"><![CDATA[会Java编程，当然要了解Java虚拟机，学习并笔记之。 内存区域Java虚拟机管理的内存包括以下几个运行时数据区域： 程序计数器 可以看作字节码行号指示器； 执行Java方法时，记录的是字节码制冷地址；执行native方法时，计数器值为空(Undefined)； 没有规定OutOfMemoryError情况； 属于线程私有； Java虚拟机栈 方法执行会创建栈帧，存储局部变量表、操作数栈、动态链接以及方法出口等信息； 局部变量表编译期确定基本类型、引用类型和returnAddress类型； long和double占用两个Slot，其余数据类型占用1个，内存空间大小也是编译期确定； 存在两种异常：StackOverflowError和OutOfMemoryError； 本地方法栈 于虚拟机栈类似，区别在于为Native方法服务； 用于实现的语言、方法和数据结构没有强制规定； Java堆 线程共享； 虚拟机规范：所有对象实例以及数组都在堆上分配；(随着技术发展不绝对) 分带收集算法：新生代老年代； 线程私有分配缓冲区TLAB； 不要求物理连续； OutOfmemoryError； 方法区 线程共享； 存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据； HotSpot用永久代实现方法区； 1.7以后HotSpot把原本放在永久代的字符串常量池移出； 此区域回收目标主要是针对常量池回收和类型卸载； OutOfmemoryError； 运行时常量池 方法区一部分； Class文件的常量池在类加载后进入方法区的运行时常量池存放； 一般来说，运行时常量池除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在其中； 具备动态性，在运行期间也可以将新的常量放入池中，见String的intern()方法; OutOfmemoryError； 直接内存 非运行时数据区的一部分； 非Java虚拟机规范定义的内存区域； 不受Java堆大小的限制； 忽略直接内存可能导致动态扩展时出现OutOfmemoryError； 对象探秘对象的创建 分配内存的时候，有两种方式，一种是“指针碰撞”，一种是”空闲列表”。前者在规整的内存上挪动指针，后者针对相互交错的内存维护一个列表，记录那些内存块可用； 对象创建的线程安全问题，一般有两种解决方案，一种是对分配内存的动作同步处理(CAS配上失败重试)，一种是利用TLAB； 对象的内存布局分为三块区域：对象头、实例数据和对齐填充。 对象头：一部分用于存储对象自身的运行时数据，一部分是用于确定对象属于哪个类实例的类型指针(不都是必须的)； 实例数据：真正的有效信息，存储各类型的字段内容； 对齐填充：非必需，没有特定含义，起占位符作用； 对象的访问定位主流的访问对象的方式有使用句柄和直接指针两种。 使用句柄：内存划分出一块作为句柄池，引用存储的是对象的句柄地址，而句柄包含了实例数据与类型数据各自的具体地址信息； 直接指针：引用直接存储对象地址，Sun HotSpot采用这一种； 小结本篇涉及一些概念，可以通过线程私有和线程共享来划分理解。 参考What’s the difference between StackOverflowError and OutOfMemoryError]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LRU(least recently used)]]></title>
    <url>%2F2018%2F04%2F13%2FLRU%2F</url>
    <content type="text"><![CDATA[不同的缓存策略适合不同的场景，这样可以保证在系统稳定的情况下拥有更好的缓存命中率，避免频繁去数据库“拿”数据。 原理LRU是最近最少使用策略，根据元素最后一次被访问的时间来决定清除哪一部分数据，较远使用的数据较先清除，每当数据被访问后会更新它被访问的时间。 下面举例演示原理，现在假设有一个限定容量为5的LRU缓存，现往其中添加数据： 12345cache.set(1, 2);cache.set(2, 3);cache.set(3, 4);cache.set(4, 5);cache.set(5, 6); 此时如果继续添加(6, 7)，由于容量为5，需要删除原有的数据，在已存在的数据中，(1, 2)最后一次访问的时间距离当前最远，所以删除(1, 2)，输出结果为： 12345(2, 3);(3, 4);(4, 5);(5, 6);(6, 7) 如果此时对(2, 3)进行访问，那么当cache继续添加数据时，被剔除的将是(3, 4)，因为此时该数据最后一次被访问时间离当前最久远。 接下来看看LeetCode的要求：Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set. 本篇也将实现get()和set()方法。 实现实现get()和set()方法之前，需要先实现两个工具方法，分别是remove()和setHead()，这两个方法主要是对双向链表进行操作，这里的链表是不同entry的value值构成的链表，并不涉及entry之间的链接。 12345678910111213public void remove(Node node) &#123; if (node.pre != null) &#123; node.pre.next = node.next; &#125; else &#123; head = node.next; &#125; if (node.next != null) &#123; node.next.pre = node.pre; &#125; else &#123; end = node.pre; &#125;&#125; 上面这段代码的含义是在双向链表中remove一个指定节点，很容易理解。 添加新节点的时候，访问时间是最新的，而如果只是对既有节点进行查询，即使没有修改节点value值，访问时间也会更新。这两种情形的代码编写都需要一个设置链表表头的工具方法： 1234567891011121314public void setHead(Node node) &#123; node.next = head; node.pre = null; if (head != null) &#123; head.pre = node; &#125; head = node; if (end == null) &#123; end = head; &#125;&#125; 将一个节点设置为表头说明它的访问时间是最近的，被清除的优先级最低。 Getget()方法是这样一种方法：首先在cache内查找是否存在以传入参数为键的键值对，如果存在，获取value值，将value设置为双向链表的表头(因为此时相当于刚刚访问键值对，设置到表头表示该数据被清除的优先级最低)；如果不存在，则返回-1，具体代码如下： 123456789public int get(int key) &#123; if (map.containsKey(key)) &#123; Node node = map.get(key); remove(node); setHead(node); return node.val; &#125; return -1;&#125; Setset()分两步走，一是当要设置的键原本存在，此时类似于进行了一次get()，只不过最后将键值对的值设置为要设置的值(实际上，在本程序中，需要设置的是键值对值的值，这个在最后再进行说明)；一是当要设置的键不存在，此时除了需要添加新的数据到cache和双向链表以外，还应考虑是否超过cache的容量，如果是，需要清除最远访问时间的数据，完整代码见下： 1234567891011121314151617181920public void set(int key, int val) &#123; if (map.containsKey(key)) &#123; Node old = map.get(key); old.val = val; remove(old); setHead(old); &#125; else &#123; Node newNode = new Node(val); if (map.size() &gt;= size) &#123; // 此时如果删除hash桶的引用，node由于还在链表上有被引用，所以不被马上回收 Collection&lt;Node&gt; col = map.values(); col.remove(end); remove(end); setHead(newNode); &#125; else &#123; setHead(newNode); &#125; map.put(key, newNode); &#125;&#125; 小结首先说说本篇算法最关键的一个细节，LRUCache将存储交给了HashMap来实现，HashMap内部是通过Entry来维护一个键值对，Entry相当于HashMap的Node，一般情况下，键和值都存入Entry中，但是此算法中的Entry维护一个(key, node)，而node中的value才是真正的value，这样处理的好处是，在node中可以定义前驱和后继，用以构造双向链表，双向链表可以控制LRUCache的大小，同时定义每个node的被访问时间优先级，Node的实现代码如下： 123456789class Node &#123; int val; Node pre; Node next; public Node(int val) &#123; this.val = val; &#125;&#125; 由于在本算法中，本人没有在Node中定义key(这样节约不少空间，但是却花费了更多时间，属于用时间换空间，不过在这里本意是想尝试通过值而不是通过键来做删除动作)，所以在set()中，当我要删除一个满足条件的entry的key时，采用的是如下代码： 12Collection&lt;Node&gt; col = map.values();col.remove(end); 第二行代码并不会删除end指向的对象，对象的回收当然是交给虚拟机，虽然此时HashMap对end采用remove()操作，双向链表对end指向对象的引用仍然存在，然后再remove(end)，强调一下后者是LRUCache提供的方法，不是HashMap的方法。 参考Java实现LRU]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git带着问题去实践(二)]]></title>
    <url>%2F2018%2F04%2F13%2FGit_Prac02%2F</url>
    <content type="text"><![CDATA[“有人把Git的分支模型称为它的必杀技特性，也正因为这一特性，使得Git从众多版本控制系统中脱颖而出。” 冲突&amp;合并在上一篇的基础上，git跳转到哈希码头四位9533的commit版本上，用命令git branch命令创建分支branch01和branch02，这个时候产生疑问： 在某分支上做改动，其它支线看得到改动的部分吗？ 切换到branch01上，将最后一行添加“branch01”到Hello后面。此时用git checkout命令切换到master或者branch02上，cat test.md，查看内容发现，都能看见改动的部分，再次切换到branch01，add改动的文件，再次切换到其它支线，此时在其它支线仍然能看见staged状态下modified的部分。切换到branch01，将刚刚add的文件commit，然后再切换到其它支线，此时将看不见modified(无论是否staged)的部分。 其实这不难理解，在没有提交前，所谓的分支不过是各个指针指向当前提交点而已。 需要说明的是，如果再次用同样的方法，对branch02进行修改，比如更改test.md最后一行为Hello branch02，尝试切换回branch01将会报错： 1234error: Your local changes to the following files would be overwritten by checkout: test.mdPlease, commit your changes or stash them before you can switch branches.Aborting 切换失败，需要commit或者使用stash解决，关于stash后面会讲到。 在各支线，用git log命令可以看到其它支线提交的情况吗？ 将branch02分支中add的文件commit，切换到各支线进行测试，结果是不能。 不仅如此，git log --oneline --decorate这个命令，只会追踪HEAD指针，当其它分支都停留在HEAD指针指向的地方时，命令才会将它们的名字打印出来。 但是使用git log --oneline --decorate --graph --all可以打印出所有支线组成的树状结构。 log也可以查看公共仓库的提交，使用git log origin/master命令即可。 怎么给Git命令取别名？ 以git log --oneline --decorate --graph --all为例，为它取一个别名git tree可以通过如下设置： 1$ git config --global alias.tree 'log --oneline --decorate --graph --all' 当打下git tree将出现和欲被修改的别名命令同样的效果。 为了以后的方便，这里将reset HEAD --设置为unstaged： 1$ git config --global alias.unstaged 'reset HEAD --' 分支怎么合并到master? 12$ git checkout master$ git merge branch01 此时输出： 1234Updating 9533382..28f767bFast-forward test.md | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 这里用到fast-forward，是因为在这次合并中，master指针只是做了一个向前移动的动作。至于为什么可以fast-forward，源于branch01是master的直接上游，合并不产生没有解决的分歧。从这个动作看来，称master“合并”到branch01更适合。接着也可以使用删除命令对branch01进行删除： 1$ git branch -d branch01 branch02怎么合并到master？ branch01很迅速的就合并到master上了，但是如果现在要将branch02合并到master上，就会产生冲突： 123Auto-merging test.mdCONFLICT (content): Merge conflict in test.mdAutomatic merge failed; fix conflicts and then commit the result. 因为此时的master和branch02已经不是一条直线上的“蚂蚱”了，变成了旁系，且branch02和之前的branch01本来就有冲突。 合并冲突后任意时刻调用git status可以查看包含合并冲突而未合并的文件，等待你去解决合并产生的冲突。使用cat test.md查看文件： 123456789Hello I am LiLei.Hello I am XiaoFang.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADHello branch01=======Hello branch02&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch02 然后修改该冲突文件，一旦运行git add命令，Git就会知道冲突已经解决： 123On branch masterAll conflicts fixed but you are still merging. (use "git commit" to conclude merge) 继续commit最终完成合并。 Git对行列的空格符会进行冲突检测吗？ 在Git内任何空格符都是能够被识别的，下面是一个例子的结果： 123456789Hello I am LiLei.Hello I am XiaoFang.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADHello branch01 branch02 b01=======Hello branch01 branch02 b02&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch02 分支管理在切换到不同分支后使用git branch [新建的分支名]创建的新的分支有什么不同？ 在不同分支先创建新的分支，就相当于在当前创建了一个新的指针而已。在上一个问题的最后，branch02已经合并到master上了，此时切换到branch02新建一个分支branch03，那么运行命令： 1$ git branch --merged branch02和branch03都会打印出来，切换到master，如果此时合并branch03会显示Already up-to-date。同样的如果在master下新建一个分支branch04，那么尝试合并它也会打印Already up-to-date。如果要打印所有包涵未合并工作的分支，使用如下命令： 1$ git branch --no-merged 如何查看远程分支？ 只需要运行git branch -r就可以查看远程分支，而如果运行git branch -a将罗列出所有分支。 储藏&amp;清理未处于staged的modified数据和处于staged状态的数据都能被stash么 实测的确是这样，stash针对的工作区的改动(Saved working directory)。在git stash apply后文件的改动被重新应用了，但是之前staged的文件却没有重新处于staged状态。如果要在调用命令后就处于staged状态，可以使用如下命令： 1$ git stash apply --index Git可以在同一个分支多次存储吗？ 经过本人来回多次git stash apply stash@{0}，验证出可以进行多次存储，但每次恢复其中一个后，并不能马上又恢复另一个，这样会出现以下信息： 1234error: Your local changes to the following files would be overwritten by merge: test.mdPlease, commit your changes or stash them before you can merge.Aborting 在stash的过程中怎么添加描述信息？ 我的做法是这样的： 1$ git stash save "具体描述信息" 如何移除stash的工作？ 命令如下： 1$ git stash drop stash@&#123;0&#125; 这条命令可以指定删除哪一条stash存储的内容。 再就是下面这条恢复后弹出栈命令： 1$ git stash pop 它会恢复栈顶stash储存的内容，恢复后，这条stash也从栈弹出，相当于删除栈顶。 工作目录下untracked状态的test02.md属于多余的“看客”，使用什么命令可以删除？ 答案是 git clean。但通常最后添加参数-n，比如这里运行如下代码： 1git clean -n 会输出这样的结果： 1Would remove test02.md 所以上面的命令并不会真正删除，只不过是个提醒。 如果使用命令： 1git clean -df 即删除当前目录吓没有被track的文件和文件夹。 打标签Git可以给历史中的某一个提交打上标签。 如何列出标签？ 只需要输入git tag就可以了。而打轻量标签，是在git tag后面添加参数作为标签名，此参数不需要打引号表示字符串。 既然是给提交打标签，那么如何给过去的某个提交打标签？ 比如现在我要为实验中的某次commit(9533382df5a3b45b5d6a67fe2f51ce3fafd1c8b8)打标签，我会使用如下命令： 1$ git tag -a v1.0 9533 -m "my v1.0" 如果不希望Write a message for tag，如何给提交打标签？ 在上一个问题中，必须提供一个用来描述的message，主要是因为命令中含有-a，现在使用下面的命令，打印轻量标签： 1$ git tag v.1.1 1d3b 以上反映的是轻量标签和附注标签的不同。 可以根据tag创建分支吗？ 见如下命令： 1$ git checkout -b branchname v1.1 如何看待git checkout [标签名] 切换tag和切换branch的命令相同，在实际的测试中，输入该命令后，各branch列表如下： 当切换到其它分支后，“临时”branch就不见了，这种状态被称为detached HEAD状态。 上传到远程仓库： 1$ git push origin tag名 小结通过两篇小记，采用自问自答的形式，窥探了git最核心的几个功能。 参考progit-zh-v2.1.1.pdf]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git带着问题去实践(一)]]></title>
    <url>%2F2018%2F04%2F12%2FGit_Prac%2F</url>
    <content type="text"><![CDATA[之前翻译过一篇简短的《GIT CHEAT SHEET》，这里带着问题实践一下。 状态在Git里文件有四种状态：untracked、unmodified、modified和staged。 第一个问题：untracked是什么状态？ touch一个README.md然后运行相关命令后有： 在untracked状态下，README.md就像一个“路人甲”，没有被Git系统追踪。 第二个问题：如何查看modified状态下更改过的内容？ 使用如下命令： 1$ git diff README.md 第三个问题：如何查看进入staged状态后的内容？ 使用如下命令： 1$ diff --staged README.md 或者： 1$ git diff --cached README.md 如果既有处于modified状态的内容，又有处于staged状态的内容，分别运行上文提到的命令，会得到什么结果？ 编辑README.md文件内容： 12345First editstaged状态modified状态 其中第二行和第三行构造为staged状态，第四行和第五行构造为modified状态。 运行git diff命令有： 运行git diff –staged / –cached命令有： 从结果可以看出，modified状态对staged状态和unmodified状态一视同仁。而staged状态并未在乎modified状态的修改。 需要注意的是空行的修改。 staged状态怎么理解？ 之前看过一些资料，有说法认为这是模仿这样一种功能：比如Windows上，当你要进行批处理操作时，在确定之前会给你一个勾选界面进行勾选。额，大概就是给你一个巴洛特利式思考人生的时间吧。 如果不需要思考人生，能不能跨过staged状态直接commit呢？ 只要给commit添加参数 -a就可以了。 如何将README.md还原成untracked状态？ 可以使用如下命令： 1$ git rm --cached README.md 不能只使用rm，这样会出现“Changed but not updated:”(而且如果有内容处于modified状态或staged状态还要添加-f参数，这样做是为了保证安全)，如果你希望保存文件夹下存在README.md，那么你也不仅仅要使用git rm，而应该添加–cached参数。 表格总结如下： 文件夹下保留文件 文件夹下不保留文件 Has _M git rm –cached git rm -f Has M_ git rm –cached git rm -f Has MM git rm –cached -f git rm -f Not has MM git rm –cached git rm 现在来分析其中几个主要情况： 文件包含modified状态的内容： 1.如果希望文件夹下保留文件，那么执行git rm --cached命令，然后查看状态： 此时README.md处于untracked状态。 如何恢复到最开始文件包含modified状态的内容时的状态呢？首先执行git add README.md，然后再采用git reset HEAD README.md命令。或者，执行git reset HEAD README.md。 2.如果希望文件夹下不保留文件，需要执行git rm -f，之所以要添加选项-f是为了数据的安全，当使用这个命令后，就意味着将舍弃modified状态和staged状态下的修改。 文件夹下包含staged状态的内容： 基本和文件包含modified状态内容的情况相同，在恢复最开始内容的时候有点点出入。 文件包含modified状态和staged状态的内容： 如果此时使用git rm --cached README.md命令会出现如下结果： 所以要添加选项-f，想来也容易理解其中原因，当你要通过前述方法恢复数据的时候，你无法区分哪一部分是modified的内容，哪一部分是staged的内容，这就造成了信息丢失。 历史与撤销如果仅仅是一次add犯了错，要还原成untracked状态还可以使用什么方法？ 下面我们touch一个新的文件README02.md并add之，这个时候运行git status -s命令有： 此时虽然README02.md的内容处于staged状态，但是它属于new file，所以用A表示。在这种情况下使用如下命令可将README02.md恢复到untracked状态： 1$ git reset HEAD README02.md 能不能撤销README.md处于modified状态的修改？ 可以，只需要使用如下命令： 1$ git checkout -- README.md 如何查看最新提交的更新情况? 1$ git show 如果要查看指定的某次提交更新的情况呢？ 1$ git show xxxx xxxx对应git log打印出来的四十位SHA-1哈希码，可以把它当作每次commit的专属id。本人在本机上测试时，这个码至少要输入四位。 除此之外，还有方法查看最新提交的更新情况： 1$ git log -p -1 经本人比较以上两条命令输出结果是一样的。该条命令中，-1如果改为-n，表示查看最近n条更新，省去查看全部更新。 如何比较某两次提交的变化？ 使用如下命令： 1$ git diff xxxx xxxx 两个参数xxxx对应要比较的两次提交id，谁作为第一个参数，谁就是参照物，最后的打印会显示以参照物为标准的变化。 如果git rm –cached README.md后，那么此时再add刚刚已经untracked的README.md后会发生什么呢？ 实际上属于前文某表格下的分析的情形，但在那里的分析忽略掉了Not has MM的情况，这里进行说明。 如果当前的README.md既没有modified状态的内容，也没有staged状态的内容，在执行git rm –cached README.md后，继续add README.md，会出现如下结果： 此时modified状态和staged状态下是没有内容的。 如何列出所有的SHA-1哈希码？ 使用如下命令即可： 1$ git reflog 小结本篇用问答的形式，记录个人在使用Git上遇到的一些问题，下一篇将用同样的形式聚焦Git分支管理等功能。 参考progit-zh-v2.1.1.pdf]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码摘要]]></title>
    <url>%2F2018%2F04%2F11%2FHashmap%2F</url>
    <content type="text"><![CDATA[本篇主要分析HashMap源码。 java.util包(Java7)下的HashMap是一个泛型容器，它的继承关系见代码： 1public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125; 此文章主要围绕本人阅读HashMap源码引出的问题来展开，HashMap没有实现Collection，属于一种Map容器。 构造与初始化先来看主要的初始化代码： 1234567891011121314public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; threshold = initialCapacity; init(); &#125; initialCapacity就是初始化容量，loadFactor就是负载因子，默认是0.75，在后续要在本篇分析的代码中，用来计算threshold，至于init()的作用见本篇最后参考文献，该方法可以使构造初始化和反序列化的功能更规整。 和初始化相关的部分，有这么一个辅助方法： 123456private static int roundUpToPowerOf2(int number) &#123; // assert number &gt;= 0 : "number must be non-negative"; return number &gt;= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1; &#125; 其中Integer.highestOneBit()是将传入参数的二进制表示的最高位进行保留，其它位全部设为零，再返回，整个辅助方法的目的是产生一个大于等于number的最小2的幂次方的值，这个方法是为下面这个方法服务的： 12345678private void inflateTable(int toSize) &#123; // Find a power of 2 &gt;= toSize int capacity = roundUpToPowerOf2(toSize); threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); table = new Entry[capacity]; initHashSeedAsNeeded(capacity); &#125; 这个方法用来计算threshold，在table == EMPTY_TABLE时，初始化一个table，Entry就是一般算法书中的Node，貌似Java8已经用Node代替Entry了。 从上面可知，在HashMap中table的大小设置为2的幂次方，这和算法书上推荐素数的策略不一样，使用2的幂次方和采用的hash()策略有很大关系，下面是生成hash()方法和生成table索引的方法： 12345678910111213141516171819202122final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; /** * Returns index for hash code h. */ static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2"; return h &amp; (length-1); &#125; h &amp; (length-1)相当于h % length，但前者具有更高的效率，所以length最好是偶数，因为如果是奇数最后末位是0，通过除留取余法会很容易让两个key在table中处于相同的index，也就是碰撞冲突，而将table的大小设置为2的幂次方，一方面它是偶数，另一方面，它的产生也可以很容易就通过位运算来获得，提高了性能，而且扩容通常都是double一次(这是非常普遍的扩容策略)。当然，取2的幂次方仍然容易产生碰撞，所以要对原本的hash值扰动计算，进行再hash，扰动计算的细节见本篇最后参考文献中某问题下的回答。 以上就是本人对HashMap初始化内容的理解。 接受null键HashMap是接受null键的，首先看getForNullKey()代码： 12345678910private V getForNullKey() &#123; if (size == 0) &#123; return null; &#125; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null; &#125; 当需要取以null为键的值的时候，首先判断size是否为0，如果size为0就直接返回null，不用做无谓的查找了。接着我们可以发现，以null为键的entry只存储在以table[0]值为表头的链表中(看来默认null % length = 0)，依次遍历这个链表直到键值 == null为止。 Put下面分析招牌的put()，该方法内第一个for循环之前的内容在原理上前文已经分析过了。for循环后的代码如下： 123456789101112for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125;&#125;modCount++;addEntry(hash, key, value, i);return null; 由这段代码可以看出，两个实体entry(node)的hash值相同并且只要键值==，那么其实就不用计算equals()了，直接更新value，返回旧值；如果前面的条件不满足，就添加entry，代码如下： 123456789void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex); &#125; addEntry()和createEntry()的区别在于，addEntry()要进行一次数组扩容的判断，如果需要扩容，此时bucketIndex需要重新计算以适应新的table.length，关于扩容的内容后续再进行具体分析，下面看看createEntry()代码： 123456789101112void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++; &#125;Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; 这两段代码也非常简单，值得一提的是，后续添加的entry将成为table相关索引指向的链表的表头。 扩容前述中，在addEntry()中进行(size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])判断并为真的时候，需要resize()，下面是resize()的代码： 1234567891011121314151617void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; boolean oldAltHashing = useAltHashing; useAltHashing |= sun.misc.VM.isBooted() &amp;&amp; (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD); boolean rehash = oldAltHashing ^ useAltHashing; transfer(newTable, rehash); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);&#125; 这段代码也并不复杂，实现的关键是transfer(newTable, rehash)，具体代码如下： 123456789101112131415void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125;&#125; 这段代码的构造和之前设计put()方法的思路是相似的，只不过这里需要被“put()”的是原本存在的entry，这个entry是通过遍历hash桶每一个索引关联的链表得到的。 小结在本人看来，HashMap是空间换时间的算法，理想状态在O(1)进行操作。但通过上述分析也可以看出，如果碰撞较多，存在最坏的时间复杂度O(n)；因为每个键值的存储都依赖hash，但hash的生成和存储顺序并不一致，所以HashMap不具有顺序性；此外HashMap不是线程安全的。应对以上场景可以考虑LinkedHashMap以及ConcurrentHashMap。Java 8中HashMap的源码分析可以参考最后列举的文献，最大改动就是当碰撞较多后，链表会过长(8元素以上)，此时将链表转换为一棵红黑树。 参考文献 Java 8系列之重新认识HashMap这篇文章开头对相似的Map类进行了简要比较。 HashMap构造函数最后一行调用的init方法的作用 initHashSeedAsNeeded相关问题 HashMap中的hash实现扰动计算]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码摘要]]></title>
    <url>%2F2018%2F04%2F09%2FArrayList%2F</url>
    <content type="text"><![CDATA[本篇主要分析ArrayList源码。 java.util包(Java7)下的ArrayList是一个范型容器，它的继承关系见代码： 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;&#125; 此文章主要围绕本人阅读ArrayList源码引出的问题来展开，有些问题涉及到上面列出的上层类和接口。 构造与初始化12345678910111213141516171819202122private transient Object[] elementData;private int size;public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); this.elementData = new Object[initialCapacity];&#125;public ArrayList() &#123; this(10);&#125;public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; 由这段代码可知ArrayList在没有传参的情况下会初始化一个大小为10的Object数组，在列出的第三个构造器中，if (elementData.getClass() != Object[].class)引人入胜，代码中给出了一条注释：c.toArray might (incorrectly) not return Object[] (see 6260652)，这是第一个要关注的问题。 在接口Collection代码中，有两个未实现的toArray方法，需要子类自己去实现。回到本代码中，具体执行哪一个toArray方法，取决于ArrayList构造器传入的参数，在ArrayList中，无参的实现是这样的： 123public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125; 继续查看util包中Arrays下的copyOf()代码： 1234567891011121314@SuppressWarnings("unchecked")public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass());&#125;public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings("unchecked") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 因为在ArrayList中elementData是Object[]类型，所以其它的重载方法这里就不列出来了。这段代码中((Object)newType == (Object)Object[].class)也是第二个值得理解的问题。 先尝试理解第二个问题。 这个问题又可以分几个小问题： 为什么要将==左右两边强制转换为Object； 为什么要用三目运算符中的代码生成数组； 为什么不用三目运算符的表达式3取代三目运算符的部分； 1A: 这里举一个简单的例子，代码如下： 1234567891011121314151617181920class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125;class Jonathan extends Apple &#123;&#125;class Orange extends Fruit &#123;&#125;public Class Test07 &#123; public static void main(String args[]) &#123; Fruit a = new Apple(); Orange b = new Orange(); Jonathan c = new Jonathan(); Fruit d = new Jonathan(); System.out.println(b == c); //不可比较类型 System.out.println(a == c); //false System.out.println((Fruit)b == c); //false System.out.println(c.getClass() == d.getClass()); //true &#125;&#125; 这段代码说明“直系”类是可以比较的，例如a和c等；“旁系”不能比较（如b，c），编译不能通过。但如果转型为公共“祖先”（或者用父类引用指向要比较的对象），那么代码就可以运行（见(Fruit)b和c)。 所以在将==左右两边强制转换为Object，是为了让程序通过编译，但是即使进行了向上转型，==比较的是对象的内存地址，并不会破坏原本的比较逻辑。 2A: Java不支持泛型数组，类似List&lt;E&gt;[] listarr = (ArrayList&lt;E&gt;[]）new ArrayList[10];是类型不安全的，但是可以通过编译，因为Java虽然不能创建泛型数组对象，但可以运用在声明和强制转换中。三目运算符包含的是创建“泛型数组”的代码。具体展开请见stackoverflow: How to create a generic array in Java?。“此时编译器是不可能证明这段程序是安全的，…但相关的数组保存在一个私有的域中，永远不会被返回到客户端，或者传递给任何其他方法。这个数组中保存的唯一元素，是传递给push方法的那些元素，它们的类型是E，因此未受检的转换不会有任何危害。”——《Effective Java中文版》(第二版) ArrayList代码中elementData是私有的域，传递给诸如add等方法的那些元素类型是E。 3A: public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) {}这个方法服务于多处。多数情况下只需要new一个Object[]对象来实现“泛型数组”，毕竟在ArrayList内部elementData是Object[]，而反射创建对象的效率是比new创建对象要低。具体也可以参考stackoverflow: I have trouble understanding the source code of Arrays.copyOf。 在数组中，以下两种方式创建的对象具有不同的Class对象： 12345Object[] o1 = new Integer[]&#123;1, 2, 3, 4, 5, &#125;;Object[] o2 = &#123;1, 2, 3, 4, 5, &#125;;System.out.println(o1.getClass().getComponentType());System.out.println(o2.getClass().getComponentType()); 输出分别是class java.lang.Integer和class java.lang.Object。但o1[1] = “Hello World”;会通过编译，运行时报java.lang.ArrayStoreException。 再尝试理解第一个问题。 为什么在初始化中要添加if (elementData.getClass() != Object[].class)代码？因为虽然大部分的toArray操纵的是private的elementData，但在util包的Arrays下存在一个asList方法： 12345@SafeVarargs@SuppressWarnings("varargs")public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; 而Arrays下toArrays的实现如下： 1234@Overridepublic Object[] toArray() &#123; return a.clone();&#125; 这样只要Arrays.asList()传入的实参不是Object[]，就会导致elementData.getClass() 不等于Object[].class。 12private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123;&#125; 值得注意的是，Arrays内部实现了一个私有的静态内部类ArrayList，不是util包的ArrayList。这个bug具体详见JDK-6260652。 这里有一篇System.arraycopy的介绍Java的System.arraycopy()方法拷贝小数组时高效吗?。 迭代ArrayList中另一个值得关注的地方就是迭代功能的实现。 ArrayList实现了Iterable接口： 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; Itr()的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 首先这段代码似乎违背了《Effective Java中文版》(第二版) 第24条：“你可以试着将注解放在整个方法上，但是在实践中千万不要这么做，而是应该声明一个局部变量来保存返回值，并注解其声明。” cursor: 下一个要返回的元素的索引lastRet: 最后一次已返回的元素的索引expectedModCount: 预期修改次数的记录值 先看下面这行代码： 123456789ArrayList&lt;Integer&gt; o4 = new ArrayList&lt;Integer&gt;();o4.add(1);o4.add(2);for(Integer o: o4) &#123; o4.remove(o);&#125;System.out.println(o4.get(0)); 啊哈哈，程序运行无误，没有产生java.util.ConcurrentModificationException异常，这可能是因为o4中只包含两个元素，没有触发fail-fast机制。 在正常的迭代过程中，不能让容器发生结构性变化，例如添加、删除等操作，于是设置变量expectedModCount和modCount(后者来自于AbstractList)。每次发生添加等操作的时候，modCount会增加，迭代时就通过比较expectedModCount和modCount来判断是否抛出异常。 12345678Iterator&lt;Integer&gt; itr = list.iterator();while(itr.hasNext()) &#123; itr.next(); itr.remove();&#125;// System.out.println(o4.get(0)); 如果代码中不添加itr.next();会报java.lang.IllegalStateException异常，如果取消注释会发生java.lang.IndexOutOfBoundsException异常。 小结这篇笔记主要记录了本人读源码时注意到的几个点，后期如有新体会也会持续更新，若有错误也会即使更正。考虑到前文中有不少内容涉及到“泛型数组”，在这里不妨用《Effective Java中文版》(第二版)第25条的一段来收尾： “当你得到泛型数组创建错误时，最好的解决办法通常是优先使用集合类型List&lt;E&gt;，而不是数组类型E[]。这样可能会损失一些性能或者简洁性，但是换回的却是更高的类型安全性和互用性。”]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单排序]]></title>
    <url>%2F2018%2F04%2F09%2FSimple_Sort%2F</url>
    <content type="text"><![CDATA[《算法(第4版)》介绍了不少简单的排序算法，这里亲手码一遍。 排序算法涉及的算法有插入排序、选择排序、希尔排序、冒泡排序、快速排序、归并排序以及堆排序。 插入排序主要思想就是还未排序的元素，依次插入已排序好的序列中，直接放代码： 123456789101112131415161718192021222324public class InsertionSort &#123; public static &lt;T extends Comparable&gt; void sort(T[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = i - 1; j &gt;= 0; j--) &#123; if (less(arr[j + 1], arr[j])) &#123; exch(arr, j + 1, j); &#125; else &#123; break; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Integer[] ar = new Integer[]&#123;1, 7, 6, 4, 3&#125;; String[] strings = new String[]&#123;"abcab", "ababc", "acbac"&#125;; sort(strings); sort(ar); System.out.println(isSorted(ar)); show(ar); show(strings); &#125;&#125; 从for循环可以看出，新近要插入的元素从后向前依次和排序好的序列元素进行比较，最好的情况是交换次数为0，此时目标序列本身就是有序的，排序时间复杂度是O(n)，最坏的情况是目标序列本身是逆序的，此时排序的时间复杂度是O(n2)。 选择排序选择排序的代码如下： 12345678910111213141516171819public class SelectionSort&#123;public static &lt;T extends Comparable&gt; void sort(T[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123;// T temp = arr[i]; for (int j = i; j &lt; arr.length; j++) &#123; if (less(arr[j], arr[i])) &#123; exch(arr, j, i); &#125; &#125; &#125;&#125;public static void main(String[] args) &#123; Integer[] ar = new Integer[]&#123;5, 2, 6, 4, 3&#125;; sort(ar); show(ar); &#125;&#125; 主要思想是，每次选取还未排序序列的最小元素，放入序列头。具体到选取过程，是采用遍历的方式，挨个比较，所以无论原本的序列处于什么情形，排序的时间复杂度都是O(n2)。 希尔排序123456789101112131415161718192021222324252627282930public class ShellSort &#123; public static &lt;T extends Comparable&gt; void sort(T[] arr) &#123; int h = arr.length; while (h &gt;= 1)&#123; h = h / 3; for (int i = h; i &lt; arr.length; i++) &#123; for (int j = i - h; j &gt;= 0; j -= h) &#123; if (less(arr[j + h], arr[j])) &#123; exch(arr, j + h, j); &#125; else &#123; break; &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Integer[] ar = new Integer[]&#123;1, 7, 6, 4, 3&#125;; String[] strings = new String[]&#123;"abcab", "ababc", "acbac"&#125;; sort(strings); sort(ar); System.out.println(isSorted(ar)); show(ar); show(strings); &#125;&#125; 希尔排序只需要对插入排序稍加修改，核心思想就是利用插入排序在部分有序的情况下会减少它的时间复杂度，所以可以将整个序列分成几条等索引差序列，先对这些序列进行插入排序。希尔排序的平均时间复杂度是O(nlog2n)。 冒泡排序12345678910111213141516171819202122232425262728public class BubbleSort&#123; public static &lt;T extends Comparable&gt; void sort(T[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; boolean flag = false; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (less(arr[j + 1], arr[j])) &#123; exch(arr, j + 1, j); flag = true; &#125; &#125; if (!flag) &#123; break; &#125; &#125; &#125; public static void main(String[] args) &#123; Integer[] ar = new Integer[]&#123;1, 7, 6, 4, 3&#125;; String[] strings = new String[]&#123;"abcab", "ababc", "acbac"&#125;; sort(strings); sort(ar); System.out.println(isSorted(ar)); show(ar); show(strings); &#125;&#125; 两两交换，每次固定一个位置，时间复杂度是O(n2)，优化后在有序的情况下，时间复杂度可以是O(n)。 快速排序代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public class QuickSort &#123; public static &lt;T extends Comparable&gt; void sort(T[] arr, int left, int right) &#123; if (left &gt;= right) return; int i = left; int j = right; T k = arr[left]; while (i &lt; j) &#123; while (!less(arr[j], k)) &#123; j--; if (j == left) break; &#125; while (!less(k, arr[i]) &amp;&amp; i &lt; j) &#123; i++; &#125; if (i &lt; j) &#123; exch(arr, i, j); &#125; &#125; exch(arr, left, i); sort(arr, left, i - 1); sort(arr, i + 1, right); &#125; public static void main(String[] args) &#123; Integer[] ar = new Integer[]&#123;1, 5, 7, 5, 6, 7, 3, 2&#125;; String[] strings = new String[]&#123;"abcab", "ababc", "acbac"&#125;; sort(strings, 0, strings.length - 1); sort(ar, 0, ar.length - 1); System.out.println(isSorted(ar)); show(ar); show(strings); &#125;&#125; 这里采用的是一种常规实现，书中说左侧扫描最好是在遇到大于等于切分元素值的元素时停下，右侧扫描则是遇到小于等于切分元素值的元素时停下，但在本实现中，步进的i在遇到大于切分元素值时停下，j则是遇到小于时停下。由于本解答中，切分初始元素总是采用序列的第一个，所以在最外层while的内循环里，两个while的循环条件必须保证i &lt; j，或者在循环体内部保证i不大于j。快排的平均时间复杂度是O(nlog2n)，主要缺点时非常脆弱，在某且情况时间复杂度会变成O(n2)。 归并排序代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MergeSort &#123; public static &lt;T extends Comparable&gt; void sort(T[] arr) &#123; List&lt;T&gt; aux = new ArrayList&lt;&gt;(arr.length); sort(arr, 0, arr.length - 1, aux); &#125; private static &lt;T extends Comparable&gt; void sort(T[] arr, int left, int right, List&lt;T&gt; aux) &#123; if (left &gt;= right) &#123; return; &#125; int mid = (left + right) / 2; sort(arr, left, mid, aux); sort(arr, mid + 1, right, aux); merge(arr, left, mid, right, aux); &#125; public static &lt;T extends Comparable&gt; void merge(T[] arr, int left, int mid, int right, List&lt;T&gt; aux) &#123; int i = left; int j = mid + 1; int t = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (!less(arr[j], arr[i])) &#123; aux.add(t++, arr[i++]); &#125; else &#123; aux.add(t++, arr[j++]); &#125; &#125; while (i &lt;= mid) &#123; aux.add(t++, arr[i++]); &#125; while (j &lt;= right) &#123; aux.add(t++, arr[j++]); &#125; t = 0; while (left &lt;= right) &#123; arr[left++] = aux.get(t++); &#125; &#125; public static void main(String[] args) &#123; Integer[] ar = new Integer[]&#123;1, 7, 7, 6, 4, 3&#125;; String[] strings = new String[]&#123;"abcab", "ababc", "acbac"&#125;; sort(strings); sort(ar); System.out.println(isSorted(ar)); show(ar); show(strings); &#125;&#125; 这是一个自顶向下的原地归并算法，比较关键的代码在于两个sort()后再进行merge()那段，sort()执行后会不断递归向下，所以merge()一定是对两段已经排序的序列进行操作。该算法在最坏的情况下的比较次数是O(nlog2n)。 堆排序这里只涉及堆排序的操作，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public class HeapSort&#123; public static &lt;T extends Comparable&gt; void sort(T[] arr) &#123; int N = arr.length; for (int k = N / 2 - 1; k &gt;= 0; k--) &#123; sink(arr, k, N); &#125; while (N &gt; 0) &#123; exch(arr, 0, N - 1); N--; sink(arr, 0, N); &#125; &#125; private static &lt;T extends Comparable&gt; void sink(T[] arr, int k, int N) &#123; while (k &lt;= N / 2 - 1) &#123; int j = 2 * k + 1; // 找到左节点和右节点中较大的一个 if (j + 1&lt; N &amp;&amp; less(arr[j], arr[j + 1])) &#123; j++; &#125; if (!less(arr[k], arr[j])) break; exch(arr, k, j); k = j; &#125; &#125; public static void main(String[] args) &#123; Integer[] ar = new Integer[]&#123;5, 1, 7, 6, 4, 7, 3&#125;; String[] strings = new String[]&#123;"abcab", "ababc", "acbac"&#125;; sort(strings); sort(ar); System.out.println(isSorted(ar)); show(ar); show(strings); &#125;&#125; 堆排序的关键是： 构造堆，使其有序化。所谓有序化，就是每个节点都大于等于它的两个子节点。有序化的堆为大顶堆，根节点是最大元素； 下沉排序。将根节点与最末端的节点交换，然后将交换后的根节点做下沉操作(sink())，将除了末尾元素的部分构造成新的大顶堆； 堆排序是唯一能够同时最优的利用空间和时间的算法，在最坏的情况下也能保证使用2nlog2n次比较和恒定的额外空间。缺点是数组元素很少和相邻元素做比较，缓存命中率低，无法有效利用缓存。 小结这里主要侧重于对排序算法的熟悉。 附录工具类： 1234567891011121314151617181920212223242526package Algorithms_FOURTH_EDITION.tools;public class SortTool &#123; public static boolean less(Comparable v, Comparable w) &#123; return v.compareTo(w) &lt; 0; &#125; public static &lt;T&gt; void exch(T[] a, int i, int j) &#123; T t = a[i]; a[i] = a[j]; a[j] = t; &#125; public static void show(Comparable[] a) &#123; for (int i = 0; i &lt; a.length; i++) &#123; System.out.println(a[i] + " "); &#125; &#125; public static boolean isSorted(Comparable[] a) &#123; for (int i = 1; i &lt; a.length; i++) if (less(a[i], a[i-1])) return false; return true; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Effective Java》(10):序列化]]></title>
    <url>%2F2018%2F03%2F25%2FEffective_Java_10%2F</url>
    <content type="text"><![CDATA[本篇为《Effective Java》读书笔记系列10(多图预警！)。 笔记]]></content>
      <categories>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Effective Java》(08):异常]]></title>
    <url>%2F2018%2F03%2F24%2FEffective_Java_08%2F</url>
    <content type="text"><![CDATA[本篇为《Effective Java》读书笔记系列08(多图预警！)。 笔记]]></content>
      <categories>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go配置与入门(续)]]></title>
    <url>%2F2018%2F03%2F23%2FGo_Getting_Start02%2F</url>
    <content type="text"><![CDATA[go-plus在go get的时候总是出现很多问题，且每次启动都会弹出各种提示；本地的Go语言版本过低，需要升级；homebrew运行brew update如同假死。为了解决这些问题，开启了一上午的折腾。 卸载Go原本电脑上Go的版本低于1.5，我们知道1.5后Go通过自举已经将源码改成Go实现，所以更新Go已经成为迫切的需求。 了解到升级Go的最好方式是卸载了之前版本再安装，所以本人按照官方给予的方式进行卸载，首先删除/usr/local/go，进而再移除/etc/paths.d/go文件，环境变量写在在~/.bash_profile文件中，因为是为了更新所以没有更改这个配置文件的内容。 使用Homebrew因为之前安装不少软件都是通过Homebrew管理，使用简单方便，适用版本切换，所以原本打算使用它来安装Go，但是在本人的电脑上，Homebrew只能安装1.6版本的Go，这个版本不能解决go get fails with unrecognized import path “context”的问题，brew update假死，于是尝试更换成镜像源，方法如下： 替换源 –&gt; cd “$(brew –repo)”git remote set-url origin git://mirrors.ustc.edu.cn/brew.git 替换homebrew-core源 –&gt; cd “$(brew –repo)/Library/Taps/homebrew/homebrew-core”git remote set-url origin git://mirrors.ustc.edu.cn/homebrew-core.git 可惜仍然没有作用(换了另外的源也没作用)。 官网下载安装见The Go Programming Language官网。安装完成后，可以运行go env查看环境变量，如果之前没有设置环境变量，这里放出本人的配置： 123export GOPATH="/Users/yin/go"export GOBIN=$GOPATH/binexport PATH=$PATH:$GOBIN go get等价于从远程下载包然后执行go install。 go get失败解决办法golang.org/x/… 相当于github.com/golang/.. 所以在出现unrecognized import path “golang.org/x/tools/…”的问题时，可以相应的在GitHub上找“github.com/golang/tools/…”对应的文件。具体做法： 123$ mkdir -p $GOPATH/src/golang.org/x$ cd $GOPATH/src/golang.org/x$ git clone https://github.com/golang/tools.git 总之，通过此方法，缺啥补啥。最后，go install执行相关模块，例如： 1234$ go install golang.org/x/tools/cmd/goimports$ go install golang.org/x/tools/cmd/vet$ go install golang.org/x/tools/cmd/oracle$ go install golang.org/x/tools/cmd/godoc go-plus每次新启动就会检查更新，本人将time-out的时间设为了0。 参考How to identify which goimports go-plus is running? 无法安装sha3包 使用gopm代替go get 解决go包卡慢的问题，没试过。 GOROOT，GOPATH，GOBIN，project目录]]></content>
      <categories>
        <category>入门</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Effective Java》(07):通用程序设计]]></title>
    <url>%2F2018%2F03%2F23%2FEffective_Java_07%2F</url>
    <content type="text"><![CDATA[本篇为《Effective Java》读书笔记系列07(多图预警！)。 笔记]]></content>
      <categories>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Effective Java》(06):方法]]></title>
    <url>%2F2018%2F03%2F22%2FEffective_Java_06%2F</url>
    <content type="text"><![CDATA[本篇为《Effective Java》读书笔记系列06(多图预警！)。 笔记]]></content>
      <categories>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Effective Java》(05):枚举和注解]]></title>
    <url>%2F2018%2F03%2F21%2FEffective_Java_05%2F</url>
    <content type="text"><![CDATA[本篇为《Effective Java》读书笔记系列05(多图预警！)。 笔记]]></content>
      <categories>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Effective Java》(04):泛型]]></title>
    <url>%2F2018%2F03%2F20%2FEffective_Java_04%2F</url>
    <content type="text"><![CDATA[本篇为《Effective Java》读书笔记系列04(多图预警！)。 笔记 补充条目29首先考虑这样一种情形:123456789101112131415public class Favorites &#123; private Map&lt;String, Object&gt; fav = new HashMap&lt;&gt;(); public void putFavorite(String s, Object o) &#123; fav.put(s, o); &#125; public Object getFavorite(String s) &#123; return fav.get(s); &#125;&#125;Favorites favorite = new Favorites();Apple apple = new Apple();favorite.putFavorite("喜爱", apple);Apple apple01 = (Apple)favorite.getFavorite("喜爱"); 这个时候需要在最后一行向上转型，而且当出现下面这种情形时： 123Orange orange = new Orange();favorite.putFavorite("喜爱", orange);Apple apple02 = (Apple)favorite.getFavorite("喜爱"); 会出现运行时错误，破坏了Java类型安全。]]></content>
      <categories>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Effective Java》(03):类和接口]]></title>
    <url>%2F2018%2F03%2F19%2FEffective_Java_03%2F</url>
    <content type="text"><![CDATA[本篇为《Effective Java》读书笔记系列03(多图预警！)。 笔记 补充条目13再一次提到了前面关于clone()的内容，放代码以窥之： 1234567891011121314151617181920public class Clone_Array &#123; Apple[] a = new Apple[]&#123;new Apple()&#125;; Apple[] b = a.clone(); public static void main(String[] args) &#123; Clone_Array ca = new Clone_Array(); ca.b[0].o.a = 7; System.out.println(ca.a[0].o.a); &#125;&#125;class Apple &#123; int a = 1; int b = 2; Orange o = new Orange();&#125;class Orange &#123; int a = 3; int b = 4;&#125; 从这段代码输出为7，可以看出：1.第三行克隆语句不需要强制转换；2.Apple并不需要实现Cloneable接口；3.当深层次修改数组a(也就是修改数组a中索引为0的元素内引用的Orange对象的成员变量a)，克隆数组b中的相应数据仍然更改了。也就是单纯的clone仍然是浅拷贝。看下面代码： 1234567891011121314151617181920212223242526public class Clone_Array &#123; private static final Apple[] a = new Apple[]&#123;new Apple()&#125;; public static final Apple[] values() &#123; return a.clone(); &#125; static Apple[] getA() &#123; return a; &#125; public static void main(String[] args) &#123; Apple newApple = new Apple(); newApple.o.a = 7; Apple[] b = values(); b[0] = newApple; System.out.println(b[0].o.a); System.out.println(getA()[0].o.a); &#125;&#125;class Apple &#123; int a = 1; int b = 2; Orange o = new Orange();&#125;class Orange &#123; int a = 3; int b = 4;&#125; 第一行输出为7，第二行输出为3。也就是避免了长度非零的数组可变所带来的安全漏洞。]]></content>
      <categories>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Effective Java》(02):对于所有对象都通用的方法]]></title>
    <url>%2F2018%2F03%2F18%2FEffective_Java_02%2F</url>
    <content type="text"><![CDATA[本篇为《Effective Java》读书笔记系列02(多图预警！)。 笔记 补充条目11书中介绍了从Java1.5发行版开始，在数组上调用clone返回的数组，其编译时类型与被克隆数组的类型相同，也就是一般情况调用super.clone()需要转型。Object.clone()是特殊的，实现上也不是纯的Java代码。clone的原理可以想象成拿到this引用再通过反射去找对象实例的所有字段，然后逐一拷贝。(参考RednaxelaFX的答案)； 条目12Comparable和Comparator有所区别，在本人分析TreeMap源码的时候，两个交杂出现，前者需要实现类在内部实现compareTo()方法(内部比较器)，而后者多是将实现类放置于策略模式中(外部比较器)；]]></content>
      <categories>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go配置与入门]]></title>
    <url>%2F2018%2F03%2F17%2FGo_Getting_Start%2F</url>
    <content type="text"><![CDATA[Let us go！ 配置在官网下载pkg后就可以进行安装(在最新版本中GOPATH进行了默认配置)。 官方配置方法：SettingGOPATH。 网上GOBIN与PATH配置方法：Golang在Mac OS上的环境配置&amp;&amp;Go 语言之Mac环境配置。 GOBIN配置好后，在所配置的目录下会生成编译好后的文件，该文件可直接执行。 PATH配置好后，可以在任意目录下执行GOBIN配置的目录下文件。 go build &amp; go install见“go build” and “go install”&amp;&amp;What is the difference between build and install in Go?。前者用实际例子比较了两者的区别，后者则给出了他对这两个命令的偏好并给出了偏好的原因。 语法入门看完这一篇算是对语法有了基本熟悉：给 Java 程序员写的 Go 语言入门。 亦或是这一篇：从Java到Golang快速入门。 实战问题 os可以通过变量Args来获取命令参数，os.Args返回一个字符串数组，其中第一个参数就是执行文件本身。 方法调用的问题、struct实例的问题：Go 方法调用与接口 安装Atom上的Go插件时，可以先在GitHub下载，然后进入该文件夹，执行命令行命令npm install，Atom上的Go插件就安装好了。]]></content>
      <categories>
        <category>入门</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Effective Java》(01):创建和销毁对象]]></title>
    <url>%2F2018%2F03%2F17%2FEffective_Java_01%2F</url>
    <content type="text"><![CDATA[本篇为《Effective Java》读书笔记系列01(多图预警！)。 笔记 补充关于条目6本条说到内存泄漏另一个常见来源是缓存。一种解决方案是用WeakHashmap代表缓存。JDK1.2后将引用分为四种：强、软、弱、虚。这里软引用指向的对象会在内存不足的时候被回收，进而解决一部分OOM问题，如果这次回收还是没有足够内存，才会抛出内存溢出异常；弱引用强度更弱，只能活到下一次垃圾回收之前，无论内存是否足够；虚引用是幽灵引用，不能通过它取得一个对象实例，不过被它引用的对象在被回收时能产生一个系统通知。]]></content>
      <categories>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[职责链模式]]></title>
    <url>%2F2018%2F02%2F08%2FChain_of_Resp_Pat%2F</url>
    <content type="text"><![CDATA[“从小，在家中总是处在食物链顶端。” 被处理类试想有这样一个问题，父亲去超市买了两个水果，分别是苹果和橘子，为了不浪费，这些水果需要被由小孩、母亲和父亲组成的家庭吃掉。先来构造水果类： 123interface Fruit06 &#123; String getColor();&#125; 继续构造苹果和橘子： 1234567891011121314151617class Apple06 implements Fruit06 &#123; private String color = "red"; @Override public String getColor() &#123; return color; &#125;&#125;class Orange06 implements Fruit06 &#123; private String color = "orange"; @Override public String getColor() &#123; return color; &#125;&#125; 将水果包装进一个Thing类方便处理： 12345678910class Thing &#123; private Fruit06 f; public Thing(Fruit06 f) &#123; this.f = f; &#125; public Fruit06 getF() &#123; return f; &#125;&#125; 抽象的“职责”类水果买到家，先看孩子吃不吃，孩子不吃再看妈妈吃不吃，妈妈如果也不吃，最后由爸爸无条件吃光。 构造一个抽象类： 12345678910111213141516171819202122232425262728293031323334353637abstract class SendToMember &#123; private String name; private SendToMember next; public SendToMember(String name) &#123; this.name = name; &#125; public SendToMember setNext(SendToMember next) &#123; this.next = next; return next; &#125; public final void sendToMember(Thing thing) &#123; if (resolve(thing)) &#123; done(thing); &#125; else if (next != null) &#123; next.sendToMember(thing); &#125; else &#123; fail(thing); &#125; &#125; @Override public String toString() &#123; return "[" + name + "]"; &#125; protected abstract boolean resolve(Thing thing); protected void done(Thing thing) &#123; System.out.println("被" + this + "吃掉"); &#125; protected void fail(Thing thing) &#123; System.out.println("不能被吃掉"); &#125;&#125; 可以把一条职责链当成一条链表，链表上的每一个node都是拥有不同“职责”的节点，而这些节点都继承于抽象类SendToMember。在SendToMember中，resolve方法交给继承类去实现，也恰恰是各个节点的resolve方法不同，才赋予它们不同的“职责”。 具体的“职责”类在本例中，会出现三种“职责”，一种是厌食(不吃)，一种是偏食(选择性的吃)以及通食(什么都吃)。 厌食： 1234567891011class NoEat extends SendToMember &#123; public NoEat(String name) &#123; super(name); &#125; @Override protected boolean resolve(Thing thing) &#123; return false; &#125;&#125; 偏食： 123456789101112131415161718class LimitEat extends SendToMember &#123; private String limit; public LimitEat(String name, String limit) &#123; super(name); this.limit = limit; &#125; @Override protected boolean resolve(Thing thing) &#123; if (thing.getF().getColor() == limit) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 通食： 12345678910class AllEat extends SendToMember &#123; public AllEat(String name) &#123; super(name); &#125; @Override protected boolean resolve(Thing thing) &#123; return true; &#125;&#125; 上面的代码中厌食的resolve方法都反回false，偏食有选择的返回true，而通食无论遇到哪种水果都是返回true。 测试用例123456789public static void main(String[] args) &#123; SendToMember child = new NoEat("Child"); SendToMember mother = new LimitEat("Mother", "red"); SendToMember father = new AllEat("Father"); child.setNext(mother).setNext(father); child.sendToMember(new Thing(new Orange06())); child.sendToMember(new Thing(new Apple06()));&#125; 小孩爱吃糖不爱吃水果，什么水果都无法吸引他；母亲喜欢吃红色的水果，觉得吃啥补啥，越吃脸越红彤彤，美美美；父亲节约无忌口，不吃觉得浪费，做家庭的“光盘”捍卫者。 设计模式的原则迪米特法则、开闭原则等。水果类作为对象，并不需要关心到底是谁吃掉了它们，而且在该设计模式下程序很容易得到扩展，比如家里来了客人，可以动态改变职责链。 参考资料图解设计模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>职责链模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Spring Boot中使用AOP]]></title>
    <url>%2F2017%2F12%2F01%2FSpringBoot%2F</url>
    <content type="text"><![CDATA[一个Spring Boot中使用AOP的例子。 准备活动在pom.xml文件中添加： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 新建一个controller： 1234567891011121314@RestControllerpublic class TestAopController &#123; @Timer @GetMapping("/testaop") public String testAop() &#123;// try &#123;// Thread.sleep(5000);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; return "testAop"; &#125;&#125; Timer是自定义的一个注解，虽然是自定义，但是可以通过@Pointcut捕获。 实现AOP相关类具体代码如下： 123456789101112131415161718192021222324252627@Aspect@Componentpublic class AspectTest &#123; long start;// ThreadLocal&lt;Long&gt; beginTime = new ThreadLocal&lt;&gt;(); //定义切点 @Pointcut("@annotation(com.cg.springbootdemo.annotation.Timer)") public void timer()&#123;&#125; //在方法执行前执行 @Before("timer()") public void before() &#123; start = currentTimeMillis();// beginTime.set(System.currentTimeMillis()); System.out.println("start: " + start); &#125; //在方法执行后执行 @After("timer()") public void after() &#123; long now = System.currentTimeMillis(); System.out.println("now: " + now);// System.out.println(now - beginTime.get()); System.out.println(now - start); &#125;&#125; 注意上面代码的具体细节，比如@Before中参数写法。 小结实现起来确实轻快方便。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FabFilter Pro-Q 2的使用]]></title>
    <url>%2F2017%2F10%2F01%2FFabfilter_Tutorial%2F</url>
    <content type="text"><![CDATA[这一篇主要讲FabFilter Pro-Q 2的使用。 Overview FabFilter Pro-Q 2的界面简单而直观，交互式EQ显示界面填充整个插件窗，并且可以让你用鼠标创建和调整EQ频段。当你创建和选择频段时，频段控制控件就会出现，浮现在显示界面上，位于所选频段下方。通过该控件，你可以改变当前的所选EQ频段的设置。底部栏提供的属性包括处理模式（零延迟、自然相位、线性相位），通道模式（立体声或M/S），频谱分析仪设置，全局旁路，相位反转，自动增益，增益比例和输出电平／左右相位。 交互式EQ显示界面交互式EQ显示界面一目了然，可以让你轻松地创建和编辑EQ频段。 频段控制控件EQ显示界面下面的控件会调整显示界面中当前所选EQ频段的参数。 处理模式FabFilter Pro-Q &lt;sup&gt;2&lt;/sup&gt;可以在零延迟模式，自然相位模式或线性相位模式下工作。 通道模式每个EQ频段都可以在两个立体声通道上工作，也可以在单个通道上工作。底部栏中的“通道模式”按钮在L/R和M/S处理之间切换。 频谱分析仪和EQ Match通过分析仪按钮，您可以启用或禁用pre-EQ，post-EQ和side-chain信号的实时频谱分析仪，您可以自定义分析仪设置。 通过相同的设置面板，您还可以访问EQ Match模式，这样可以让你匹配到从side-chain分析而来的频谱。 输出选项在底部栏的最右侧，你可以对整个插件进行旁通，反转输出相位，启用或禁用自动增益，显示/隐藏输出测量表，更改总体增益比例并调整输出电平/左右相位。 调整大小和全屏模式使用底部栏右侧的“调整大小”按钮，你可以选择所需的界面大小。此外，使用右上角的全屏按钮，你可以进入全屏模式，该模式可以使Pro-Q&lt;sup&gt;2&lt;/sup&gt;填充整个屏幕。 钢琴显示界面使用钢琴显示按钮，您可以在正常频率刻度和钢琴键盘显示界面之间切换，通过它可以轻松量化频段。 MIDI学习MIDI学习可让您轻松地将任何MIDI控制器与任何插件参数相关联。 预设按钮, undo, A/B, help使用预设按钮，你可以轻松浏览出厂预设或保存您自己的设置，以便你可以在其他歌曲中重复使用。插件界面顶部的“撤消”，“重做”，“A/B”和“复制”按钮使你能够撤消更改并在插件的不同状态之间切换。最后，帮助菜单提供了产品帮助和版本信息。 旋钮使用大圆形旋钮可轻松控制FabFilter Pro-Q 2的参数。当你将鼠标光标移动到表示可以调整它们的时候，它们将高亮。当你将鼠标光标移动到旋钮上时，将弹出参数值显示，显示参数的名称和当前值。 所有旋钮支持四种控制方式： 垂直模式单击旋钮的中心区域，向上或向下拖动以旋转它。旋钮对你拖动的速度做出反应，所以如果你慢慢移动鼠标，则进行精确的调整。 旋转模式抓住旋钮的箭头并拖动它。通过拖动鼠标的同时将鼠标光标移开远离旋钮，你可以进行精确的调整。 鼠标滚轮模式也许最简单的做出调整的方法是将鼠标悬停在旋钮上时使用鼠标滚轮。此模式适用于所有旋钮和可能的摇摄环。（在Windows上，你可能需要首先单击插件界面以确保它是活动窗口。） 文本输入模式双击旋钮，使用键盘输入确切的值。 提示 要将旋钮重置为默认位置，请按住Ctrl键（Windows）或Command键（Mac OS X），然后单击旋钮一次。要在使用垂直拖动模式或鼠标滚轮时微调值，请在拖动或移动时按住Shift键鼠标滚轮。 Pro Tools注意：我们插件的AAX和RTAS/AS版本实现了默认的Pro Tools键盘快捷键，用于微调（Windows上的Ctrl+拖动，Mac OS X上的Command+拖动），重置为默认值（Alt+单击）和链接的更改（Shift+drag）。 在文本输入模式下，有几个方便的快捷方式。使用频率值，你可以键入’1k’将值设置为1000Hz，以及将“A4”设置为440Hz，甚至将字符串设置为“C＃3+13”。使用dB值，你可以键入’2x’获得+6dB（对应于两倍的值）。使用所有值，你也可以输入百分比（例如“50％”将旋钮准确放在中间位置）。 有时，我们插件界面中的旋钮会被关联：通过拖动其中一个时按住Alt键（Pro Tools中的Shift键）来同步调整它们。例如，插头的输出电平和输入电平设置可以通过这种方式同时（相反方向）进行调整。 显示界面和工作流程这个大的显示界面能显示所有的EQ频段，让你轻松创建新的频段并编辑它们。粗黄曲线显示均衡器的总体频率响应。EQ显示界面看起来虽然简单直观，但拥有大量智能和时髦的功能。我们强烈建议你花一些时间阅读此主题，了解其所有选项和快捷方式…这将大大提升你的工作流程！ 创建频段 要添加新的EQ频段，只需点击黄色的整体曲线并将其向上或向下拖动即可。 或者，在显示界面背景上双击或按住Ctrl键单击（Mac OS X上按住Command单击）。 新创建曲线的形状根据你点击的位置自动确定，一旦你习惯了这些方式，这真的很节约你的时间！你需要一个Notch曲线吗？只需双击远处的下方区域即可。 想要低切或高切滤波器？双点击最左边或最右边的区域。搁架滤波器？你可以拖动显示界面左侧或右侧的黄色曲线。 选择频段 单击EQ频段的点或其周围的彩色区域进行选择。 在显示界面背景上单击并拖动以在其周围拖出一个矩形来选择相邻的波段。 按住Ctrl（Mac OS X上使用Command键），然后单击另一个点以选择多个频段。按住Shift键并点击一个点，选择一个连续范围的频段。 通过点击显示背景上的任意位置取消选择所有频段。 调整和编辑频段一旦你选择了一个或多个EQ频段，显示界面将突出显示所选频段的形状。你现在可以通过浮动的频段控件来编辑EQ，但调整它们的最简单方法是简单地拖动它们： 单击并拖动所选点以调整所选频段的频率和增益。如果你选择了多个频段，则所有选定的频段将按照彼此相关的比例进行增益。 拖动鼠标或者当鼠标箭头位于曲线上方时，使用鼠标滚轮可以调整所选频段Q的设置，使其变窄或变宽。或者，在垂直拖动的同时按住Ctrl（Mac OS X上使用Command键）可调整所有选定频段的Q。 按住Shift键的同时拖动以微调所选频段的设置。 在拖动时按住Alt可以限制为水平调整（频率）或垂直调整（增益或Q，取决于Ctrl/Command键）。 按住Alt并单击EQ频段上的点一次以切换其旁路状态（启用或禁用频段）。按住Ctrl+Alt（Mac OS X上的Command+Alt），然后单击EQ频段上的点以更改其形状。按住Alt+Shift并单击EQ频段上的点一次以更改其斜率。 双击一个点，在参数值显示中输入值（使用Tab键依次进入频率，增益和Q），或直接双击参数值显示中的值。请注意，你可以通过各种方式输入频率，例如“100”，“2k”，“A4”或“C#2+13”。 如果右键单击EQ频段的点，将出现带有各种频段设置的弹出式菜单。这是在显示界面上修改EQ频段时的一种快速方法。 注 在Crossover Wrap版本的FL Studio 12中，Alt键是苹果电脑键盘上的Command键，后面亦不再强调这一点。 显示范围注意到显示界面绘制了两个刻度：黄色对应EQ频段曲线和黄色整体曲线。最右边的灰色刻度用于频谱分析仪和输出电平表。在显示界面右上角的黄色刻度顶部，有一个下拉式按钮用于选择显示范围：+/-3dB，6dB，12dB或30dB。当你在显示界面的当前范围之外拖动曲线时，范围将根据需要自动扩展。 水平放大有时，放大特定频率以进行精确的编辑可能会很有用。你可以很容易的通过单击并拖动EQ显示界面底部的频率刻度完成此操作，该频率刻度就在底部栏的上方。您可以执行以下操作： 单击并上下拖动以放大和缩小您点击的频率。 放大时，您也可以左右拖动移动频率刻度。 只需双击缩放刻度就可以返回其默认的完整范围。 提示 在全屏模式下，可以通过界面右上方的按钮进行设置，EQ显示界面将填满整个屏幕，这样可以方便你做出非常精确的调整。请参阅全屏模式并调整大小。 如果要不使用钢琴显示界面来量化频率，只需双击显示屏中的曲线点或“频率”旋钮即可进行EQ控制，并输入像“A4”或“C#2”这样的值。 通过单击帮助菜单中的自动调整显示范围选项，可以关闭显示范围的自动调整。 即使20kHz以上的频率通常听不到，显示界面仍然延伸至30kHz，因此你可以将滤波器设置在此限制以上，而滤波器的左边部分延伸到可听的频谱，还是可以影响听得到的声音。这使你可以根据需要调整均衡器的频率响应。 频段控制当你在交互式EQ显示界面中选择EQ频段时，位于显示界面底部选定频段的正下方的浮动频段控件将自动出现。频段控件显示当前所选EQ频段的设置，并使你能做出精确的调整。 控件上从左向右，依次包含如下设置： 左上方的旁路按钮可以轻松对所选的EQ频段进行旁通。请注意，你也可以通过按住Alt单击显示界面对应的点来旁路某个EQ频段。当EQ频段被旁路时，它在显示界面上会变暗，红灯在旁路按钮中点亮。 形状按钮选择所选波段的滤波器形状：- Bell，传统的参数化EQ波形，这可能是所有波形中最通用的。 - Low Shelf，提升或衰减低频。 - Low Cut，切掉滤波频率以下的声音。 - High Shelf，提升或衰减高频。 - High Cut，切掉滤波频率以上的声音。 - Notch，切掉一小段频谱。 - Band Pass，隔离一段频谱。 - Tilt Shelf，将频谱倾斜一定频率。 注意：你也可以通过在显示界面中按住Ctrl+Alt键点击对应的点（Mac OS X上的Command+Alt）来更改单个EQ频段的形状。 波形参数下面的斜率按钮可以从6dB/octave到96dB/octave来设置滤波器的陡度。在Pro-Q2中，斜率不只适用于通常的低切和高切滤波器，而是适用于所有滤波器形状！如果需要，这可以允许你进行高精度的调节。所以比如，您可以制作超窄的Bell或Notch滤波器或非常陡峭的搁架滤波器。 频率旋钮将所选频段的频率设置在5Hz和30kHz之间。如果选择了多个频段，则它们将一并被调整。 增益旋钮将所选频段的增益设置在-30和+30dB之间。此设置仅用于Bell和搁架滤波器类型。 Q旋钮设置所选频段的带宽，用来扩大或缩小它们。当使用6dB/octave斜率时，Q将不能被调节。 注意：由于在各种EQ插件和科学论文中对Q值有不同的解释，我们选择了值1对应于默认带宽。对于搁架滤波器，选择内部Q值可以使其产生良好的搁架波形的范围。在Pro-Q2中尝试再现另一个EQ插件的滤波器的形状时，请牢记：Q值的解释可能不尽相同。 使用在增益和Q旋钮之间的Gain-Q交互按钮，您可以启用一个微妙的，类似EQ和增益Q的交互效果。当启用时，Q和增益相互影响，就像在模拟混音控制台中经常出现的那种令人愉快的方式一样。从本质上讲，这意味着当增益增加时，Q自动变得更窄一些，另一方面，当Q变窄时，会增加一点增益。 注意：增益和Q相互作用仅适用于Bell波形这一种情况。 Pro-Q2会记住你选择的最后一个Gain-Q交互设置，并将其用于插件的新实例。 上一个和下一个频段按钮可让你按照当前显示的顺序，逐步浏览显示屏中的当前可用频段。在两个按钮之间，显示当前频段的频段号，以帮助你在自动化EQ参数时在宿主中识别该频段。 注意：创建新频段时，它们将被编号为1，2，3等等。但是当你删除某个频段时，其他频段将不会重新编号，以确保当前在你的宿主中所写的自动化剪辑仍然控制着正确的频段。 右上角的删除按钮会删除所选的EQ频段。如果你意外删除了一些频段，你可以使用插件界面顶部的“撤消”按钮轻松恢复。 L/stereo/R按钮控制着哪些声道会受到所选频段的影响。具体请参阅立体声选项。 提示 双击任何旋钮可以直接使用键盘输入值。有关详细信息，请参见旋钮。对于频率旋钮，你可以输入值为“100”或“2k”，也可以输入值为“A4”或“C#2+13”。要隐藏频段控制，只需点击显示背景即可取消选择所有频段。]]></content>
      <categories>
        <category>效果器</category>
      </categories>
      <tags>
        <tag>FabFilter Pro-Q &lt;sup&gt;2&lt;/sup&gt;</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[效果器(二)]]></title>
    <url>%2F2017%2F09%2F25%2FEffect_plugins02%2F</url>
    <content type="text"><![CDATA[本篇主要介绍ValhallaRoom插件EARLY&amp;LATE部分。 EARLY这里的early应该指的是早期反射能量（作者称之为能量），这些声音的特点是比干声要浑浊，但是还是能听清楚内容。 Early Size本人将MIX值调到最满，再将Early Size的旋钮慢慢向右调，发现效果类似音头attack值被调小。 Early Cross立体声的左右通道互相生成早期反射的强度，强度增加回声密度增加。 Mod Rate早期反射叠加声音基本频率变调，以一个平均比例值随机的改变音调。 Mode Depth早起反射叠加声音的深度，参数越高约有空间感，结合Mod Rate一起使用。 Early Send把Early部分的声音发送到Late部分。 Diffusion当参数比较低的时候会明显有颗粒感，当旋钮调大的时候，会有扩散感，增加了回声密度。 LateLate部分主要看后面四个旋钮。 Base Mult调节低频衰减时间，和DECAY一起使用，参数的值乘以DECAY的值就是低频衰减时间。 Bass Xover对Base Mult和DECAY控制的效果进行融合。 High Mult调节高频衰减时间，和DECAY一起使用，参数的值乘以DECAY的值就是高频衰减时间。 High Xover对High Mult和DECAY控制的效果进行融合。 混响中的EARLY &amp; LATE结合效果器(一)介绍了这个插件的大部分旋钮，这里补充一点点混响的个人理解，早期反射，指的是最开始房间反射的一部分声音，这部分声音显然不及原声清楚，但是由于是早期反射，所以还是能听清楚内容。晚期反射，指的是多次反射后残留的声响，这部分能增加混响的空间感，这也是为什么DEPTH的参数反映为EARLY和LATE的一个比例。 了解这么多后应该可以具体实战了。]]></content>
      <categories>
        <category>效果器</category>
      </categories>
      <tags>
        <tag>ValhallaRoom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[效果器(一)]]></title>
    <url>%2F2017%2F09%2F23%2FEffect_plugins01%2F</url>
    <content type="text"><![CDATA[这里说说最近使用的几款效果器插件。 1.FAT FilterFAT Filter是一款免费滤波效果器，它的全部功能只有cut off滤波控制和共鸣参数旋钮，以及一个高通/低通模式的切换开关。虽然仅是一款极简的滤波效果器，但FAT Filter的声音非常具有特点 —— 它自带超级顺滑的模拟滤波效果，并且开发者让它的CPU占用低到了让人发指的地步，这就意味着即使演出中使用也不会有太大的影响。 个人使用后觉得比宿主自带的Fruity Filter要好。 LOW PASS选择LOW PASS后，旋钮在最右边时还原原本的声音，在向左旋转的时候，慢慢过滤高频。 HIGH PASS选择HIGH PASS后，旋钮在最左边时还原原本的声音，在向右旋转的时候，慢慢过滤低频。 RESONANCE共鸣旋钮向右旋后会增减“嗡嗡”的共鸣感。 2.Sausage Fattener该插件的作者很是自信：“ The Sausage Fattener is used by Tiësto, Kaskade, Diplo, Laidback Luke, Chuckie, Sebastian Ingrosso, Dirty South, Hardwell, Angger Dimas, Frank E, Zedd, Lazy Rich, Dimitri Vegas and Like Mike, Marcus Schossow, John Dahlbäck and many other DJ/producers. ” FATNESS 这个旋钮的作用，给我的感觉确实如名字描述的那样：越往右旋，声音越爆炸，就像香肠快要炸裂，但又很爽滑。在旋转这个旋钮的时候，你会发现左边会出现动画效果，如下图所示。 旋钮在左： 旋钮向右旋转： COLOR 大致听了一下旋转前后的效果，感觉是是一种高频滤波的处理。往右旋转，增加高频。 GAIN这是一个响度增益，是可以调节的，用来增加DB值。 3.ValhallaRoomValhallaRoom号称从心理声学的角度设计。界面如下图： 该插件可以调节的旋钮控件比较多，大致可以分成四个部分：总体控制、EARLY&amp;LATE、REVERB MODE和PRESET。 总体控制 MIX主要控制干湿比。 PREDELAY预延迟，表明经过此时间后第一次反射出现。用来模拟房间大小。 DECAY混响衰减时间。 HIGH CUT高切。 DEPTH调节EARLY和LATE的比例。 REVERB MODE点开控件，如图所示： 一共有12种： Large Room大型房间，模仿大房间具有宽广空间的感觉，平滑的“失谐”调制。 Medium Room中型房间，有很多随机调制。 Bright Room明亮的房间，一个丰满，更亮泽超现实混响，具有深厚的调制和相对较为缓慢的起始时间。 Large Chamber大型会议厅。平滑衰减+高回声密度+微妙的失谐调制。 Dark Room小黑屋。蹩脚的早期数字混响和ValhallaRoom现代算法之间的混合体，高频降低，回声密度范围从低到高，同时保持透明度，有着成吨的魔力。 Dark Chamber小黑屋晋级版，更黑更粗。 Dark Space小黑屋终极版，低密度早期反射+深度失调调制。 Nostromo诺斯魔舰,又黑又深+回声混响。低密度早期反射，宽度大。 Narcissus(一个希腊神话人物。这位嫉妒自恋喜欢自己水中的倒影。死后化作一株水仙花)，这个名字用来暗示是Nostrmo的哥们(或许是Valhalla公司自己很喜欢的一个预置)，不同之处是合唱混响+低CPU占用。 Sulaco又暗又丰满，Late Size可以从一个 tight rooms调成一个带宽广回声的房间。 LV-426又黑又深的空间混响，和Nostromo和Narcissus一样宽广，但是有着高初始回声密度。 LV-426具有比其他模式稍慢的起始时间，和高扩散的decays。 Dense Room类似于Large Room，有密集的早期回声，可以从暗调到亮。军鼓神器。 PRESET对应着前面REVERB MODE，该公司提供了相应的预置，一图以蔽之： 该插件剩下的一部分见下篇。]]></content>
      <categories>
        <category>效果器</category>
      </categories>
      <tags>
        <tag>FAT-Filter</tag>
        <tag>Sausage-Fattener</tag>
        <tag>ValhallaRoom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天气app开发简要流程]]></title>
    <url>%2F2015%2F10%2F20%2FWeather_App%2F</url>
    <content type="text"><![CDATA[工程的框架结构如下： activity db model receiver:广播接收器代码 service:存放服务相关代码 util:工具相关的代码 CoolWeatherDB常用的数据库操作封装起来。主要功能是提供六种方法： 存储省份数据，读取省份数据 存储城市数据，读取城市数据 存储县数据，读取县数据 遍历全国省市县数据增加一个HttpUtil类来和服务器交互 这里面的重点是需要添加一个HttpCallbackListener接口。 数据处理类这里再util包中新建一个Utility类 查询全国所有省这个方法是整个app的关键,思路是优先从数据库查询，如果没有查询到再去服务器上查询。123456789101112131415private void queryProvinces() &#123; provinceList = coolWeatherDB.loadProvinces(); if (provinceList.size() &gt; 0) &#123; dataList.clear(); for (Province province : provinceList) &#123; dataList.add(province.getProvinceName()); &#125; adapter.notifyDataSetChanged(); listView.setSelection(0); titleText.setText("中国"); currentLevel = LEVEL_PROVINCE; &#125; else &#123; queryFromServer(null, "province"); &#125; &#125; 适配器的方法中通常有三个参数，第一个参数是上下文，就是当前的Activity, 第二个参数是android sdk中自己内置的一个布局，它里面只有一个TextView，这个参数是表明我们数组中每一条数据的布局是这个view，就是将每一条数据都显示在这个 view上面；第三个参数就是我们要显示的数据。listView会根据这三个参数，遍历adapterData里面的每一条数据，读出一条，显示到第二个参数对应的布局中，这样就形成了我们看到的listView. 在这里有一个notifyDataSetChanged()方法，这个方法的作用就是通知adapter 调用getview来刷新每个Item。（但是notifyDataSetChanged这个不是好办法,也尽量不要用，越多Item越耗时，getView每次取的只是可见的一部分，上千条数据,我觉得还是分页的好）。 还有一个是setSelection()方法。这里先介绍setSelectionFromTop()，它的作用是设置ListView选中的位置，同时在Y轴设置一个偏移量（padding值）。ListView还有一个方法叫setSelection()，传入一个index整型数值，就可以让ListView定位到指定Item的位置。他们的关系大体是：123public void setSelection(int position) &#123; setSelectionFromTop(position, 0); &#125; 在服务器上查询数据新建一个queryFromServer()方法 runOnUiThread()方法runOnUiThread这个会调用父类中的方法：1234567public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123; mHandler.post(action); &#125; else &#123; action.run(); &#125; &#125; 首先判断是否是UI线程，不是的话就post，如果是的话就正常运行该线程。 ProgressDialog()方法该方法是防止假死的，它的执行步骤很重要，基本上遵循：在执行耗时间的操作之前弹出ProgressDialog提示用户，然后开一个新线程，在新线程里执行耗时的操作，执行完毕之后通知主程序将ProgressDialog结束。结束采用progressDialog.dismiss()方法，具体代码如下： 12345private void closeProgressDialog() &#123; if (progressDialog != null) &#123; progressDialog.dismiss(); &#125; &#125; 捕获Back键在这里重写了Back键方法，具体代码如下： 12345678910@Overridepublic void onBackPressed() &#123; if (currentLevel == LEVEL_COUNTY) &#123; queryCities(); &#125; else if (currentLevel == LEVEL_CITY) &#123; queryProvinces(); &#125; else &#123; finish(); &#125; &#125; 更新天气其实很简单，创建一个新的方法queryWeatherInfo(),在该方法中添加更新方法：123String address = "http://www.weather.com.cn/data/cityinfo/" +weatherCode + ".html"; queryFromServer(address, "weatherCode");]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio关联Github]]></title>
    <url>%2F2015%2F10%2F19%2FAndroidStudio_Connect_with_Github%2F</url>
    <content type="text"><![CDATA[翻看了不少帖子，觉得用Android Studio和命令行配置的方式是最简单的方式，同时也方便找到出现的各种问题，比如提交无响应、在拥有两个GitHub账号的电脑提交项目时无权限、提交为空等等问题。更详细的地方可以参考最后提到的链接。 GitHub的设置配置账号首先在Android Studio的设置界面搜索GitHub，然后将GitHub进行配置，如图所示：可以点击旁边的test进行测试。 新建Git仓库在Android Studio菜单栏的VCS下点击Import into Version Control，继续选择第二个选项：这一步旨在设置一个目录为本地仓库。注意，最好设置当前的工程目录为仓库。 选择分享工程到GitHub选项这一步的目的主要是为了Create a repository in bitbucket/github.本人尝试过很多上传文件到GitHub的流程，发现在GitHub上先新建一个远程仓库在后续的创建阶段面临的坑最少（后续有空也可以不断进行其它尝试，这是开放的）。点击上一步中所在选项下的Share Project on GitHub.配置完成后，会发现，push失败了，这是显然的，因为本地库都还没有commit呢。 命令行的操作首先进行如下命令：12$ git add .$ git commit -m "Initial commit" 如果接下来直接push到远程仓库仍然后报有关denied的错误，这个denied to 指向了我的另一个GitHub账号。在这里我不打算尝试去要就如何在两个号中进行切换。首先，继续修改文件：1$ vim .git/config 将中间的相关行，改为https://username@github.com/username/StickyScroll.git，然后继续：12$ git remote add origin https://github.com/username/StickyScroll.git$ git push -u origin master 此时，完成了上传GitHub的工作。 #.gitignore设置上传的时候还会遇到.gitignore文件产生的一些问题。关于该文件的设置并非有统一的标准，本文最后的参考中有一些经验者的建议。这里需要注意的是，往往生成了.gitignore文件后不能过滤文件，需要进行如下操作：123$ git rm -r --cached .$ git add .$ git commit -m "update .gitignore" 附上我的配置：12345678910.gradle/local.properties/.idea/workspace.xml/.idea/libraries.DS_Store/build*.iml.idea.gradlebuild/ 其他方法 可以先使用GitHub创建一个仓库，然后用命令将远程版本库克隆到本地。 1$ git clone https://github.com/username/projectname.git 克隆成功后，将.git、.gitignore、LICENSE和README.md复制到本地上传的仓库。 按照原有的方法进行。 参考 https://www.youtube.com/watch?v=IBEbJUEDWZQ http://stackoverflow.com/questions/28292333/android-studio-how-to-push-to-new-repository .gitignore文件的设置： http://stackoverflow.com/questions/16736856/what-should-be-in-my-gitignore-for-an-android-studio-project http://segmentfault.com/a/1190000000522997 设置多个账号：http://tmyam.github.io/blog/2014/05/07/duo-githubzhang-hu-she-zhi/]]></content>
      <categories>
        <category>安装</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android Studio</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习笔记]]></title>
    <url>%2F2015%2F10%2F15%2FAndroid_notes%2F</url>
    <content type="text"><![CDATA[以下是Android基础知识笔记。 添加ActionBarActionBar的覆盖叠加 问题：当本人添加12&lt;item name=&quot;android:windowActionBarOverlay&quot;&gt;true&lt;/item&gt;&lt;item name=&quot;windowActionBarOverlay&quot;&gt;true&lt;/item&gt; 传入的intent数据不显示。 兼容不同的设备 使用字符串替代资源实现支持多国语言在res/中创建一个额外的values目录，以连字符和ISO国家代码结尾命名。 使用字符资源在xml文件中，通过元素的name属性来引用字符串资源。 在源代码中可以通过R.string.语法来引用字符串资源。 适配不同的屏幕 创建不同的layout 创建不同的bitmap 适配不同的系统版本确保新版本的app支持90%设备的使用。 指定最小的目标API级别 在运行时检查系统版本 管理Activity的生命周期 指定你的程序首次启动的Activity 系统会调用你的app里面的被声明为“launcher”（or”main“）activity中的onCreate()方法。 如果你的程序没有一个activity声明了MAIN action或者LAUNCHERcategory，那么在设备的主界面列表不会呈现你的app图标。 创建一个新的实例 问题：示例代码有问题。 无论如何，系统会调用新的activity实例中的onCreate()方法。 onCreate里面尽量少做事情，避免程序启动太久都看不到界面。 onStart之后开始被用户可见，但是onResume()会迅速执行，使activity停留在Resume()状态。 销毁Activity onDestroy()作为activity要从系统中完全移除的信号。 在onCreate创建了后台线程，以及可能导致内存泄露的资源等，你就应该在onDestroy()时杀死他们。 如果activity只是做简单的逻辑跳转功能，它用来决定跳转到哪的一个activity，那么，在onCreate调用finish方法，会让系统直接跳过其他方法执行onDestroy方法。 暂停与恢复Activity 被其它组件阻塞的情况下，只要activity部分可见，之前的activity一直处在Paused状态。 如果这个activity完全阻塞不可见，它会进入Stop状态。 你应该实现onResume()来初始化那些你在onPause方法中释放掉的组件。 停止与重启Activity初探 出现的一些关键场景： 使用app时，接到一个电话。 启动新的Activity时，当前的Activity会stop，点击back后，第一个会被重启。 app在最近的app菜单，通过手机界面图标启动或者最近的程序中启动。 无论什么原因导致Activity停止，系统总是会在onStop()之前调用onPause方法的。 调用onRestart后会迅速调用onStart和onResume方法。 停止你的activity 避免内存泄露，为什么会内存泄露？因为极端情况下，在不需要activity时会摧毁，摧毁的时候不执行onDestroy方法。所以你需要在onStop()方法中释放资源。 启动与重启你的activity onRestart()方法只是在activity从stopped状态恢复时才会被调用。 因为回到activity之前需要过一段时间，所以onStart()方法是一个比较好的来验证某些系统特性是否可用方法。 重新创建Activity 正常destory的场景： 通过返回按钮或者通过调用finish()。 处于stop状态长期不用。 前台需要更多的系统资源所以关闭后台进程。 如果系统不是主动结束的时候(姑且认为是主动，比如按回按钮，调用finish()等)，系统在销毁之前会保存记录数据（这些数据可能是描述状态用的），这是一个存放在Bunlde对象中的键值对。 重建的时候，可能需要更多的之前状态的信息，首先，为了恢复View的状态，需要为每个View指定一个ID。 这里有一个很”神秘”的回调函数，需要重写。这个方法叫做：onSaveinstanceState()，只要系统离开activity的时候，就会调用这个函数，把信息传递给Bundle对象，当重建的时候，就会调用onRestoreState()方法。 执行onSaveInstanceState()的场景： 跳转到其他activity 点击Home back不会出现这种情况，因为这属于退栈，不会执行该函数，因为通常认为，不会出现这种操作。 恢复数据可以在onCreate()和onRestoreInstanceState()实现，前者总是在后者前执行。 ##使用Fragment建立动态UI Fragment像一个嵌套的activity，拥有自己的布局以及管理自己的生命周期。在activity中可以与其他的fragments生成不同的组合。 创建一个Fragment 拥有生命周期，接受自己的输入事件，运行过程中添加移除。 API版本大于11可以不使用Support Library，也可以使用v7 appcompat library. 和activity的区别之一：你必须重写onCreateView()回调方法，这是唯一一个需要重写的回调方法。 用XML将fragment添加到activity.可以在activity的XML布局文件中定义。 API11版本以下的系统需要activity继承FragmentActivity，而如果版本大于等于11，你可以使用普通的Activity. 如果使用的是v7 appcompat library，需要继承ActionBarActivity，后者是FragmentActivity的一个子类。 如果是使用XML布局文件的方式添加进activity，是不可以动态移除的。如果是要交互的时候把fragment切入与切出，必须在activity启动后添加。 当屏幕是large时，按目录中的large字符来区分。 建立灵活动态的UI 支持范围广泛的屏幕尺寸时，可以重用fragment. FragmentManager可以动态的添加移除fragment. 如果你打算在activity的生命周期中替换fragment，可以在activity运行时动态添加fragment. 使用FragmentManager创建FragmentTransaction对象。 fragment的layout在view中。 添加fragment的具体步骤： 程序中首先确定activity的布局使用了FragmeLayout. 用saveInstanceState != null判断是否存了先前的状态。 在activity的onCreate方法初始化fragment实例。 将activity的Intent参数传给生成的Fragment对象。 将Fragment对象添加到布局文件中。 fragment替换的具体步骤： 将add()替换成replace() 为了使客户能向后导航和撤销，可以用FragmentTRansaction提交前调用addTbackStack()方法，该方法可以传参给这次更改的事务命名（String类型）。 fragments之间的交互： fragment之间不应该直接交互，应该通过关联的activity. 在fragment中定义一个接口，用onAttach()来捕获activity的接口实现。 在fragment中有各种触发事件的类，在这些触发事件的类中调用前面的接口实现。 消息传递给Fragment 使用findFragmentById()获取Fragment的实例。 直接调用Fragment的public方法向Fragment传递消息。(比如一个activity中的另一个Fragment). 数据保存通过activity那一部分可以了解到，onPause()是可以保存一些信息的。但是Android也有一些专门保存数据的方法。 保存到Preference SharedPreferences可以用来保存键值对量级的需求，他可以是私有的，也可以是共享的状态。 不要与preference混淆，后者帮助设置用户配置的页面。 getPreference()方法如果省略了第一个参数（activity的shared preference文件），这个方法会默认检索该activity下的该文件。 如果设置了Context.MODE_PRIVATE，表示这个文件只能这个app访问了。如果输设置为MODE_WORLD_READABLE或者MODE_WORLD_WRITEABLE模式，那么任何app知道文件名就能访问。 写文件，可以通过edit()创建SharedPreferences.Editor来实现。 提交使用apply()方法来替代commit()，可能阻塞UI线程，但是如果不出于线程同步的要求可以使用。 读文件，用getInt()和getString()方法来读取。在读取时，存在一个默认的value作为查找的key不存在时函数的返回值，default. 保存到文件应用场景：网络中交换的数据，图片文件。 两个存储区域： Internal storage:1.总是可用；2.只能被app访问；3.卸载app后相关文件都清楚干净；4.如果你希望不被其它用户以及其它app访问数据，应该保存在这里。 External storage:1.并非总是可用，比如通过USB挂在的时候；2.都可以访问的区域，所以你不能拥有绝对的控制权；3.卸载app时，仅仅会删除external根目录下的相关文件(getExternalFilesDir()). app默认安装在internal storage，但是可以在manifest中声明android:install.ocation属性来安装到external storage中。 获得写External存储权限：在manifest文件中请求权限：&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; 尽量声明读权限，尽管在现有版本并非必要。 getFileDir()代表app的internal目录，getCacheDir()返回缓存目录，并提供了一些方法对文件进行存储。 保存文件到External Storage,因为可能挂在，所以应该先查询状态，用getExternalStorageState()方法来实现。返回的是MEDIA_MOUNTED的话，表示可以读写。 external storage目录对用户和其它app来说有两种： Public files：卸载后应该保留。特定方法getExternalStoragePublicDirectory()方法实现，有两个可指定的参数分别是DIRECTORY_MUSIC以及DIRECTORY_PICTURES. Private files:卸载后应该随之删除。 应该手动删除所有通过getCacheDir()方式创建的缓存文件。 保存到数据库相较于前两种存储方法，数据库方便存储结构化的数据。大多数都有APIs封装好了。 由于保存的区域默认是私有的，所以android会保存db到你的程序private的空间上。 通过实现BaseColumns接口，可帮助您的数据库与 Android 框架协调工作。 要使用SQLiteOpenHelper，需要创建一个替代onCreate()、onUpgrade()和 onOpen()回调方法的子类。也可以通过版本号结合onDowngrade()来更新数据库。 通过将一个ContentValues对象传递至insert()将数据插入数据库。 要从数据库中读取信息，需使用query()方法，查询使用Cursor对象来返回。 与其它应用交互Intent的发送 一个Intent可以显示的指明需要启动的模块，也可以隐式的指明处理那种类型的操作。 带有action的intent能使当前app跳转到其他app。有的时候你并不知道对方组件的名字，这个时候可以使用隐式的intent. 例如：Intent callIntent = new Intent(Intent.ACTION_DIAL, number)样式。 如果没有用Uri，则可以使用setType()方法来指定intent附带的数据类型。 在API Level 14以上可以使用intent for Calendar. 设􏰠MIME type 􏱊为􏱒􏲱􏱛哪􏱰activity􏰔􏰙应该􏳝􏳞这􏰩intent. 应该处罚intent之前验证是否有App接受这个intent,如果没有app接收，那么app会crash. 要确认可以安全的使用这个intent，需要使用queryIntentActivities()获得一个能接收的list，然后通过数组的大小来查看是不是为空。 通过前面的步骤后，最后一步，启动app，运行startActivity(intent). Intent过滤你的app如果需要在别人分享时出现在待选对话框，那么你的app应该能接收ACTION_SEND的Intent. 必须定义好action和data，如果activity中的intent filter满足以下对象的标准，那么就可以： Action，在intent filt用指定它的值，值为字符串。这些值都是已经定义好了的。 Data，可以是多个属性。 Category，一般不怎么用得到，都有一个默认值，这主要是和用户的手势以及启动位置有关。 如果出现了能响应ACTION_SEND和ACTION_SENDTO两种“name”，那么你必须用两个filter来分开表示。 获取action，并且读取intent的内容。方法是getIntent(). 可以在任何生命周期使用getIntent()，但是最好是在onCreat()和onStart()执行。 返回Result，使用setResult(),并且总是指定result code.通常是RESULT_OK或者RESULT_CANCELED. 探究碎片动态添加碎片实现一个例子，用两个fragment对activity进行分屏，左边的fragment上面有一个按钮，通过按下这个按钮，将右边的fragment进行替换。 事实上，这个按钮还是注册在activity上面的，按照书中所说，动态加载fragment需要5步： 创建碎片实例； 获得fragmentManager对象； 用这个对象开启一个事务； 通过这个事务的replace()方法替换实例； 提交事务； 通过这个实验，产生了疑问，fragment到底是替换还是覆盖？？因为替换为第三个fragment后，出现了一个现象，那就是前一个fragment的一部分图片仍然显示，背景颜色也是原有颜色。后来将新的fragment的颜色改为了黄色，这个时候才没有出现前一个fragment.如图所示： . 碎片中模拟返回栈在前面的例子中，如果按下back键程序会直接退出。添加生成的事务的方法addTobackStack(null); 但是我在我的模拟器上试验没有成功。 碎片的生命周期 运行状态碎片可见，相关联的活动处于运行状态，则该碎片处于运行状态。 暂停状态当一个活动进入暂停状态，他所关联的所见碎片都会进入暂停状态。 停止状态当一个活动进入停止状态时，关联的碎片都进入到了停止状态，或者通过remove()和replace()方法将碎片移除，然后在事务提交之前调用addTobackStack()方法，也会进入停止状态。 销毁状态如果关联的activity销毁了，name这些碎片也销毁。如果在事务提交之前没有调用addToBackStack()，也会进入到销毁状态。 详解广播机制 标准广播 有序广播 接受广播 在代码中注册，动态注册 在AndroidManifest.xml中注册，静态注册 动态注册的广播接收器都要取消注册 访问一些关键信息需要在配置文件中声明才可以 静态注册的缺点是程序启动了才能收到广播，这样不能进行一些接受操作，比如要实现开机自启动 内容提供器内容提供器主要用于在不同的应用程序之间实现数据共享的功能，允许一个程序访问另一个程序中的数据，同时能保证数据的安全性。 一种是现有的内容提供器 一种是自己创建的内容提供器 具体操作有一套现有的APIs，充分利用了ContentResolve类 探究服务适合于去执行不需要和用户交互而且要长期运行的任务。服务不是运行在一个独立的进程当中的，而是依赖于创建服务时所在的应用程序进程，所以程序进程被杀掉了，那么该进程的服务也会停止。 多线程 用Runnable()方法启动线程的方式是：new Thread(yourThread).start() Android不允许在子线程对UI进行操作 解析异步消息处理机制的四个方法 Message：可以携带少量消息，有what字段，arg1，arg2还有obj… Handler：处理和发送消息 MessageQueue：消息队列，每个线程只会有一个MessageQueue对象 Looper：进行无限循环，去发现并取出MessageQueue中的消息 AsyncTask： 服务基本用法 onCreate():在服务创建时调用 onStartCommand():在每次服务启动时调用，一旦启动就立即执行操作的话，可以使用这个 onDestroy():在服务销毁的时候调用 服务需要在AndroidManifest.xml中注册才能生效，四大组件都需要这样 启动服务 启动服务很简单，只要配合好Intent就行了，类似启动另一个Activity，但是这里使用startService()停止服务： 同样的，如果停止服务，使用stopService()。服务也可以自己停下来，只要在自身任何位置调用stopSelf()方法就可以停止这个服务。 onCreate和onStartCommand的区别？？我觉得类似Activity中的onCreate和onStart.如果没有创讲过服务，那么两者都要执行。而服务创建好后，多次点击启动的那个button，只执行后者了 服务是在活动里启动的，但是启动了服务后，活动与服务基本就没什么关系了。当我把Activity destroy以后，具体看图（服务1）：以及图（服务2）：从图（服务00）和图（服务01）可以看出，后台中还有一个服务在跑，中间其实经过了一次小小的重新创建，process曾经变为了0，为了证实这一点，可以看图（服务3）和图（服务03）的结果，图（服务3）如下：图（服务4）： 你会发现，当我关掉Activity后，onCreate()又执行了一次。 网络技术WebView的用法首先研究基本的语法，在layout中加入一个WebView的控件，这个很容易，其次是在设置文件中添加一个permission权限，来访问网络功能，接下来主要分析一下activity中的代码：12345678910webView = (WebView)findViewById(R.id.web_view); webView.getSettings().setJavaScriptEnabled(true); webView.setWebViewClient(new WebViewClient()&#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; view.loadUrl(url); return true; &#125; &#125;); webView.loadUrl("http://www.baidu.com"); 这这几行代码中，setJavaScriptEnabled()使WebView支持JavaScript脚本。 webView.loadUrl(“http://www.baidu.com&quot;);使得立即加载百度首页页面。 这里使用WebViewClient的作用是希望目标页面能在WebView直接显示，而不需要打开其它的浏览器，具体的做法是把方法的返回值设为true.当然，前面会运用view.loadUrl(url)来让函数传入参数后再加载新的网页。 使用HttpURLConnection这里举一个例子，用一个Button控件来发送请求，然后通过HTTP协议接收目标网站响应的内容，并呈现在界面上。这里主要关注sendRequestWithHttpURLConnection()方法：12345678910111213141516171819202122232425262728293031323334private void sendRequestWithHttpURLConnection()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; HttpURLConnection connection = null; try &#123; URL url = new URL("http://www.baidu.com"); connection = (HttpURLConnection) url.openConnection();￼ connection.setRequestMethod("GET"); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); InputStream in = connection.getInputStream(); //下面对获取到的输入流进行读取 BufferedReader reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine()) != null) &#123; response.append(line); &#125; Message message = new Message(); message.what = SHOW_RESPONSE; //将服务器返回的结果存放到Message中 message.obj = response.toString(); handler.sendMessage(message); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (connection != null) &#123; connection.disconnect(); &#125; &#125; &#125; &#125;).start(); &#125; 现在来分析一下这段代码： openConnection():用来获得connection实例 setRequestMethod():设置请求方法，通常有post和get setConnectTimeout()和setReadTimeout():分别设置链接超时和读取超时 getInputStream():获取服务器返回的输入流后面就是对输入流进行读取了，然后就是把返回的信息保存在Message实例中 使用HttpClientAndroid中另一种发送请求的方式是采用HttpClient.但是这种方法主要是在Android api9以下采用，Apache公司维护它的热情也不高。 解析XML格式数据网络传输时最常用的格式有两种，分别是XML和JSON. Pull解析方式在书上，作者采用了Apache服务器，这里我们简单的实用Django自带的服务器进行测试。 在Django工程目录下新建一个static文件夹，然后在该文件夹下新建一个get_data.xml，填写XML格式的内容：1234567891011121314151617&lt;apps&gt; &lt;app&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;Google Maps&lt;/name&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/app&gt; &lt;app&gt; &lt;id&gt;2&lt;/id&gt; &lt;name&gt;Chrome&lt;/name&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/app&gt; &lt;app&gt; &lt;id&gt;3&lt;/id&gt; &lt;name&gt;Google Play&lt;/name&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/app&gt;&lt;/apps&gt; 浏览器显示如图所示（Safari呈现）： 这里我们继续使用HttpURLConnection的那个项目开发，重点关注XML的解析。 在genymotion中指向localhost的地址不是10.0.2.2，而是10.0.3.2… 在原有的代码中，我们获得了一个叫response的String对象，然后将该对象传入一个叫做parseXMLWithPull()的方法中，用该方法来解析XML文件。 我们具体来看parseXMLWithPull()方法是如何来解析的： XmlPullParserFactory:这个类用于创建XmlPull解析器 XmlPullParser:这是一个定义解析功能的接口，通过多态，和1中的类一起产生一个XmlPullParser的对象 setInput()方法：将获得的Xml数据设置到2中产生的对象，以进行解析。 getEventType():获得解析事件，一些基本的事件如下： START_DOCUMENT:判断事件为文档开始事件 END_DOCUMENT:判断事件为文档结束事件 START_TAG:标签文件开始事件 END_TAG:标签文件结束事件 TEXT:文本事件 解析JSON格式数据JSON的优点是体积小，省流量，但是缺点是语义性差。 这里简单说说使用GSON来解析数据。 首先安装GSON插件，如图所示： 如果是单个GSON数据，可以有如下示例： 12Gson gson = new Gson();Person person = gson.fromJson(jsonData, Person.class); 如果是一个GSON数组，可以有如下示例： 1List&lt;Person&gt; people = gson.fromJson(jsonData, new TypeToken&lt;List&lt;Person&gt;&gt;() &#123;&#125;.getType()); 这样就生成了对象的一个List了。 参考pull的详细原理：http://www.android100.org/html/201406/07/20575.htmlGSON简单示例：http://blog.csdn.net/dakaring/article/details/46300963]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT CHEAT SHEET翻译]]></title>
    <url>%2F2015%2F09%2F05%2FGIT_CHEAT_SHEET%2F</url>
    <content type="text"><![CDATA[本人翻译自速查表，通过该文档快速学习Git。 Git是开源分布式版本控制系统，可以帮助您在笔记本电脑或台式电脑上使用GitHub。该速查表总结了常用的Git命令并进行说明，以便快速参考。 安装Git GitHub提供桌面客户端，它包括了拥有最常见存储库操作的图形用户界面，以及针一个能对高级场景自动更新的Git命令行版本。 GitHub for Windows https://windows.github.com GitHub for mac https://mac.github.com Linux和POSIX系统的Git发行版可在官方Git SCM网站上找到。 Git for All platforms http://git-scm.com 配置工具 配置所有本地存储库的用户信息 1$ git config --global user.name "[name]" 设置您要附加到提交事务的名称1$ git config --global user.email "[email address]" 设置您要附加到您的提交事务的电子邮件1$ git config --global color.ui auto 使命令行输出加上有用颜色 创建仓库 开启一个新的仓库或者从已有的URL获取一个 1$ git init [project-name] 用特定的名字命名并创建一个本地的仓库1$ git clone [url] 下载项目及其整个版本的历史记录 变更 复习编辑和制作一个commit事务的命令 1$ git status 列出要提交的所有新的或被修改的文件1$ git diff 显示未添加进stage区的文件前后差异1$ git add [file] 把文件进行快照，为版本控制做准备1$ git diff --staged 显示stage区和最后一个文件版本之间的文件差异1$ git reset [file] 使文件移除stage区，但保留其内容1$ git commit -m "[descriptive message]" 在版本历史记录中永久记录文件快照 群体变更 对一系列commits以及完整的合并进行命名 1$ git branch 在当前的仓库中列出所有的本地分支1$ git branch [branch-name] 创建一个新的分支1$ git checkout [branch-name] 切换到指定的分支并更新工作目录1$ git merge [branch] 合并特定的分支历史记录到当前的分支中1$ git branch -d [branch-name] 删除特定的分支 重构文件 重新定位和删除版本文件 1$ git rm [file] 从工作目录删除文件，并暂存(staged)删除这个动作1$ git rm --cached [file] 从版本控制中删除文件，但在本地保留文件1$ git mv [file-original] [file-renamed] 更改文件名并准备提交 停止追踪 排除临时文件和路径 123*.logbuild/temp-* 名为.gitignore的文本文件可以停止追踪与指定的文件相匹配的文件和路径 1$ git ls-files --other --ignored --exclude-standard 将工程中被限定的文件列出 保留片段 搁置并恢复不完整的更改 1$ git stash 暂时存储所有修改过的被追踪的文件1$ git stash pop 恢复最近的stashed的文件1git stash list 列出所有stashed变更列表1$ git stash drop 丢弃最近被stash的变更 回顾历史 浏览并检查项目文件的演进 1$ git log 列出当前分支的历史版本1$ git log --follow [file] 列出指明的文件的历史版本，包括更改过名称的。1$ git diff [first-branch]...[second-branch] 展示两个分支间的不同1$ git show [commit] 输出特定提交的元数据和内容更改的地方 退回提交 擦出错误并更换历史记录 1$ git reset [commit] 退回[commit]之后的所有命令，保存本地的改变1$ git reset --hard [commit] 将所有历史记录和更改丢弃回特定的某个提交 同步更改 注册一个仓库的bookmark并交换版本历史记录 1$ git fetch [bookmark] 从这个仓库的bookmark下载所有的历史记录 1$ git merge [bookmark]/[branch] 合并当前的bookmark的分支到当前的本地分支1$ git push [alias][branch] 将所有本地分支提交上传到GitHub1$ git pull 下载bookmark历史记录并整合更改 不定时补充备注： 工作区clean不是指的工作区清空，而是指checkout的版本没有变动的地方。 git rm –cached [file] 如果the following file has staged content different from both the file and the HEAD 就会出错。 使用git stash pop后，stage区之前有被提交的，也被清空，统一回到add前的状态。也就是这个时候，git diff –staged不会有反应。 在本地新建一个分支：git branch newBranch //////切换到你的新分支: git checkout newBranch //////将新分支发布在github上：git push origin newBranch //////在本地删除一个分支：git branch -d newBranch //////在github远程端删除一个分支：git push origin :newBranch (分支名前的冒号代表删除)/git push origin –delete newBranch (注意删除远程分支后，如果有对应的本地分支，本地分支并不会同步删除！) 相关链接：stash用法：http://www.cnblogs.com/craftor/archive/2012/11/04/2754149.htmlGit参考手册：http://gitref.org/zh/]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发一款方言输入法Android App(四)]]></title>
    <url>%2F2015%2F08%2F30%2F%E6%96%B9%E8%A8%80App04%2F</url>
    <content type="text"><![CDATA[这里再展示一下总的领域模型UML类图： 通过前三篇，将本人此次开发的一些中间环节进行了一番小记。实际的开发过程并不顺利。 七月十号左右开始决定写写输入法，因为对它的机制也很感兴趣的； 七月十二号左右参考相关源码以及谷歌官方api，进行键盘布局的编写，当然也有多篇布局的相关博客，比如：http://blog.csdn.net/hfsu0419/article/details/7924673 等。InputMethodService进行初探。大多数的输入法都遵守大的android框架，流程处理机制也大致相同； 七月十六号开始涉及各功能模块如keboardswitch类等，后来遇到一些问题，主要是配置xml出错； 这个时候在网上找单词和词语的素材，为了进行很好的编辑对其进行文本预处理； 八月十号到八月十五号开始对输入法的算法进行编写，例如候选字的处理，联想词的处理，但实际效果很不理想，算法设计得很粗鄙。增加了长按后出现小视图的效果，使得一些特有功能能够应用，比如数学符号的输入，方言输入； 八月二十号左右参考一些项目，发现一般的输入法都添加了震动和音效的功能，遂添加，同时在fragment中尝试添加ListPreference试图增加小功能，例如改变输入法的字体颜色(后来取消了该功能)； 八月二十一号对UI进行了编辑，选取了一组很炫酷的素材，使得是如法看 起来美观大气； 八月二十二号左右大体完成，整款软件只在小米4上进行了测试。虽然整个 实现功能并不复杂，在输入上由于算法的不足使得用户体验不佳，但是，一般在聊天时能打常用的方言短句，还算满足了我的需求； 效果展示这里就展示几张： No.1: No.2: No.3: 小结后续我将添加远程数据库的支持，同时，优化算法，添加多个拼音连续输入，我在思考能不能制作一款输出纯图形图像的输入法，并且尝试将这款输入法的app(如上图No.3)制作成一款IM的可能。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发一款方言输入法Android App(三)]]></title>
    <url>%2F2015%2F08%2F28%2F%E6%96%B9%E8%A8%80App03%2F</url>
    <content type="text"><![CDATA[候选栏实现设计的候选栏每页只显示6个候选字，如果某一个拼音所对应的候选字过多，本文设计了翻页操作，先计算候选字要显示的页数，核心代码如下：1234private int getPageCount() &#123; return (int) Math.ceil(words.length() / ContainerView.MAX_CANDIDATE_COUNT) + 1;&#125; 其中MAX_CANDIDATE_COUNT 设置为6; 当然还有个技术难点就是对候选栏中确定的汉字的选取，在选取的时候会出现背景高亮，这里的代码如下：1234567891011121314int action = me.getAction(); int x = (int) me.getX(); int y = (int) me.getY(); switch (action) &#123; case MotionEvent.ACTION_DOWN: case MotionEvent.ACTION_MOVE: updateHighlight(x, y); break; case MotionEvent.ACTION_UP: if (updateHighlight(x, y)) &#123; pickHighlighted(); &#125; break; &#125; 候选字查找实现候选字查找的活动图是这样的： 当在文本框中输入拼音文本的时候，在候选栏会出现候选字(当然还有联想词)。本软件配备了字库文件，存储在res/raw路径下。如何对她们进行读取是一个难点。首先我在百度文库中下载了一些词典文件，然后为了方便编辑可以对他们进行一个预处理。我认为把字库弄成一排一个字或词的形式比较好，这样方便读取和显示出字和词的行数。编写函数DictionaryLoader用来加载文件。通过一个InputStream对象获取文件的内容，可以得到一个字符串。为了准确规范的读入设置了根据UTF-8编码读入文件内容。具体可以查询InputStreamReader类。然后可以在PinyinDictionary类中通过刚刚提到的DictionaryLoader类的静态方法getString()读取txt文本中的信息。接下来对读取的信息进行处理：123456str = lines.split("\n"); for (int i = 0; i &lt; 404; i++) &#123; tem = str[i].split("\\."); pinyin[i] = tem[0]; hanzi[i] = tem[1]; &#125; 如上可见，读入的文本被处理为数组，然后每一数组的值又分成两部分，拼音和汉字部分。 接下来从字库匹配汉字。ComposingText就是输入时带下划线的文本，他并不直接输入到文本框中，但是可以通过获取他（这里输入是拼音）然后来查找满足输入的汉字，具体考一下语句判断：12pinyin[i].indexOf(s) == 0c += hanzi[i]; 此语句会将满足输入部分的所有字词以字符c的形式保存。 同理，在联想词的处理上也可以用同样的方法，但是由于时间紧的关系，我写的算法并不好，也就是当输入一个字，比如“阿”，会出现“阿斗”“阿飞”等等等等，但是如果我的词组是三个字组成，在敲击的时候是无法一次输入这三个字的，所以，我就取舍了以下都换成二元词组。每次输入一个字，如果有联想词保证能有意义的输入，而不是只能看输入后就跳过了。这是算法设计的缺陷，还需改进。具体代码如下，将满足的词组全部都一次存入lianxiang中：123456789public String getFollowingWords(char c) &#123; String lianxiang = ""; for (int i = 0; i &lt; MAX_SIZE; i++) &#123; if (c == first[i]) &#123; lianxiang += following[i]; &#125; &#125;return lianxiang;&#125; 候选词的处理体现了本软件的主要算法。 震动和音效实现在AndroidManifest.xml文件中先对VIBRATE的请求进行注册。在具体实现时，只需要将这个震动音效类实例化后，并且在输入法创建成功初始化后，通过在相应类的设置就能具体实现按键的震动和音效。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发一款方言输入法Android App(二)]]></title>
    <url>%2F2015%2F08%2F28%2F%E6%96%B9%E8%A8%80App02%2F</url>
    <content type="text"><![CDATA[上一篇主要提出了这款app的基本需求。接下来就是按照这个需求进行设计了。 消息传递要想设计一个输入法，必须知道，在输入法中按下一个按键之后，究竟发生了什么，由于中文输入比英文复杂，且具有代表性，这里用一个简单的输入的活动图进行说明： 当键入字母后，会通过方法进行判断当前的键盘是不是中文键盘，如果是，会把键入的信息添加到一个StringBuilder的实例composingText中，然后在字典中查找相应的汉字，然后在候选栏显示，然后是进行选字，选完字后，还会在候选栏中出现联想字，然后你可以继续选择，完成一次输入。在英文键盘和符号键盘中输入时，没有候选栏，直接提交。 输入法的初始化了解了输入法基本的消息传递机制后，就可以开始具体的编写，首先进行的是输入法的初始化。输入法的初始化不同于一般的Android app.Android系统有它特有的输入法框架IMF，它给出了输入法必须的API.该框架的类也是各种让人眼花缭乱，我着重关心InputMethodService类，这也是初始化输入法的地方，显然，这个类是一个Service，需要在AndroidManifest.xml中使用android:permission声明所需要的服务，这里指的是BIND_INPUT_METHOD，这是api要求的。输入法启动了InputMethodService,执行onCreate()进行相关类的初始化，onCreateInputView()创建键盘视图，onCreateCandidateView创建候选栏视图。onCreate()代码：12345678public void onCreate() &#123; super.onCreate(); mKeyboardSwitch = new ImeKeyboardSwitch(this, R.xml.pinyin); mEditor = new PinyinEditor(); mWordDictionary = new PinyinDictionary(this); mPinyinPhrase = new PinyinPhrase(this); effect = new ExtraEffect(this);&#125; onCreateInputView()代码：123456public View onCreateInputView() &#123; inputView = (ImeKeyboardView) getLayoutInflater().inflate( R.layout.keyboardview, null); inputView.setOnKeyboardActionListener(this); return inputView;&#125; onCreateCandidateView代码：123456public View onCreateCandidatesView() &#123; container = (Container) getLayoutInflater().inflate(R.layout.container, null); container.setCandidateViewListener(this); return container; &#125; 以上就是初始化的主要代码。 键盘布局的实现在Android输入法开发过程中，输入法的键盘布局的详细设计是通过xml文件的内容描述来完成的，键盘xml文件是储存在res/xml路径中。本文设计的输入法一共有三类键盘，中文键盘、英文键盘和符号键盘。在设计这些键盘时，首先定义键盘的相关属性，然后只需在完成键盘按键的位置和Unicode值的说明，然后加上按键的标签即可。键盘属性包括如下部分： xmlns:android定义键盘视图的命名空间； android:keyWidth=&quot;10%p&quot;定义按键宽度，这里一个普通按键是10%； android:horizontalGap=&quot;0px&quot;定义键盘水平间隔距离，绝对值； android:verticalGap=&quot;0px&quot;定义键盘垂直间隔距离，绝对值； android:keyHeight=&quot;@dimen/key_height&quot;定义按键高度； 这部分完成后就要分别定义每个按键的属性，主要包括android:codes和 android:keyLabel，根据Google Android官方API说明，前者是按键的unicode值，而后者是按键的文本标签。同时在row中开始和结尾都要使用android:keyEdgeFlags来进行左右对齐调整。如英文键盘按键q的完整说明是：12&lt;Keyandroid:codes="113" android:keyLabel="q" android:keyEdgeFlags="left"/&gt; 在这里还要说明一下，android:popupKeyboard表示长按按键后弹出的键盘，布局文件也在res/xml下，在这里实现相关键盘键盘定义。比如我的中文键盘中：123&lt;Key android:keyLabel="瓜" android:keyOutputText="瓜娃子" android:keyEdgeFlags="left" /&gt; 虽然本软件的要切换的键盘视图比较多，而且有很多长按的弹出视图，但是基本上都是通过以上方法进行布局。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发一款方言输入法Android App(一)]]></title>
    <url>%2F2015%2F08%2F27%2F%E6%96%B9%E8%A8%80App01%2F</url>
    <content type="text"><![CDATA[需求我想要写一款输入法app。 这款app不会上传用户隐私； 适配本人特别想输入的一些字符(比如无限大等基本的数学符号)； 适配本人在输入文字时的定式语句，这些语句基于方言，不易拼写或具有近似发音； UML用例图系统功能清单如图所示： 我希望能尽量简洁高效的完成基本的功能。 通过几篇的博客，来记录整个app开发的一些关键点，算是一次小小的复盘。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android MVC MVP和MVVM]]></title>
    <url>%2F2015%2F08%2F24%2FAndroid_MVP%2F</url>
    <content type="text"><![CDATA[这是一个关于MVC、MVP、MVVM三种软件架构模式的笔记。 MVC简单的来说，最基本的定义如下： M:Model层，数据模型。 V:View层，界面。 C:Controller层，逻辑。 将数据在界面上展示出来，就是一个最简单的应用场景。MVC的主要特点：M和V可以直接通信，通常是单向的。 MVP和MVC最大的区别是，首先，中间层的名字用Controller变成Presenter，这里简称为P层，P层和V层、P层和M层是可以双向通信的，但是V和M彼此再也不直接来电了。 MVVMMVVM的理解可以在MVP上更进一层，P层被一个叫ViewModel层的中间层取代。View层和ViewModel层从双向通信变成双向绑定。 MVVM实践我始终认为，架构啊模式啊是一种思想，严格抠字眼意义不大。其实熟悉常用的设计模式，那么MVC和MVP并不难理解，而MVVM，由于在最近一次Android大会中，Google推出了Data Binding框架，这里打算按照相关教程，跑跑例子。 简单的例子Model层Model层用一个User类代表：1234567891011121314151617public class User &#123; private String firstName; private String lastName; public User(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125;&#125; View层View层用一个布局文件activity_main.xml表示：12345678&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;/data&gt; &lt;!--原先的根节点（Root Element）--&gt; &lt;LinearLayout&gt; .... &lt;/LinearLayout&gt;&lt;/layout&gt; 我个人认为data元素就相当于接口，View层则布局在元素里面。 data可以这么写：123&lt;data&gt; &lt;variable name="user" type="com.xxx.User" /&gt;&lt;/data&gt; 也可以这么写：1234&lt;data&gt; &lt;import type="com.xxx.User" /&gt; &lt;variable name="user" type="User" /&gt;&lt;/data&gt; 在布局中，就可以调用变量：1234&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.lastName&#125;" /&gt; VM层具体的代码如下：12345678@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityBasicBinding binding = DataBindingUtil.setContentView( this, R.layout.activity_main); User user = new User("X", "L"); binding.setUser(user);&#125; 这样就实现了绑定。基本完成了一个MVVM实例。MVVM其实也有争论，关于它的不同见解也可以见参考中所列的文章。 Google出的Databinding框架还有很多高阶的使用方法，未完待续，慢慢填坑… 参考： Android MVP模式 简单易懂的介绍方式 MVC，MVP 和 MVVM 的图示 AndroidDataBinding-MVVM模式 Repository that showcases 3 Android app architectures: “Standard Android”, MVP and MVVM 被误解的 MVC 和被神化的 MVVM 精通Android Data Binding]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3Sum]]></title>
    <url>%2F2015%2F08%2F22%2FLeetCode_3Sum%2F</url>
    <content type="text"><![CDATA[问题描述 Given an array S of n integers, are there elements a , b , c in S such that a + b + c = 0? Note: Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c) The solution set must not contain duplicate triplets. For example, given array S = {-1 0 1 2 -1 -4},A solution set is: (-1, 0, 1) (-1, -1, 2) 这题的意思是，在给出的整数数组中，找出三个元素的和为0的集合，集合中的元素是升序排列，同时集合中不能包含重复的解。 解法前面我们解过一个Two Sum的问题，这里虽说是三个数了，但是乍一看会让人去思考：是不是可以用和Two Sum问题相似的解法？我想可以尝试一下，大概思路即：在数组中取一个元素，求它的反，然后在剩下的元素中找到两个数，它们的和正好和前面求得的反相等。值得注意的地方： 这一题最终不是求元素的索引。 这一题不用考虑是否有多个相同的元素，因为最终的集合不包含重复的解。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution&#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result = new List&lt;List&lt;Integer&gt;&gt;(); if(nums.length &lt; 3) return result; Arrays.sort(nums); for(int i = 0;i &lt; nums.length;i++) &#123; if(nums[i]&gt;0) break; if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; int begin = i+1,end = nums.length - 1; while(begin &lt; end) &#123; int sum = nums[i] + nums[begin] + nums[end]; if(sum == 0) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(nums[i]); list.add(nums[begin]); list.add(nums[end]); result.add(list); begin++; end--; while(begin &lt; end &amp;&amp; nums[begin] == nums[begin-1]) begin++; while(begin &lt; end &amp;&amp; nums[end] == nums[end+1]) end--; &#125; else if(sum &gt; 0) end--; else begin++; &#125; &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>3Sum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two Sum]]></title>
    <url>%2F2015%2F08%2F22%2FLeetCode_Two_Sum%2F</url>
    <content type="text"><![CDATA[问题描述 Given an array of integers, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Input: numbers={2, 7, 11, 15}, target=9 Output: index1=1, index2=2 这一题大致是说在给定的整数数组中找到两个整数，使得两个数字的和等于一个给定的数，这里假定问题存在一个解。 解法暴力求解的时间复杂度过高，当然还有采用先排序再两边夹逼的方法，但是目前比较好的方法是采用Hash表。 Hash表解此题的核心思想是用key存储原数组中的值，用value存储原数组值的索引。 此题假设有一个解，但是并非不能有重复的数出现，比如提供的数组为[5,3,3,5,7]，如果target是6，那么如何处理重复的数就派生出两种稍微不同的解法。 哈希(1)事先存好，存好后如果出现相同的数会覆盖前面出现的数，这里不妨采用HashMap。下面手写实现的类： 1234567891011121314151617181920212223class Solution&#123; pubic int[] twoSum(int[] numbers,int target ) &#123; int[] res = new int[2]; Map map = new HashMap(); for(int i = 0; i &lt; numbers.length; i++ ) &#123; map.put(numbers[i],i); &#125; for(int i = 0;i &lt; numbers.length; i++) &#123; int gap = target - numbers[i]; if (map.get(gap) != null &amp;&amp; (int)map.get(gap) != i) &#123; res[0] = i+1; res[1] = (int)map.get(gap) + 1; break; &#125; &#125; return res; &#125;&#125; 在这段代码中，首先将提供的数组全部存储在容器中，这里如果存在相同的数，会覆盖。由于题目假设只有一个解，那么重复的数字不会超过2。if语句中!= i，是因为自己总是会和自己相等。 编写测试用例：1234567891011import java.io.*;import java.util.*;public class Test&#123; public static void main(String[] args) &#123; Solution a = Solution(); int[] number1 = new int[]&#123;5,3,3,5,7&#125;; System.out.println(Arrays.toString(a.twoSum(number1,6))); &#125;&#125; 输出[2,3]。 哈希(2)判断当前数组的元素是不是已经存在在Hash容器中，没有的时候，就把当前的添加进去。前面介绍的第一种Hash方法是后面的把前面覆盖，这一种是前面出现了后面就不添加了，同样能解决重复问题,这里我另用hashtable。 1234567891011121314151617181920class Solution&#123; public int[] twoSum(int[] numbers,int target) &#123; int[] res = new int[2]; Hashtable&lt;Integer,Integer&gt; ta = new Hashtable&lt;Integer,Integer&gt;(); for(int i = 0;i &lt; numbers.length;i++) &#123; if(ta.get(target-numbers[i]) != null &amp;&amp; ta.get(target-numbers[i]) &lt; i) &#123; res[0] = ta.get(target-numbers[i]) + 1; res[1] = i + 1; break; &#125; if(ta.get(numbers[i]) == null) ta.put(numbers[i],i); &#125; return res; &#125;&#125; 小结以上算法的时间复杂度是O(n)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Two Sum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小工具]]></title>
    <url>%2F2015%2F08%2F15%2FTools%2F</url>
    <content type="text"><![CDATA[这里做一个小工具一个集合，防止电脑崩坏后的不知所措。 新建文件菜单新建文件菜单(New File)：一款可以在Mac上右键创建文件的应用； 七牛图床失效解决方法七牛云测试域名失效导致图片外链失效的解决办法 修改Mac键盘映射Seil：用来修改Mac键盘的键映射； 下载地址：我是地址 痛点：本人使用Mac原生输入法，平时切换中英文输入法直接按caps lock就可以，但是在Intellij Idea中切入英文伴随的全部是大写，而通常本人打大写字母使用的是shift，遂通过Seil这款小工具更改键盘映射； 使用方法见链接：我是链接 防止他人网站挂掉还是简单记录一下步骤： 首先，打开系统偏好设置－键盘－键盘－修饰键，将Caps Lock键设为“无操作”； 然后，下载Seil后将Caps Lock键映射为Key Code 80（或者其他一个不存在的键，80代表F19）； 最后，打开系统偏好设置－键盘－快捷键－输入源，将切换到上一个输入法的快捷键设置为F19（通过选择后按一下Caps Lock）； svg-term：将asciinema动画转换为svgsvg-term-cli 安装方法和基本使用格式如下： 12$ npm install -g svg-term-cli # 安装方法$ svg-term --cast 113643 --out examples/parrot.svg # 基本格式 详细了解可查看帮助文档：svg-term –help Vultr搭建SS主要步骤：地址01 或 地址02 在CentOS安装git：yum install git BBR加速：https://wangejiba.com/3842.html BBR安装主要命令： 1wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh tldr用于查询Linux命令的用法，但查询到的内容进行了简化，并添加了示例。 安装方法(全局安装)：npm install -g tldr 使用方法：tldr [命令]]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>未完待续</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom 上手教程]]></title>
    <url>%2F2015%2F07%2F25%2FAtom_Getting_Start%2F</url>
    <content type="text"><![CDATA[Atom是一款Github官方推出的文本编辑器，号称是“A hackable text editor for the 21st Century”。下面翻译自官方文档。 基本术语首先，让我们熟悉一下在本手册中使用到的一些术语。 BufferBuffer表示Atom中一个文件的文本内容。通常情况下它相当于一个文件，但是是Atom存储在内存中的一种文件。举个例子，你可以改变buffer中的文本，这种写入操作不会作用于相应的磁盘文件，除非你进行了保存。 PanePane是Atom中的可视区域，在欢迎界面上你可以看见四个Pane：the tab bar（文件标签栏），the gutter（它包括了行号），the status bar（底部的状态栏），the text editor（文本编辑器）。 命令面板在欢迎界面上，我们介绍一个可能是Atom中最重要的命令，用来呼出命令面板，当当前焦点在编辑窗时，如果你敲击cmd-shift-P，命令面板就会出现。 在Atom中基本所有主要的操作都能通过这种搜索驱动的菜单来完成。不同于通过点击应用菜单来找寻相关操作的方式，你只需要敲击cmd-shift-P就能寻找到相关命令。 你不仅能尽最大可能的看到并快速搜索到数以千计的命令，而且，如果这些命令存在一个相应地快捷键，你也能同时看到他们。这非常棒，因为这意味着你在用这些命令做你感兴趣的事的同时，也一并能学习这些快捷键。 手册余下的部分，我们将试图弄清楚那些不同命令快捷键以及命令面板中搜索出的命令。 偏好设置在设置界面上，Atom有很多偏好设置选项，你可以对它们进行修改。 这包括了修改色彩框架或主题，具体为如何处理自动换行，字体设置，tab的大小，滚动速度等等。你也能用这个界面安装新的软件包和主题，这些在“Atom Packages”中介绍。 为了打开设置界面，你可以去菜单栏的Atom下Prefernces菜单项。你也可以搜索Settings View:open或者快捷键cmd-,。 更改彩色主题设置界面还能让你为Atom更改彩色主题。Atom拥有四个UI彩色主题，分别名为Atom Dark，Atom Light，One Dark和One Light，同时还包括八个不同的语法彩色主题。你可以点击设置界面侧边栏的“Themes”菜单项来更改当前主题或者安装新的主题。 UI主题改变了UI元素的颜色，诸如标签和树结构的视图。而语法主题改变了载入在编辑器中的文本的语法高亮模式。我们只要简单选择下拉栏中的不同选项就能改变主题。 Atom.io上有几十个主题，如果你需要一些与众不同，你可以从其中进行选择。在”Style Tweaks”章节中涉及到了定制主题内容，在“Creating a Theme”中涉及到了创建你自己的主题的内容。 SOFT WRAP你也可以用设置界面具体设置你的空白符以及换行偏好。 开启”Soft Tabs”后，当你敲击tab键时会插入空格符来代替实际的tab字符.“Tab Length”指定了插入时会有多少个空格,或者当没有开启”Soft Tabs”时，指定了一个tab表示为多少个空格符。 当在当前窗口单行键入太长时“Soft Wrap”键可以进行换行设置。当soft wrapping未开启时，行将会超出界面的显示边缘，你必须滑动窗口才能看到剩下的部分。如果切换到”Soft Wrap At Preferred Line Length”项，行的字数将在达到80后自动换行，取代原本的显示到窗口的最末端。你也能更改默认的80字数的行距值。 在“Basic Customization”中，我们能了解如何根据不同种类的文件进行不同的换行设置（比如我们想在Markdown文件中进行换行，但是不在代码文件中也这样）。 处在beta期的功能随着Atom的不断发展，偶尔会有一些特性，在作为主要功能面向大众之前作为测试放出，在某些情况下，这些功能是默认关闭的，但是在设置面板中你能尝试将他们打开。 在新的特性推向普通大众之前，这个功能对软件包的开发者是非常有用的，使他们开发的软件包能提前在新特性下工作。当然，如果你只是对这些即将发布的新特性感兴趣，你也可以偶尔尝试这些新的特性。 打开、修改以及存储文件现在看起来你的编辑器已经设置成你所希望的那样，让我们开始打开并且编辑文件。这毕竟是一个文本编辑器最主要的功能，不是么？ 打开文件在Atom中有一些方法来打开文件，你可以选择通过菜单栏中”File&gt;&gt;Open”的方式或者敲击cmd-o的方式在系统对话中选择文件。 以上方法特别适合打开你当前工程中没有的文件，或者因为某些原因从一个新窗口打开文件。 在Atom中打开文件的另一种方式是通过命令行。如果你使用的是Mac，Atom菜单栏有一个命令叫做“Install Shell Commands”，这个命令能在你的Terminal中安装两个新的命令：atom和apm。如果是在Windows和Linux平台上，这两个命令在Atom安装过程中被作为一部分自动生成。你可以通过运行atom命令附带一个或多个文件路径的方式来打开Atom中的文件。 如果你熟悉terminal，或者你平时工作使用terminal多一点，那么这将是一个很棒的工具。你只用运行atom [files]命令就能开始编辑。 编辑以及存储文件编辑文件非常简单。你可以点击并滚动你的鼠标，然后输入更改内容即可。不存在特殊的编辑模式和关键字命令。 你可以通过在菜单栏选择”File&gt;&gt;Save”或者敲击cmd-s的方式来保存文件。你可以选择”Save As”或者敲击cmd-shift-s的方式对当前的编辑器中的内容进行另存为。你可以使用ctrl-shift-s保存Atom中所有打开的文件。 Atom不只能完成单个文件的工作，而你也更倾向于花费更多的时间在包含多个文件的工程项目上。如果要打开一个目录，选择在菜单栏中”File&gt;&gt;Open”然后在弹出的对话框中选择目录。你也可以在当前的Atom窗口中添加目录，可以在菜单栏中选择”File&gt;&gt;Add Project Folder…”或者敲击cmd-shift-o。 你可以通过在atom命令行工具中添加路径的方式来打开任意个数的目录。比如：你可以通过命令atom ./hopes ./dreams 来同时打开hopes和dreams目录。 当你在Atom中打开一个或者多个目录的时候，编辑窗口的左侧会自动得到一个Tree view。 Tree view允许你查看更改你的工程中的文件和目录。通过这个视图，你可以打开、重命名、删除并且新建一个文件。 你可以通过cmd-\或者菜单栏中的“toggle tree view”命令来显示和隐藏Tree view。ctrl-0可以用来设置它的焦点。当Tree view被设置了焦点你就能通过a，m或者delete来添加、移动或者删除文件和文件夹。你也可以在这些文件和文件夹上点击右键来显示更多选项。包括很多本地文件系统中的文件拥有的选项、拷贝文件路径到系统剪切板上等。 在工程中打开文件一旦你在Atom中打开了一个工程，你能很轻松的找到并打开工程中的任何文件。 无论你敲击键盘上的cmd-T或者cmd-P，模糊查询对话空就会呼之欲出。通过敲击文件路径中的任何一部分，你就能在任何工程目录中快速的对文件进行查询。 你也可以使用cmd-B对当前打开的文件进行查找（而不是工程中所有的文件）。这个搜索包括了”buffers”和打开的文件。如果你只想搜索上一次Git提交后新的或者改动的文件，可以通过命令cmd-shift-B来限制范搜索。 模糊查询会通过core.ignoredNames以及fuzzyfinder.ignoredNames配置文件来过滤哪些文件和文件夹能被查找。如果你的工程中有大量的文件你不希望查找，你可以在配置文件中添加关键字和路径。我们会在”Global Configuration Settings”章节中学习更多关于配置文件的操作。但是现在你能在设置界面的Core Settings下简单的设置。 这两个配置文件对关键字进行筛选的功能是由名为minimatch的Node.js库来完成的。你可以在这里阅读更多关于minimatch的内容：https://github.com/isaacs/minimatch 当core.excludeVcsIgnoredPaths选项被选中后，该软件包同样不会显示Git忽略的文件。你能轻易的在设置视图中切换改选项，该选项位于众多选项的最上面。 总结现在你已经基本明白了Atom是什么你需要用Atom做什么。并且，你已经把它安装在了你的操作系统上，可以用它来进行最基本的一些文本操作。 现在你已经准备好开始深入挖掘这个有趣的东西。]]></content>
      <categories>
        <category>文档</category>
      </categories>
      <tags>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django入门(二)]]></title>
    <url>%2F2015%2F07%2F16%2FDjango02%2F</url>
    <content type="text"><![CDATA[模板首先，尝试将前面的静态文件加载到模板里面。 1&lt;img src="&#123;% static "images/rango.jpg" %&#125;" alt="Picture of Rango" /&gt; 添加了这一行，这一行中，应该注意斜线。 模型当创建项目后，Django就会在settings.py添加DATABASES字典。在编写模型文件以后需要同步数据库。这里先运行如下命令： 1$ python manage.py makemigrations 在确认没有报错后，继续运行如下命令： 1$ python manage.py migrate 此步骤将models.py与数据库同步。 增删改查运行在交互式shell环境下： 1$ python manage.py shell 然后就是根据API进行增删改查了。 AdminAdmin方便管理者添加和删除网站的内容，创建超级用户。 通过下面的命令创建超级用户：1$ python manage.py createsuperuser 填写完注册信息后，仍然不能更改数据库中间的信息，这里可以在range/admin.py中添加代码： 1234from django.contrib import adminfrom rango.models import Articleadmin.site.register(Article) 传参访问数据库：在view.py上导入类from rango.models import Article 正则表达式具体参考两个链接：官方文档，REGEX CHEAT SHEET 遇到过的problems patterns()中的’’作用的问题 print __file__的问题 TEMPLATE_DIRS = (TEMPLATE_PATH,)的问题 /rango/about/的问题 ‘rango/index.html’斜杠问题 生产环境部署静态文件 href研究、斜杠研究 static目录里，如果文件不存在或者引用错误的话,控制台将会输出错误. 需实际验证。 models.py文件中不能中文注释…]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django入门(一)]]></title>
    <url>%2F2015%2F07%2F15%2FDjango01%2F</url>
    <content type="text"><![CDATA[这是一个Django入门。 创建项目1$ django-admin.py startproject &lt;文件名&gt; manage.py允许运行内建的Django服务并且可以运行数据库命令。 每个Django应用对应实现的一种功能，你可以针对不同功能创建不同的应用。 运行如下命令：1$ python manage.py startapp rango 生成五个脚本： init.py 可空，表示这是一个python包 models.py 存储数据模型 tests.py 存储测试代码 views.py 处理用户请求和响应 admin.py 向Django注册你的模型 创建视图 从django.http导入HttpResponse对象 创建index视图 视图至少带一个参数，一个HttpRequest对象 最后返回一个HttpResponse对象 URL映射用URL映射上面创建的视图。新建一个urls.py，这个urls.py不同于项目目录中的那一个。12345from django.conf.urls import patterns,urlfrom rango import viewsurlpatterns = patterns('', url(r'^$',views.index,name = 'index')) 在项目目录中的urls.py文件中添加url(r&#39;^rango/&#39;, include(&#39;rango.urls&#39;))，这样就可以访问http://127.0.0.1:8000/rango了。 硬编码问题提供绝对路径是非常不好的，比如：会为将来的移植带来问题。 用静态目录来说明： 在项目目录中创建一个static目录，同时在static创建images目录。 在设置文件settings.py中添加STATIC_URL和STATICFILES_DIRS两个元组。 首先设置：STATIC_PATH = os.path.join(BASE_DIR,’static’) 同时添加：STATIC_URL = ‘/static/‘ # 这样设置可以使用户通过http://127.0.0.1:8000/static/来访问。具体的书写方式可以通过查看文档。 以及： STATICFILES_DIRS = ( STATIC_PATH,)]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo构建web应用]]></title>
    <url>%2F2015%2F04%2F11%2FHexo_Getting_Start%2F</url>
    <content type="text"><![CDATA[使用Hexo主要考虑到如下几点： 主题选择灵活美观； 可将博客托管在GitHub； 正在尝新Atom，相关插件方便推送文章； Geek风格(见仁见智)； 具体的步骤可以参考Hexo官方文档，Hexo的中文文档还是比较完善的，不过在实际安装过程中，还是遇到了一些具体的问题，后面进行说明。 安装Hexo1$ npm install -g hexo-cli 运行以上命令后，务必用hexo -v查看一下hexo版本，起初本人得到的结果是这样的： 接着使用如下命令：1$ npm install hexo --save 再查看文件的版本，就会出现如下图所示： 接着按照官方文档给出的操作：123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 这样Hexo就安装成功了，根据目录的文件生成静态网页：1$ hexo generate 运行本地服务：1$ hexo server 然后就可以打开 http://localhost:4000/ 进行查看。需要停止服务器可以按control+c.由于Hexo3.0以后，不少功能都独立出来了，所以在运行server之前，先在终端输入：1$ npm install hexo-server --save 以上便是我在安装Hexo时的具体步骤，记录了遇到的实际问题。 基本操作1.新建一篇文章：1$ hexo new [layout] &lt;title&gt; 可以单独指定layout，默认采用的是Hexo项目根目录（非主题）下的_config.yml参数，标题含有空格要使用引号括起来。 2.生成静态文件1$ generate 也可以使用hexo g 3.部署网站在根目录的_config.yml中设置：1234deploy: type: git repository: git@github.com:gitbeiyong/gitbeiyong.github.io.git branch: master 然后在命令行中运行如下：12$ npm install hexo-deployer-git --save$ hexo deploy 也可以使用hexo d 4.清除缓存文件1$ hexo clean 这里清除的是db.json和public文件。 以上只列举了本人常用的操作指令，详情请见官方文档指令。 添加功能1.给文章添加目录 在所选主题的文件下找到_partical文件夹，修改该文件夹下article.ejs文件，在&lt;!-- Table of Contents --&gt;后面添加：123456&lt;% if (!index &amp;&amp; post.toc)&#123; %&gt; &lt;div id="toc" class="toc-article"&gt; &lt;strong class="toc-title"&gt;文章目录&lt;/strong&gt; &lt;%- toc(post.content) %&gt; &lt;/div&gt;&lt;% &#125; %&gt; 这样就可以根据标题添加目录。 2.给博客添加“关于” 使用命令：1$ hexo new page about 3.一些杂项 有的时候Mac自动生成的.DS_Store文件很烦人，可以使用rm -fr .DS_Store命令删除之。 CNAME文件放在博客根目录下的source文件夹下。 测试SSH key是否设置正确可以使用命令：1ssh -T git@github.com 在执行 hexo deploy 后,出现 error deployer not found:github 的错误: 1$ npm install hexo-deployer-git --save gitalk相关链接： https://newdee.cf/posts/4da30c7/ https://lefer.cn/posts/46934/ 样式修改： 这个帖子里的实例会出现横线问题，可以通过修改gitalk.css来解决。 https://ryanluoxu.github.io/2017/11/27/Hexo-Next-添加-Gitment-评论系统/ https://www.libinx.com/2017/2017-03-12-hexo-next-beautify/ https://blog.csdn.net/kxp9545/article/details/75194232 修改\themes\next\source\css\ _variables\base.styl文件的$code-foreground和$code-background，可以改变``围出的代码块颜色。 4.相关参考链接 Hexo-NexT配置 MarkDown括号如果出现嵌套怎么办？(可以用%28代替，)可以用%29代替。 站内引用引用站内文章：{% post_link markdown文件名（不要后缀） 文章标题（可选） %}引用YouTube：{% youtube video_id %} Hexo草稿生成草稿： 1$ hexo new draft &lt;title&gt; 发布草稿： 1$ hexo publish [layout] &lt;title&gt; layout指布局，比如draft就是Hexo的一种特殊布局。 参考https://hexo.io/zh-cn/docs/writing.html]]></content>
      <categories>
        <category>安装</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB在OS X下的安装]]></title>
    <url>%2F2014%2F10%2F21%2FMongoDB_Install_for_Mac%2F</url>
    <content type="text"><![CDATA[这里介绍MongoDB在Yosemite上的安装方法。官方文档介绍了两种安装方法，一种是通过Homebrew，另一种是通过下载包文件手动安装。在这里本人采用Homebrew方法。 安装方法1.首先是更新Homebrew套件： 1$ brew update 如果不更新，可能不会安装最新的MongoDB版本，本人在没有更新之前，曾安装过较低版本，后续遇到各种坑。 2.安装MongoDB 1$ brew isntall mongodb 3.启动MongodDB 在启动前，需要建立数据库存放的目录，预设的路径是/data/db，运行下面命令： 123$ mkdir -p /data/db$ mongod —config /usr/local/etc/mongod.conf$ mongod 结果出现如图情况： 继续运行命令： 1$ sudo chown yin /data/db 成功解决问题。 4.指定数据库安装目录 可以把MongoDB的数据库放在指定的目录，比如自己的home目录： 12mkdir -p ~/data/dbmongod --dbpath ~/data/db 遇到的问题 在另一台Mac上安装，还出现了一些错误，http://docs.mongodb.org/manual/tutorial/manage-mongodb-processes/ 中提到了解决办法。]]></content>
      <categories>
        <category>安装</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于多尺度自相似算法]]></title>
    <url>%2F2014%2F08%2F26%2FVarious_Scales_Algo%2F</url>
    <content type="text"><![CDATA[采用多尺度自相似思想形成的算法可以引入到超分辨率相关问题的解决中。 主体思想这类算法通常分为两个部分，一部分属于Classical SR，另一部分属于Example-based SR，通过构造一个框架将它们整合在一起，最终能够有助于单张低分辨率图像到高分辨率图像的恢复。 上图解释了算法的主要原理：在同一张图片下的多个尺度下能够找到外观极其相似的图片快。Input image I中的块能再Various scales of I中的小尺寸图片中找到相似块，相似块能在输入图像中找到母块，因此构成了“低分辨率-高分辨率”的图像对，这就类似基于学习的方法了，再进行传统的图像恢复。 这里再有必要说一说两种方法结合的框架： Classical SR 在图片中(a)就是传统的超分过程，而图片中(b)在单幅图像中模拟的(a)的过程。 运用公式，只要这些patches有重叠的地方，就可以用多个patches来联立方程求解。 Example-based SR 基于例子的超分辨率需要找到高低分辨率的图像对，这种图像对可以在不同尺度的图片中进行寻找。如图所示： 在图中可见I0 的深绿色小块在I-2 找到一个相似块，该块在I0层是一个大的浅绿色方块，那么我们就认定其为需要寻找的example。然后把它贴到需要恢复的图像层中，这个过程类似一个学习的模拟过程，但是实际上不需要学习。 为了尽可能提高精度，在具体实现上还采用了coarse to fine(粗到精)的思想，即先恢复要恢复的第一层I1，然后对错误进行纠正，在这里采用反向投影法，再用此方法恢复I2，如此迭代，最后得到高分辨率图H。 这里给出本人实现的核心部分(采用Matlab代码)，仅供参考： 123456789101112131415161718192021222324252627282930313233343536ImageName=&#123;'Child' 'Oldman' 'Chip'&#125;;ImageName=ImageName&#123;3&#125;;I_small=imread([ImageName '_input.png']);I_paper=imread([ImageName '_paper.png']);alpha=2;N=1;sigma_example=20;sigma_classical=(0.01)^2;if size(I_small,3)==3 I_small = rgb2ycbcr(I_small); Y = double(I_small(:,:,1)); else Y = double(I_small);endlow_size=size(Y);patchsize=[5 5];boundary=floor(patchsize(1)/2);PSF_size=[2*floor(alpha)+1 2*floor(alpha)+1];sigma_PSF=PSF_size(1)/6.4;I = cell(3,1); %假设下采样一层I&#123;2,1&#125; = Y; % 中间层是输入层I&#123;1,1&#125; = imresize(I&#123;2,1&#125;,alpha^(-1)); %下采样后的低尺度图像%%由粗到精的过程m = 3; I_inscale=cell(1,1); W_inscale=cell(1,1); I_cross=cell(1,1); W_cross=cell(1,1);l = 2;[W_inscale&#123;1,1&#125; I_inscale&#123;1,1&#125;]=InScale(I&#123;2&#125;,alpha^(1),boundary,sigma_classical);[W_cross&#123;1,1&#125; I_cross&#123;1,1&#125;]=CrossScale(sigma_PSF,I,boundary,2,3,alpha,sigma_example); 小结此算法并不能还原图像最初包含的真实信息，但确实能在一定程度上增加图像的清晰度，且只需要采样于自身相似结构。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Super Resolution</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyenv的安装和应用]]></title>
    <url>%2F2014%2F07%2F25%2FPyenv_Tutorial%2F</url>
    <content type="text"><![CDATA[简介最近本人需要在python3.X的环境中工作，但是mac自带的python版本是2.X的，由于大部分情况下2.X还是主流，所以也不希望自己的2.X升级成3.X，于是希望在一台机器上包含多个版本的python，pyenv是这样一个python版本管理器。 安装pyenv安装的方法有一些，由于自己的机器上有homebrew，所以使用它来安装pyenv，具体的命令如下：1$ brew install pyenv 完成了pyenv的安装后，还需要在_profile文件中写入数条命令，首先打开该文件： 1$ vi ~/.bash_profile 然后在该文件中写入如下命令：123$ echo 'export PYENV_ROOT="$HOME/.pyenv"' &gt;&gt; ~/.rc$ echo 'export PATH="$PYENV_ROOT/bin:$PATH"' &gt;&gt; ~/.rc$ echo 'eval "$(pyenv init -)"' &gt;&gt; ~/.rc 最后执行命令：1$ exec $SHELL -l 此时pyenv就安装完成了。 安装python先查看可安装的python版本：1pyenv install --list 这里举例子安装python3.4.2，由于pyenv原本的源下载速度很慢，我们可以使用国内的镜像： 1export PYTHON_BUILD_MIRROR_URL=&quot;http://pyenv.qiniudn.com/pythons/&quot; 然后在运行如下命令：1$ pyenv install 3.4.2 安装完成后对数据库进行更新：1$ pyenv rehash 接下来就可以对已安装的python版本进行查询了：1$ pyenv versions 会看到如下显示： 12* system (set by /Users/yin/.pyenv/version) 3.4.2 pyenv的使用这里可以进行两种设置 设置全局版本 使用全局版本的方法是在shell中运行命令：1$ pyenv global 3.4.2 设置局部版本 在这里本人新建了一个文件夹pythonT，进入该文件夹。然后运行：1$ pyenv local 3.4.2 此时运行python命令发现在该文件夹环境下版本是3.4.2当在其它文件夹下运行时是2.7.6（即本人电脑上自带的python版本）。 取消设定在pyenv中local有–unset参数，而global没有该参数。要取消local设定可以使用：1$ pyenv local --unset 使用pyenv-virtualenvpyenv-virtualenv 是pyenv的插件，为pyenv设置的python版本提供隔离的虚拟环境，设置虚拟环境后，在这个目录下面安装的第三方库及修改库搜索路径都不会影响其他环境，相当于一个沙盒环境，互相不影响。 安装过程见：官方说明 具体的使用： 1234$ pyenv virtualenv &lt;version&gt; &lt;name&gt; #初始化环境$ pyenv activate &lt;name&gt; #激活环境$ pyenv deactivate #取消激活环境$ pyenv unistall &lt;name&gt; #删除存在的环境 （生成的环境可以通过 shift-command-G输入~/.pyenv的地址查看。） 补充说明Python 3.3中使用pyenv命令创建的虚拟环境不包含pip，需要手动安装。Python 3.4改进了这一缺陷。 ##发生的问题汇总可能是Mac更新系统的原因，当我在用pyenv安装Python－2.7.5的版本时出现了The Python zlib extension was not compiled. Missing the zlib?.解决的方法有两种： 使用CFLAGS=&quot;-I$(xcrun --show-sdk-path)/usr/include&quot; pyenv install -v 2.7.5 尝试重新安装Xcode command line tools（特别是刚升过级的系统）。 建议选择第二种，具体可以在Apple官网下载对应的版本，因为后面还有不少坑，比如遇到的OS X 10.11 using python-build 20150818问题。可以看看原作者和发现问题人的讨论OS X 10.11 pyenv install. 该项目的Github官方主页为：pyenv的官方主页 。 在具体的处理“坑”的时候，认为显示了隐藏文件可能方便一点，这里提供两个命令：12$ defaults write com.apple.finder AppleShowAllFiles -bool true #开启显示隐藏$ defaults write com.apple.finder AppleShowAllFiles -bool false ＃关闭隐藏 输入后强制重启Finder就可以了。 Mac系统的环境变量，加载顺序为：/etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc /etc/profile和/etc/paths是系统级别的，系统启动就会加载，后面几个是当前用户级的环境变量。后面3个按照从前往后的顺序读取，如果~/.bash_profile文件存在，则后面的几个文件就会被忽略不读了，如果~/.bash_profile文件不存在，才会以此类推读取后面的文件。~/.bashrc没有上述规则，它是bash shell打开的时候载入的。]]></content>
      <categories>
        <category>安装</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pyenv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Java编程风格规范]]></title>
    <url>%2F2014%2F07%2F20%2FGoogle_Java_styleguide%2F</url>
    <content type="text"><![CDATA[编程也需要好的习惯和规范，翻译自《Google Java编程风格指南》(链接见最后)。 源文件基础文件名文件名以最顶层的类名来命名，大小写敏感，文件扩展名为.java. 文件编码源文件编码的格式采用UTF-8. 特殊字符空白字符除了行结束符序列，ASCII水平空格字符（0x20,即空格）是源文件中唯一允许出现的空白字符。也就是说： 其它情况下出现的空白字符都要进行转义； 制表符不用于缩进；特殊转义序列对于具有特殊转义序列的任意字符（\b,\t,\n,\f,\r,\”,\’以及\），我们使用它的转义序列，而不是相应的八进制（比如\012）或Unicode（比如\u000a)转义。非ASCII字符对于剩余的非ASCII字符，是使用实际的Unicode字符（比如∞），还是使用等价的Unicode转义符（比如\u221e），取决于哪个能让代码更易于阅读和理解。 Tip:在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。 源文件结构按顺序地，一个源文件包含： 许可证和版权信息（如有需要） package语句 import语句 一个顶级类（只有一个） 以上每个部分用一个空行隔开。 许可证和版权信息如果一个文件包含许可证和版权信息，那么它应该放在文件的最前面。 package语句package语句不换行，列限制（4.4节）并不适用于package语句。（即package语句写在一行里） import语句import不要使用通配符即，不要出现类似这样的import语句：import java.util.* ; 不要换行import语句不换行，列限制（4.4节）并不适用于import语句。（即每个import语句独立成行） 顺序和间距import语句可以分为以下几组，按照下面的顺序，组各由一个空行分隔： 所有的静态导入独立成组 com.google导入（源文件在com.google包下） 第三方的包，每个顶级包一组，字典序。例如：android,com,junit,org,sun java包导入 javax导入 组内不空行，按字典排序。 类声明只有一个顶级类声明每个顶级类都在一个和它同名的源文件中（当然，包含.java后缀） 例外，package-info.java,该文件中可没有package-info类。 类成员顺序不存在唯一的通用法则，每种类以某种逻辑排列它的成员，维护者应该能解释这种排列逻辑。比如新的方法不应该总是添加在类的最后面，因为这是按照时间顺序而不是某种逻辑来排列的。 tip:永不分离的重载：当一个类有多个构造函数，或者是多个同名方法，它们应该按照顺序出现在一起，中间不要放进其它函数、方法。 格式术语说明：块状结构指的是一个类、方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性的视为块状结构。 大括号使用大括号（即便是可选的）大括号与if、else、for、do、while语句一起使用，即使只有一条语句（或是空），也应该把大括号写上。 非空块：K&amp;R风格对于非空块和块状结构，大括号遵循Kernighan和Ritche风格： 左大括号前不换行 左大括号后换行 右大括号前换行 如果右大括号是一个语句、函数体或类的终止，则右大括号后换行；否则不换行。例如，如果右大括号后面是else或逗号，则不换行。 示例：123456789return new MyClass() &#123; if (condition()) &#123; try &#123; something(); &#125; catch (ProblemException e) &#123; recover(); &#125; &#125;&#125;; 后续给出了enum类的一些例外。 空块：可以用简洁版本一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分（if/else或try/catch/finally），即使大括号内没内容，右大括号也要换行。 示例:1void doNothing() &#123;&#125; 块缩进：2个空格每当开始新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别，缩进级别适用于代码和注释。 一行一个语句每个语句后要换行。 列限制：80或100一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。 例外： 不可能满足列限制的行（例如Javadoc中的一个厂URL，或是一个厂的JSNI方法参考）； package和import语句； 注释中那些可能被剪切并粘贴到shell中的命令行； 自动换行术语说明：line-wrapping指的是一行代码为了避免超出列限制而被分为多行。 很多时候，对于一段代码会有好几种有效地自动换行方式。 Tip:提取方法或局部变量可以在不换行的情况下解决代码过长的问题（合理缩短命名长度）。 从哪断开自动换行的基本准则：更倾向于在更高的语法级别处断开。 在非赋值运算符处断开：在该符号前断开（比如+，它将位于下一行）。这条规则也适用于以下“类运算符”符号，点分隔符（.），类型界限中的&amp;（），catch块中的管道符号（catch (FooException | BarException e)； 在赋值运算符处断开：通常做法是在该符号后断开（比如=，它与前面的内容留在同一行）。这条规则也适用于foreach语句中的分号； 方法名或构造函数名与左括号留在同一行； 逗号（,）与其前面的内容留在同一行； 自动换行时缩进至少+4个空格自动换行时，第一行后的每一行至少比第一行多缩进4个空格（注意：制表符在前面说过了，制表符不用于缩进）。当存在连续自动换行时，缩进可能会多缩进不只4个空格（语法元素存在多级时）。一般而言，两个连续行使用相同的缩进当且仅当他们开始于同级语法元素。 空白垂直空白一下情况需要使用一个空行： 类内连续的成员之间：字段，构造函数，方法，潜入类，静态初始化块，实例初始化块； 例外：两个连续的字段之间的空行是可选的，用于字段的空行主要是用来对字段进行逻辑分组。 在函数内，语句的逻辑分组间使用空行； 类内的第一个成员前或最后一个成员后的空行是可选的（既不鼓励也不反对这样做，视个人喜好而定）； 满足本规范个其它关于空行的要求。 多个连续的空行是允许的，但是没必要这么做（也不鼓励这样做）。 水平空白除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方： 分割任何保留字与紧随其后的左括号（(）（如if、for或catch等） 123for (; ; ) &#123;&#125; 分割任何保留字与其前面的右大括号（}）（如else,catch） 12345try &#123; something(); &#125; catch (ProblemException e) &#123; recover(); &#125; 在任何大括号前（{）。但是有两个例外： @SomeAnnotation({a, b})（不使用空格） String[][] x = foo;（大括号间没有空格，见第八条下面的那点） 任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号： 类型界限中的&amp;（） catch块中的管道符号|（catch (FooException | BarException e)） foreach语句中的分号 在, : ;及右括号（)）后 如果在一条语句后做注释，则双斜杠两遍都需要空格，可以允许多个空格，但是没有必要 类型和变量之间，比如：List list 数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] {5, 6 }都是可以的 这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求 水平对齐：never required属于说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。 这是允许的，但是Google编程风格对此不作要求。 Tip:对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)，这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。 用小括号来限定组：推荐除非认为去掉小括号不会使代码被误解，或者去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。没有理由假设读者能记住整个Java运算符优先级表。 具体结构枚举类枚举常量间用逗号隔开，换行可选。 没有方法和文档的枚举类可写成数组初始化的格式： 1private enum Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125; 由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。 变量声明每次只声明一个变量不要使用组合声明，比如int a, b;。 需要时才声明，并尽快进行初始化不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。 数组数组初始化：可写成块状结构数组初始化可以写成块状结构，比如，下面的写法都是OK的：123456789101112131415161718new int[] &#123; 0, 1, 2, 3&#125;new int[] &#123; 0, 1, 2, 3&#125;new int[] &#123; 0, 1, 2, 3&#125;new int[] &#123;0, 1, 2, 3&#125; 非C风格的数组声明中括号是类型的一部分：String[] args， 而非String args[]。 switch语句术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。 缩进与其它块状结构一致，switch块中的内容缩进为2个空格。 每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。 Fall-through:注释在一个switch块内，每个语句组要么通过break, continue, return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，任何能表达这个意思的注释都是OK的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。示例：1234567891011switch (input) &#123; case 1: case 2: prepareOneOrTwo(); // fall through case 3: handleOneTwoOrThree(); break; default: handleLargeNumber(input);&#125; default的情况要写出来每个switch语句都要包含一个default语句组，即使什么代码都不包含。 注解（Annotations）注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行，因此缩进级别不变。例如：123@Override@Nullablepublic String getNameIfPresent() &#123; ... &#125; 例外：单个的注解可以和签名的第一行出现在同一行。例如：1@Override public int hashCode() &#123; ... &#125; 应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：1@Partial @Mock DataLoader loader; 参数和局部变量注解没有特定规则。 注释块注释风格块注释与其周围的代码在同一缩进级别，以下注释都是OK的：1234/* * This is // And so /* Or you can * okay. // is this. * even do this. */ */ 修饰符类和成员的修饰符如果存在，则按Java语言规范中推荐的顺序出现。1public protected private abstract static final transient volatile synchronized native strictfp 命名约定对所有标识符都有通用的规则标识符只能使用ASCII字母、数字和下划线，字母大小写敏感，因此每一个有效地标识符名称都能匹配正则表达式\w+. 在Google其它编程语言风格中使用的特殊前缀或后缀，如name_，mName，s_name和kName,在Java编程风格中都不再使用。 标识符类型的规则包名包名全部用小写，通过.将各级连在一起，不使用下划线。 类名类型的命名，采用以大写字母开头的大小写字符间隔的方式（UpperCamelCase）。 class命名一般使用名词或名词短语。interface的命名有时也可以使用形容词或形容词短语。annotation没有明确固定的规范。 测试类的命名，应该以它所测试的类的名字为开头，并在最后加上Test结尾。例如：HashTest 、 HashIntegrationTest. 方法名类名都以UpperCamelCase风格编写。 方法名通常是动词或动词短语。 在JUnit的测试方法中，可以使用下划线，用来区分测试逻辑的名字，经常使用如下的结构，例如：testPop_emptyStack.并不存在唯一正确的方式来命名测试方法。 常量名常量是一个静态成员变量，但不是所有的静态成员变量都是常量。在选择使用常量命名规则给变量命名时，你需要明确这个变量是否是常量。例如，如果这个变量的状态可以发生改变，那么这个变量几乎可以肯定不是常量。只是计划不会发生改变的变量不足以成为一个常量。下面是常量和非常量的例子： 1234567891011121314// Constantsstatic final int NUMBER = 5;static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of("Ed", "Ann");static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutablestatic final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;enum SomeEnum &#123; ENUM_CONSTANT &#125;// Not constantsstatic String nonFinal = "non-final";final String nonStatic = "non-static";static final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;();static final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = &#123;"these", "can", "change"&#125;; 这些名词通常是名词短语。 非常量字段名非常量字段名以lowerCamelCase风格编写。 参数应该避免用单个字符命名。 局部变量名局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。 虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。 即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。 类型变量名类型名有两种命名方式：a、单独一个大写字母，有时后面再跟一个数字。（例如，E、T、X、T2）。b、像一般的class命名一样（见5.2.2节），再在最后接一个大写字母。（例如，RequestT、FooBarT）。 编程实践@Override：能用则用只要是合法的，就要把@Override注解给用上。 捕获的异常：不能忽视对捕获的异常不作响应是极少正确的。如果确实是不需要在catch中做任何响应，需要做注释甲乙说明。 例外：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。 12345try &#123; emptyStack.pop(); fail();&#125; catch (NoSuchElementException expected) &#123;&#125; 静态成员：使用类进行调用使用类名调用静态的类成员，而不是具体某个对象或表达式。 Finalizers:禁用极少会去重载Object.finalize. tip:不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。 Javadoc格式一般形式Javadoc块额基本格式如下所示：12345/** * Multiple lines of Javadoc text are written here, * wrapped normally... */public int method(String p1) &#123; ... &#125; 或者是以下单行形式：1/** An especially short bit of Javadoc. */ 基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。 哪里需要使用Javadoc至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外： 例外：不言自明的方法对于简单明显的方法如getFoo，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。 单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。 tip:如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名getCanonicalName， 就不应该忽视文档说明，因为读者很可能不知道词语canonical name指的是什么。 例外：重载如果一个方法重载了超类中的方法，那么Javadoc并非必需的。 可选的Javadoc对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为，那么这个注释应该写成Javadoc，这样更统一更友好。 参考文献 英文版]]></content>
      <categories>
        <category>文档</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2F2014%2F06%2F23%2FPrototype_Pat%2F</url>
    <content type="text"><![CDATA[“你是我，我是你，我是我，你是你。” 这里说的原型模式，指的是对目标对象进行深拷贝，本文采用Java自带的克隆机制来实现。 目标类首先声明个接口： 1interface Fruitprototype extends Cloneable&#123;&#125; 要使用Java自带的克隆机制，必须实现Cloneable这个标记接口。 接着写一个实现类(实例该类就将得到一个要拷贝的目标对象)： 12345678910111213141516171819202122232425class FruitImpl implements Fruitprototype &#123; private String name; private Orangeprototype orange; public FruitImpl(String name, Orangeprototype orange) &#123; this.name = name; this.orange = orange; &#125; public FruitImpl getClone() &#123; FruitImpl fruit = null; try &#123; fruit = (FruitImpl)super.clone(); // 对内部引用对象进行拷贝操作 fruit.orange = this.getOrange().getClone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return fruit; &#125; public Orangeprototype getOrange() &#123; return orange; &#125;&#125; 关键的代码在getClone()中，注释下的语句不能省略，因为clone()本身是浅拷贝，如果orange内也存在引用，则逐级调用。 引用类代码如下： 123456789101112131415161718192021222324252627282930313233343536class Orangeprototype implements Cloneable &#123; private String name; private int id; public Orangeprototype(String name, int id) &#123; this.name = name; this.id = id; &#125; public Orangeprototype getClone() &#123; Orangeprototype orange = null; try &#123; orange = (Orangeprototype) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return orange; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public int getId() &#123; return id; &#125;&#125; 思路和目标类的实现相同。 测试用例12345678public static void main(String[] args) &#123; Orangeprototype orange01 = new Orangeprototype("orange01", 1); Fruitprototype fruit01 = new FruitImpl("fruit01", orange01); Fruitprototype fruit02 = ((FruitImpl) fruit01).getClone(); ((FruitImpl) fruit02).getOrange().setId(02); ((FruitImpl) fruit02).getOrange().setName("orange02"); System.out.println(orange01.getId() + " " + orange01.getName());&#125; 拷贝一份fruit01指向的对象并声明为fruit02，调用fruit02的方法来更改内部字段原本的内容，在这里将内部指向的Orangeprototype对象的id改为了02，name改为了orange02。打印原目标对象内指向的Orangeprototype对象的id和name，仍然是1和orange01，如果将FruitImpl类中注释下的语句删除，则打印的结果是2和orange02。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2014%2F06%2F20%2FSingleton_Pat%2F</url>
    <content type="text"><![CDATA[这里介绍五种单例模式的实现。 饿汉模式单例模式主要有五种，先列出饿汉模式，饿汉，顾名思义，就想快点new出对象。想来，只要把静态变量指向需要new的对象，就能在构造方法执行之前生成： 1234567891011public class Singleton01 &#123; private static Singleton01 singleton = new Singleton01(); private Singleton01() &#123; &#125; public static Singleton01 newInstance() &#123; return singleton; &#125;&#125; 这种模式的特点是，线程安全，资源浪费和加载慢(可能情形)。 内部类懒加载模式饿汉模式不是懒加载，取其优点，可以构造一种内部类懒加载模式，比如把一开始的静态字段放在私有静态内部类中，这样可以保证线程安全： 12345678910111213public class Singleton02 &#123; private static class Singletonolder &#123; private static Singleton02 singleton = new Singleton02(); &#125; private Singleton02() &#123; &#125; public static Singleton02 newInstance() &#123; return Singletonolder.singleton; &#125;&#125; 懒汉模式延迟加载还有另一种形式，被称作懒汉模式。在这种模式中，字段也不和new创建对象的代码捆绑了，为了保证线程安全，将newInstance()用synchronized修饰： 1234567891011121314public class Singleton03 &#123; private static Singleton03 singleton; private Singleton03() &#123; &#125; public synchronized static Singleton03 newInstance() &#123; if (singleton == null) &#123; singleton = new Singleton03(); &#125; return singleton; &#125;&#125; 这种方法的缺点是，每次只有一个线程可以执行newInstance()，而实际上很多时候，可以先判断一下实例是否已经存在，已经存在就没必要调用synchronized修饰的方法了，这样可以大大提高程序的运行成本。 双重检查加锁的懒汉模式承接前面的分析，可以考虑将sychronized放入newInstance()内部，在它之前先判断一下对象是否已经存在： 12345678910111213141516171819public class Singleton04 &#123; private volatile static Singleton04 singleton; private Singleton04() &#123; &#125; public static Singleton04 newInstance() &#123; if (singleton == null) &#123; synchronized (Singleton04.class) &#123; if (singleton == null) &#123; singleton = new Singleton04(); // &#125; &#125; &#125; return singleton; // &#125;&#125; newInstance方法中的代码很容易理解，这里要注意的是，singleton = new Singleton04()这一行代码在具体执行中在底层可能出现指令重排的情况，引用赋值和初始化对象在单线程内重排后并不影响结果，但多线程下，新的线程拿到的singleton引用指向的对象可能并没有完成初始化，所以需要添加volatile关键字。 枚举模式1234567public enum Singleton05 &#123; INSTANCE; public void leaveTheBuilding() &#123; &#125;&#125; 《Effective Java》中在前面章节提到过枚举模式是实现单例的最佳方法，后面章节再次提到过枚举模式，因为它不仅仅简单高效且线程安全，而且在在反序列化的时候，也能保证对象只有一个，不需要额外的处理。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[享元模式]]></title>
    <url>%2F2014%2F06%2F17%2FFlyweight_Pat%2F</url>
    <content type="text"><![CDATA[“有则取出返回，没有则创建添加并返回。” 构造接口和类首先创建水果接口： 123interface FruitFlyweight &#123; void printColor();&#125; 然后创建水果类： 12345678910111213class OrangeFlyweight implements FruitFlyweight &#123; private String color; public OrangeFlyweight(String color) &#123; this.color = color; &#125; @Override public void printColor() &#123; System.out.println(color + " " + this); &#125;&#125; 最后这行打印this的目的是为了在输出时，显示对象的HashCode，进而判断打印的是哪一个对象； 构造工厂构造工厂的过程，揭示了享元模式的基本原理，首先，当我们需要在一个map中取一个value的时候，判断它是否为空，如果不为空，那么就返回，如果为空，那么就创建相应的对象，添加到map中，并返回，在某些场景能很好的节约开销。 代码如下： 12345678910111213class FruitFactoryFlayweight &#123; private static final Map&lt;String, FruitFlyweight&gt; fruitMap = new HashMap&lt;&gt;(); public static FruitFlyweight getFruitflyweight(String color) &#123; FruitFlyweight flyweight = fruitMap.get(color); if (flyweight == null) &#123; flyweight = new OrangeFlyweight(color); fruitMap.put(color, flyweight); &#125; return flyweight; &#125;&#125; 测试用例123456public class FlyweightDemo &#123; public static void main(String[] args) &#123; FruitFactoryFlayweight.getFruitflyweight("Red").printColor(); FruitFactoryFlayweight.getFruitflyweight("Red").printColor(); &#125;&#125; 输出为：1234Red com.cg.OrangeFlyweight@3cd1a2f1Red com.cg.OrangeFlyweight@3cd1a2f1Process finished with exit code 0 原本的map为空，调用getFruitflyweight方法后，会创建水果对象，当再次调用getFruitflyweight时，会反回之前存在的对象。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>享元模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂方法模式]]></title>
    <url>%2F2014%2F06%2F16%2FFactory_Method_Pat%2F</url>
    <content type="text"><![CDATA[“每个类型的对象都有它们自己的工厂。” 构造类还是用水果来举例，首先创建一个Fruit： 123interface Fruit03 &#123; void color();&#125; 创建橘子类： 123456class Orange03 implements Fruit03 &#123; @Override public void color() &#123; System.out.print("橘色"); &#125;&#125; 创建苹果类： 123456class Apple03 implements Fruit03 &#123; @Override public void color() &#123; System.out.print("苹果色"); &#125;&#125; 构建工厂工厂方法模式和简单工厂模式的不同之处就在于，工厂的创建，它会首先声明一个抽象工厂接口： 123interface Fruit03Factory &#123; Fruit03 getFruit();&#125; 然后针对每个水果，分别实现它们自己的工厂，首先是苹果工厂： 123456class Apple03Factory implements Fruit03Factory &#123; @Override public Fruit03 getFruit() &#123; return new Apple03(); &#125;&#125; 然后是橘子工厂： 123456class Orange03Factory implements Fruit03Factory &#123; @Override public Fruit03 getFruit() &#123; return new Orange03(); &#125;&#125; 测试用例12345public static void main(String[] args) &#123; Fruit03Factory aplfactory = new Apple03Factory(); Fruit03 fruit03 = aplfactory.getFruit(); fruit03.color();&#125; 设计模式的原则遵守了开闭原则，不用去修改已存在的工厂，和简单工厂方法最大的区别就在于，它为每个类都配备了一个专属的工厂，这些工厂都实现了同一个抽象工厂接口。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式]]></title>
    <url>%2F2014%2F06%2F16%2FSimple_Fac_Pat%2F</url>
    <content type="text"><![CDATA[“当你想要创建对象的时候，可能不知不觉就已经使用了简单工厂模式。” 构造类这里还是用水果来举例，先创建一个Fruit： 123interface Fruit02 &#123; void color();&#125; 创建具体的水果： 12345678910111213141516171819202122class Orange02 implements Fruit02 &#123; public Orange02() &#123; System.out.println("我是橘子。"); &#125; @Override public void color() &#123; System.out.println("颜色：橙色"); &#125;&#125;class Apple02 implements Fruit02 &#123; public Apple02() &#123; System.out.println("我是苹果。"); &#125; @Override public void color() &#123; System.out.println("颜色：红色"); &#125;&#125; 以上创建了橘子类和苹果类。 构造工厂接下来是工厂类： 1234567891011class FruitFactory &#123; public static Fruit02 getFruit(String type) &#123; Fruit02 fruit = null; if (type.equalsIgnoreCase("Orange")) &#123; fruit = new Orange02(); &#125; else if (type.equalsIgnoreCase("Apple")) &#123; fruit = new Apple02(); &#125; return fruit; &#125;&#125; 用if判断语句配合传入的字符串参数来选择创建什么的对象。 测试用例1234public static void main(String[] args) &#123; Fruit02 fruit02 = FruitFactory.getFruit("Apple"); fruit02.color();&#125; 设计模式的原则简单工厂模式虽然对创建对象的行为进行了封装，但是违背了开闭原则，因为每次添加一个类都要对原工厂进行修改。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2014%2F06%2F15%2FObserver_Pat%2F</url>
    <content type="text"><![CDATA[“订阅对方，就是注册自己。” 设计逻辑观察者模式很适合用“读者订阅信息”来说明，而书上更是直言“出版者 + 订阅者 = 观察者模式”。现假设有这样一个新闻机构p，它会以when、where、what的形式向订阅它的读者c们发送信息。实现一种一对多的依赖，这样一来p一旦改变状态，它的所有订阅者都会收到通知并更新。 注册注册的逻辑是发生在新闻机构内部的，只有通过注册，它才能知道去更新哪些订阅者的信息。首先抽象出P： 12345interface P &#123; public void registerC(C c); public void removeC(C c); public void notifyC();&#125; 接下来实现具体的“新闻机构”： 123456789101112131415161718192021222324252627282930313233343536373839class ImlP implements P &#123; private ArrayList cs; private String when; private String where; private String what; public ImlP() &#123; cs = new ArrayList(); &#125; @Override public void registerC(C c) &#123; cs.add(c); &#125; @Override public void removeC(C c) &#123; int i = cs.indexOf(c); if (i &gt;= 0) &#123; cs.remove(i); &#125; &#125; @Override public void notifyC() &#123; for (int i = 0; i &lt; cs.size(); i++) &#123; C c = (C)cs.get(i); c.update(when, where, what); &#125; &#125; public void reSetData(String when, String where, String what) &#123; this.when = when; this.where = where; this.what = what; notifyC(); &#125;&#125; 代码中，注册是ImlP的方法，通过该方法，将订阅者某c注册在自己的内部容器中。 订阅首先抽象出订阅者： 123interface C &#123; public void update(String when, String where, String what);&#125; 接下来实现具体的订阅者： 12345678910111213141516171819202122232425class ImlC implements C, Message&#123; private String when; private String where; private String what; private P p; public ImlC(P p) &#123; this.p = p; p.registerC(this); &#125; @Override public void update(String when, String where, String what) &#123; this.when = when; this.where = where; this.what = what; message(); &#125; @Override public void message() &#123; System.out.println("时间：" + when + "\n地点：" + where + "\n事件：" + what); &#125;&#125; 这里用到了一个辅助类Message： 123interface Message &#123; void message();&#125; 测试用例123456public static void main(String[] args) &#123; P specP = new ImlP(); C specC = new ImlC(specP); ((ImlP)specP).reSetData("早上十点", "叙利亚", "停战");&#125; 设计模式的原则这个例子我学习到的设计原则： 设计原则1：为了交互对象之间的松耦合设计而努力。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2014%2F06%2F15%2FStrategy_Pat%2F</url>
    <content type="text"><![CDATA[前言关于设计模式，我想写一个简单的笔记，方便知识的记忆。该笔记主要参考了《Head First 设计模式》这本书。 策略的提出先写一个“水果”类： 123public class Fruit &#123;&#125; 大部分人都爱吃水果，但这部分人对不同的水果又有不同的喜好。水果的一些特质可以分为两部分： 一部分指的是广泛被接受的，比如干净，估摸着很少有人喜欢吃不干净的水果； 一部分指的是颜色、酸甜等等，不同的人对此接受程度是不一样的，可以用UniqueHobby接口抽象出来。 策略的实施我们首先来写可能不会变化的部分，这里我就单列干净程度： 12345public abstract class Fruit &#123; ... public abstract void cleanliness ();&#125; 接下来要处理喜好可能有差别的部分，首先把这一部分抽象出来： 123public interface UniqueHobby &#123; public void uniqueHobby();&#125; 接下来实现不同特质： 1234567891011public class Kind1 implements UniqueHobby &#123; public void uniqueHobby() &#123; System.out.println("红色水果！"); &#125;&#125;public class Kind2 implements UniqueHobby &#123; public void uniqueHobby() &#123; System.out.println("黄色水果"); &#125;&#125; 接下来的问题是，抽象出来的特质如何在Fruit类中体现呢？？其实，只需要声明成字段就可以了，同时为了执行抽象的行为，还要添加具体的实现方法，代码如下： 1234567public abstract class Fruit &#123; UniqueHobby uniqueH; public abstract void cleanliness(); public void performMethod() &#123; uniqueH.uniqueHobby(); &#125;&#125; 接下来只要单独去实现各自的类，就能针对不同具体的水果指定方案了，以Orange方案为例： 12345678public class Orange extends Fruit &#123; public Orange (UniqueHobby uh) &#123; uniqueH = uh; &#125; public void cleanliness() &#123; System.out.println("水果已被服务人员清洗干净"); &#125;&#125; Ok，接下来我们写一个例子测试一下：123456public class Test &#123; public static void main(String[] args) &#123; Fruit o1 = new Orange(new Kind1()); o1.performMethod(); &#125;&#125; 设计模式的原则从这个例子中，我们学到了三个设计模式原则： 设计原则1：找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。在该例子中，我把所有可变的需求首先用UniqueHobby接口抽象出来了，把他们单独弄在一边； 设计原则2：针对接口编程，而不是针对实现编程，不需要new硬编码，而是在运行时才指定具体的实现对象。在本例子中，最大的体现在于WhitePlan类中的构造方法的写法。 设计原则3：多用组合，少用继承。在本例子中，这一点体现在抽象类Human中声明成员变量那一步，即：UniqueHobby uniqueH;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式原则]]></title>
    <url>%2F2014%2F06%2F10%2FDesign_Pat_Principle%2F</url>
    <content type="text"><![CDATA[设计模式通常遵守以下原则。 单一职责原则 一个类只负责一项职责； 里氏替换原则 子类可以扩展父类的功能，但不能改变父类原有的功能。 子类可以实现父类的方法，但是不能覆盖父类的非抽象方法； 子类可以增加自己特有的方法； 子类的方法重载父类方法时，方法的形参要比父类的方法的输入更宽松； 子类的方法在实现父类的抽象方法时，方法的返回值要比父类更严格； 依赖倒置原则 高层模块不应该因爱低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 问题：A依赖类B，现在改为A依赖接口C，则必须通过修改类A的代码来实现。类A一般为高层模块，负责复杂的业务逻辑，类B和C是底层模块，负责基本的原子操作，假设修改类A，会带来不必要的风险； 解决：将A修改为依赖接口I，类B和类C各自实现接口I； 接口隔离原则 客户端不应该依赖他不需要的接口； 一个类对另一个类的依赖应该建立在最小的接口上； 类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类C必须去实现他们不需要的方法； 解决：将臃肿的接口I分拆为独立的几个接口； 迪米特法则 一个对象应该对其他对象保持最少的了解； 开闭原则 对扩展开放，对修改关闭； 理论上来说就是在扩展代码的过程中，不要对原有的旧代码引入错误；]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式原则</tag>
      </tags>
  </entry>
</search>
